<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ADC相关性能参数概念]]></title>
    <url>%2F2019%2F10%2F23%2FADC%E7%9B%B8%E5%85%B3%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[- 前言补基础 目录 1. 量化误差 2. DNL 3. INL 4. SNR 5. ENOB 6. THD 7. ADC的输入阻抗 8. ADC的转换时间 9. 参考资料 1. 量化误差用简单3bit ADC来说明。 输入电压被数字化，以8个离散电平来划分，分别由代码000b到111b去代表它们，每一代码跨越Vref/8的电压范围。 代码大小一般被定义为一个最低有效位（Least Significant Bit，LSB）。 若假定Vref＝8V时，每个代码之间的电压变换就代表1V。如图中橙色线所示，即当输入电压为0.5V或者1.5V时，ADC输出的结果都是1V，这里的误差称为量化误差。 2. DNL3. INL4. SNR5. ENOB6. THD7. ADC的输入阻抗8. ADC的转换时间9. 参考资料 谈谈ADC的相关性能参数(一) ADC的INL和DNL]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>ADC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈BLE核心架构和数据帧]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%B5%85%E8%B0%88BLE%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[谈谈大家平常少接触的蓝牙核心规范中关于ble有趣的部分，点到即止。 前言蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。 目录 1. ble核心规范简介 1.1. ble核心系统架构 1.1.1. host 1.1.2. controller 1.1.3. hci 1.2. ble传输载体 1.2.1. le link layer到LE-C的signaling数据帧 1.2.2. le link layer到ADVB-C的signaling数据帧 1.2.3. l2cap manager的signaling数据帧 1.2.4. 更高层协议的signaling数据帧 1.2.5. 可靠的异步用户数据帧 1.2.6. 不可靠的异步用户数据 1.2.7. 举例 1. ble核心规范简介下面从两个角度来总览ble协议，一个是从协议层级划分角度，即下文ble核心系统架构章节，另一个是协议数据流向角度，即下文ble传输载体章节。 NOTE：运输载体英文原文是traffic bearers，有种小船之于水流的感觉，我不知道如何翻译才贴切，欢迎各位提建议。 1.1. ble核心系统架构下图为ble核心系统架构（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），ble核心架构可划分为两部分，分别是host和controller。 1.1.1. host gatt att gap smp l2cap 1.1.2. controller device manager link manager baseband resource manager link controller phy 1.1.3. hcihost和controller可通过hci（host-controller-interface）接口互相通信。具体表现为： host通过hci向controller发送command controller通过hci向host发送event host和controller通过hci互传acl data 1.2. ble传输载体下图为ble传输载体示意图（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），左边Application表示host中除l2cap以外部分的集合，Bluetootch core表示l2cap和整个controller。 结合上图，ble协议中流动的所有数据帧如下，即使分包也是由以下部分帧拆分而来： 1.2.1. le link layer到LE-C的signaling数据帧 如ll control pdu的LL_FEATURE_REQ 1.2.2. le link layer到ADVB-C的signaling数据帧 如scanning pdu的SCAN_REQ 如initiating pdu的CONNECT_IND 1.2.3. l2cap manager的signaling数据帧 如l2cap的connection parameter update request 1.2.4. 更高层协议的signaling数据帧 如smp的pairing request 1.2.5. 可靠的异步用户数据帧 如gatt的write without response，其中att_payload包含用户数据 1.2.6. 不可靠的异步用户数据 如advertising的ADV_IND，其中adv_payload包含ad type格式的用户数据 1.2.7. 举例针对上述帧举一个例子详细说明，目的是理清关系。 例子中有两个角色，一个是嵌入式蓝牙设备，称为device，另一个是手机，称为app。 如图所示从左到右为角色的每一层，从上到下为时间线。图中的交互行为并不完整，如：缺少响应包，但是这不影响我们的阅读。 双方处于未连接状态 某个时刻device’s gap通过hci发送command，让device’s controller开始发送ADV_IND，即开始广播，其中ADV_IND中包含device的设备名。 某个时刻app’s gap通过hci发送command，让app’s controller开始发送SCAN_REQ，即开始扫描周边蓝牙设备。 app’s controller发现了正在广播的device，随后通知app’s gap，紧接着app’s gap通过hci发送command，让app’s controller开始发送CONNECT_IND，即发起连接请求 双方刚刚建立连接状态 app’s controller向device ‘s controller发送LL_FEATURE_REQ，希望知道刚刚连上的device支持哪些特性。 双方已经连接了一段时间状态 连接一段时间后，device觉得频繁与app通信影响功耗，所以device’s l2cap manager将connection parameter update request封装成acl data，通过hci发送给device’s controller，device’s controller随即将数据发给app’s l2cap manager，即连接参数更新请求，该请求要求加大连接间隔。 某个时刻app向发送用户数据给device，app’s gatt将write without response发送给l2cap，l2cap将write without response封装成acl data通过hci发送给app’s controller，让app’s controller开始发送write without respon给device’s gatt。 某个时刻app觉得传输明文用户数据太危险，即app’s smp发起了pairing request给l2cap，l2cap将pairing request封装成acl data通过hci发送给app’s controller，让app’s controller开始发送pairing request给device’s smp。]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>ble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——移植nimble（3）]]></title>
    <url>%2F2019%2F10%2F09%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%A7%BB%E6%A4%8Dnimble%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[站在巨人的肩膀上可以看的更远。 前言移植目标：手机app可以搜索到ble广播，能成功连接并发现服务。 目录 1. 土方法 2. 移植host 2.1. 添加nimble 2.2. 添加空白SConscript 2.3. 移植阶段一 2.3.1. 无法打开头文件 2.3.2. 无法打开头文件（缺少头文件） 2.3.3. 无法打开头文件（存在多个同名头文件） 2.3.4. 缺少标识符定义 2.4. 移植阶段二 2.4.1. 缺少endian.c中实现的函数 2.4.2. 缺少mem.c中实现的函数 2.4.3. 缺少os_mbuf.c实现的函数 2.4.4. 缺少os_mempool.c实现的函数 2.4.5. 缺少nimble_port.c实现的函数 2.4.6. 缺少os_msys_init.c实现的函数 2.4.7. 缺少tinycrypt加密组件 2.5. 移植阶段三 2.5.1. 存在多个ble_hc_trans_xxxx同名函数 2.5.2. 缺少ble_npl_xxx函数定义 2.6. 移植host总结 3. 移植controller 3.1. 移植阶段一 3.1.1. 无法打开头文件 3.2. 移植阶段二 3.2.1. 无法打开头文件（存在多个同名头文件） 3.2.2. 缺少标识符定义 3.2.3. 无法识别内联汇编 3.2.4. 缺少ble_hw.c中实现的函数 3.2.5. 缺少os_cputime.c中实现的函数 3.2.6. 缺少os_cputime_pwr2.c中实现的函数 3.2.7. 缺少hal_timer.c中实现的函数 3.2.8. 缺少ble_npl_hw_set_isr函数定义 3.2.9. 缺少ble_npl_hw_is_in_critical函数定义 3.3. 移植controller总结 4. 移植profile 4.1. 添加心率profile 4.2. 移植proifile总结 5. 启动运行 5.1. 缺少标识符定义 5.2. 修复bug 5.3. 添加调试 5.4. 编译烧录 6. 总结 1. 土方法第一个问题，nimble的porting目录看不懂，钻牛角尖要不得，故跑到大佬的github上寻求解决方案。 然后有了第一个解决思路：基于可以正常运行的工程，将部分nimble源文件从SConscript脚本中移除。 然后第二个问题来了，移除哪些源文件？ 按照笔者对nimble官方文档的了解，nimble支持host和controller解耦，那么第一步移植工作就先保留host代码，将controller部分全部移除掉。 2. 移植host2.1. 添加nimble将官网下载的nimble压缩包解压，并将生成的文件夹复制粘贴到myboard目录下，即rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0。 2.2. 添加空白SConscript添加SConscript文件到nimble目录下，即rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\SConscript。 2.3. 移植阶段一把所有rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\nimble\host里面除了mesh文件夹和test文件夹以外的.c文件加进刚创建的空白SConscript脚本。 NOTE：ble mesh后面再挖坑，这里先不展开。 按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。 2.3.1. 无法打开头文件1error: #5: cannot open source input file &quot;sysinit/sysinit.h&quot;: No such file or directory 错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为cwd + &#39;/porting/nimble/include&#39;，同类报错可用同样方法解决。 2.3.2. 无法打开头文件（缺少头文件）1error: #5: cannot open source input file &quot;base64/base64.h&quot;: No such file or directory 错误原因：nimble包没有该文件解决办法：从mynewt的encoding目录下，拷贝base64到rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\ext\，并在SConscript中添加路径，该例子需要添加的路径为cwd + &#39;/ext/base64/include&#39;。 2.3.3. 无法打开头文件（存在多个同名头文件）1error: #5: cannot open source input file &quot;nimble/nimble_npl_os.h&quot;: No such file or directory 错误原因：nimble包有多个该文件，只是没有将头文件目录添加进编译脚本解决方法：该文件定义了os的抽象接口，协议栈会调用这些接口，这些接口的实现每个os都不一样，我们这里参考rt-thread官方做法，直接下载该文件夹到rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\npl下，并在SConscript中添加路径，该例子需要添加的路径为cwd + &#39;/porting/npl/rtthread/include&#39;。 2.3.4. 缺少标识符定义1error: #20: identifier &quot;MYNEWT_VAL_BLEUART_MAX_INPUT&quot; is undefined 错误原因：缺少宏定义解决方法：将nimble/host/services/bleuart/src/bleuart.c从SConscript脚本中删除，暂不考虑实现该profile。 1error: #20: identifier &quot;MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT&quot; is undefined 错误原因：缺少宏定义解决方法：将nimble/host/services/dis/src/ble_svc_dis.c从SConscript脚本中删除，暂不考虑实现该profile。 2.4. 移植阶段二经过上节处理之后，编译均是以下错误： 1Error: L6218E: Undefined symbol xxxx (referred from xxxx). host文件夹内的代码会引用其他目录下的公共组件以及公共函数。组件如：内存池，函数如：大小端转换函数。 所以该阶段目标是将host文件夹依赖的公共组件和公共函数补充完整。 2.4.1. 缺少endian.c中实现的函数解决方法：将porting/nimble/src/endian.c添加进SConscript脚本。 2.4.2. 缺少mem.c中实现的函数解决方法：将porting/nimble/src/mem.c添加进SConscript脚本。 2.4.3. 缺少os_mbuf.c实现的函数解决方法：将porting/nimble/src/os_mbuf.c添加进SConscript脚本。 2.4.4. 缺少os_mempool.c实现的函数解决方法：将porting/nimble/src/os_mempool.c添加进SConscript脚本。 2.4.5. 缺少nimble_port.c实现的函数解决方法：将porting/nimble/src/nimble_port.c添加进SConscript脚本。 2.4.6. 缺少os_msys_init.c实现的函数解决方法：将porting/nimble/src/os_msys_init.c添加进SConscript脚本。 2.4.7. 缺少tinycrypt加密组件解决方法：添加以下路径到SConscript文件。ext/tinycrypt/src/aes_decrypt.cext/tinycrypt/src/aes_encrypt.cext/tinycrypt/src/utils.c 2.5. 移植阶段三经过上节处理之后，编译剩下以下错误： 121. Error: L6218E: Undefined symbol ble_hci_trans_xxxx (referred from xxxx).2. Error: L6218E: Undefined symbol ble_npl_xxx (referred from xxxx). 前面做的移植操作，哪个平台都是一样的。而对于这两类错误，不同的应用场景和平台，解决方案会有所差异。 2.5.1. 存在多个ble_hc_trans_xxxx同名函数全局搜索nimble包会发现这些函数在多个.c文件中都有实现，位置如下： 123456789101112131415161718apache-mynewt-nimble-1.2.0└──nimble └──transport ├──da1469x │ └──src │ └──da1469x_ble_hci.c ├──emspi │ └──src │ └──ble_hci_emspi.c ├──ram │ └──src │ └──ble_hci_ram.c ├──socket │ └──src │ └──ble_hci_socket.c └──uart └──src └──ble_hci_uart.c 这意味着我们需要做出选择，为这些函数接口选择具体实现。这时候引入新问题，“我们在选择什么”。 参考这篇blog，可知： host和controller可通过hci（host-controller-interface）接口互相通信。具体表现为： host通过hci向controller发送command controller通过hci向host发送event host和controller通过hci互传acl data 而编译报错缺失的ble_hc_trans_xxxx函数为： ble_hci_trans_reset ble_hci_trans_cfg_hs（该API注册接收evt和acl data的回调函数） ble_hci_trans_buf_alloc ble_hci_trans_buf_free ble_hci_trans_hs_cmd_tx ble_hci_trans_hs_acl_tx 也就是我们在选择用什么样的transport来实现hci功能，即： 如果我们需要在一颗芯片上运行host+controller，那么就要选ble_hci_ram.c文件，即host和controller之间用ram通信。 如果我们需要在一颗芯片上运行host，另一颗芯片运行controller，那么就可以选ble_hci_uart.c文件，即host和controller之间用uart通信。 NOTE：市场上一些简单的智能设备，如手环、心率带、无线传感器，都会选择在一颗芯片上运行完整的协议栈，即host+controller，无论在成本还是开发上都会简单很多。但是一些比较复杂如多协议网关、机顶盒的产品，则需要一个强大的cpu跑linux，并用linux实现host（bluez、bluedroid），然后外挂一颗性能和成本较低的蓝牙芯片跑controller。 这里我们选择ble_hci_ram.c文件，将nimble/transport/ram/src/ble_hci_ram.c和cwd + &#39;/nimble/transport/ram/include&#39;加进SConscript。 2.5.2. 缺少ble_npl_xxx函数定义npl全称为nimble porting layer，顾名思义，这些函数是协议栈需要调用的接口，协议栈不会实现这部分内容，需要我们自己去实现，协议栈用到的所有接口在nimble_npl.h中。 这部分nimble没有注释说明接口该如何实现，移植者只能参考其他os的实现以及nimble协议栈调用接口代码，去猜这个函数做了什么，我不喜欢这一点。 这里我们将rt-thread官方已经移植好的代码加进SConscript，即porting/npl/rtthread/src/npl_os_rtthread.c。 NOTE：需要注释掉npl_os_rtthread.c里面的ble_npl_task_init函数。 2.6. 移植host总结总的来说，nimble中移植host功能需要关注以下几种类型代码。 host协议核心代码 公用组件和公用函数 hci transport os特定代码 myboard文件夹下载地址 3. 移植controller3.1. 移植阶段一把所有rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\nimble\controller里面除了test文件夹以外的.c文件加进之前的SConscript脚本。 按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。 3.1.1. 无法打开头文件1error: #5: cannot open source input file &quot;controller/ble_ll.h&quot;: No such file or directory 错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为cwd + &#39;/nimble/controller/include&#39;，同类报错可用同样方法解决。 3.2. 移植阶段二前面做的移植操作，无论哪个平台都是一样的。而接下来的操作，不同的应用场景和平台，解决方案会有所差异。 3.2.1. 无法打开头文件（存在多个同名头文件）1error: #5: cannot open source input file &quot;ble/xcvr.h&quot;: No such file or directory xcvr英文原名为transceiver，即既有包含发射器，又有接收器的radio设备。 xcvr正常运行前需要有一段rampup时间 xcvr在发射器和接收器之间切换，需要软件执行时间 因为不同设备，这两个参数会有比较大差异，而ble对于时间的要求又是us级别的，所以需要移植者根据自己的硬件设备来实现。 这里我们选择nrf52的xcvr文件，将nimble/drivers/nrf52/src/ble_phy.c和cwd + &#39;/nimble/drivers/nrf52/include&#39;加进SConscript。 3.2.2. 缺少标识符定义1error: #20: identifier &quot;MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT&quot; is undefined 协议栈要正常运行必须有一些默认参数，否则编译不通过，如：射频发射功率、支持最大连接数等，参数以及参数的说明可以从目录对应的syscfg.yml文件获知。 由于我们不使用rt-thread提供的软件包功能，所以将用该文件替换如下路径同名文件：rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\npl\rtthread\include\config\config.h。 同时在rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\nimble\include\syscfg\syscfg.h文件开头位置中include该头文件： 123456789101112#ifndef H_MYNEWT_SYSCFG_#define H_MYNEWT_SYSCFG_...#define MYNEWT_VAL(x) MYNEWT_VAL_ ## x#include "config/config.h"...#endif NOTE：因为通过宏定义配置参数的文件都会include &lt;syscfg/syscfg.h&gt;文件，将include “config/config.h”放在该文件前可以起到全局配置的作用。 3.2.3. 无法识别内联汇编1error: #18: expected a &quot;)&quot; 用c来实现内联汇编的功能，用该文件替换如下路径同名文件，即：rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\nimble\drivers\nrf52\src\ble_phy.c。 3.2.4. 缺少ble_hw.c中实现的函数解决方法：将nimble/drivers/nrf52/src/ble_hw.c添加进SConscript脚本。 3.2.5. 缺少os_cputime.c中实现的函数解决方法：将porting/nimble/src/os_cputime.c添加进SConscript脚本。 3.2.6. 缺少os_cputime_pwr2.c中实现的函数解决方法：将porting/nimble/src/os_cputime_pwr2.c添加进SConscript脚本。 3.2.7. 缺少hal_timer.c中实现的函数解决方法：将porting/nimble/src/hal_timer.c添加进SConscript脚本。 3.2.8. 缺少ble_npl_hw_set_isr函数定义1Error: L6218E: Undefined symbol ble_npl_hw_set_isr (referred from ble_phy.o). 该接口用于设置中断号以及对应的中断服务函数。 这里我们将porting/npl/rtthread/src/nrf5x_isr.c添加进SConscript脚本。 3.2.9. 缺少ble_npl_hw_is_in_critical函数定义在rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\npl\rtthread\src\npl_os_rtthread.c中修改如下实现： 1234567891011121314151617181920volatile int ble_npl_in_critical = 0;uint32_t ble_npl_hw_enter_critical(void)&#123; ++ble_npl_in_critical; return rt_hw_interrupt_disable();&#125;void ble_npl_hw_exit_critical(uint32_t ctx)&#123; --ble_npl_in_critical; rt_hw_interrupt_enable(ctx);&#125;bool ble_npl_hw_is_in_critical()&#123; return (ble_npl_in_critical &gt; 0);&#125; 3.3. 移植controller总结总的来说，nimble中移植controller功能需要关注以下几种类型代码。 controller协议核心代码 硬件平台差异文件（ble_phy.c/ble_hw.c/nrf5x_isr.c） 公用组件和公用函数(hal_timer.c/…) 应用宏定义配置文件（config.h/syscfg.yml） myboard文件夹下载地址 4. 移植profile不同的应用场景对于蓝牙核心协议栈（host+controller）的用法不一样，为了规范化和互联互通，针对某些应用场景，会有一套蓝牙核心协议栈的操作指南，这份指南称为profile。 4.1. 添加心率profile下载rt-thread官方推荐的应用代码，添加进rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\apps\blehr\src\文件夹。 将apps/blehr/src/gatt_svr.c添加进SConscript脚本。 将apps/blehr/src/blehr.c添加进SConscript脚本。 将cwd + &#39;/apps/blehr/src&#39;添加进SConscript脚本。 4.2. 移植proifile总结添加profile的过程比较杂乱，但这没办法，因为profile和os、nimble的启动方式等等都有耦合，特别是rtthread这里启动nimble的方式有点绕。 5. 启动运行经过上节处理之后，编译报以下错误： 1Error: L6218E: Undefined symbol ble_hs_thread_startup (referred from blehr.o). 解决方法：将porting/npl/rtthread/src/nimble_port_rtthread.c添加进SConscript脚本。 通过阅读nimble_port_rttherad.c文件得知，如果需要支持controller，还需要先增加宏定义NIMBLE_CFG_CONTROLLER=1，所以将该宏定义添加进SConscript脚本。 5.1. 缺少标识符定义1234567error: #20: identifier &quot;MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE&quot; is undefinederror: #20: identifier &quot;MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY&quot; is undefinederror: #20: identifier &quot;MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE&quot; is undefinederror: #20: identifier &quot;MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY&quot; is undefined 在porting/npl/rtthread/include/config/config.h文件添加以下内容： 1234567891011121314151617//thread config#ifndef MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE#define MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE (2048)#endif#ifndef MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY#define MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY (5)#endif#ifndef MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE#define MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE (2048)#endif#ifndef MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY#define MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY (4) // must higher than MYNEWT_VAL_BLE_HOST_TASK_PRIORITY, numerically smaller#endif 5.2. 修复bug将rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\nimble\include\os\endian.h文件1#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ 改为： 1#if defined (__BYTE_ORDER__) &amp;&amp; (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) 5.3. 添加调试将porting/npl/rtthread/src/modlog.c添加进SConscript脚本。 用该文件替换rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\npl\rtthread\src\modlog.c。 用该文件替换rt-thread\bsp\myboard\apache-mynewt-nimble-1.2.0\porting\nimble\include\modlog\modlog.h。 5.4. 编译烧录myboard文件夹下载地址 生成工程、编译、烧录后，在串口调试助手输入ble_hr，设备开始广播。 6. 总结通过这一章节的学习，对于nimble的目录结构、参数配置方式，有更深刻的认识。]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——移植bsp（2）]]></title>
    <url>%2F2019%2F10%2F09%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%A7%BB%E6%A4%8Dbsp%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[为你的bsp建立一个干净的项目框架。 前言博主不喜欢从零开始造轮子，但是有“不试一下鬼知道做了什么”强迫症，因此钟爱搬运移植文件，用一些土方法来理清软件之间的关系以及换一个平台怎么办的思路。 移植目标：移植rt-thread到开发板上，并通过串口打印hello world。 目录 1. 建立项目框架 1.1. 认识nrfx 1.2. rt-thread构建环境 1.2.1. 创建bsp文件夹 1.2.2. 添加bsp的模板工程 1.2.3. 添加bsp的Kconfig 1.2.4. 添加bsp的rtconfig.py 1.2.5. 添加bsp的SConscript/SConstruct 1.2.6. 添加nrfx 1.2.7. 添加设备驱动实现 1.2.8. 添加应用层代码 1.3. 验证环境构建结果 1. 建立项目框架1.1. 认识nrfx文件夹路径：nRF5_SDK_15.3.0_59ac345\modules\nrfx nrfx由nordic提供的一系列外设驱动组成，无需集成厚重的标准SDK就能把芯片跑起来，是一个轻量级的驱动库。 移植只需要关注以下内容： 芯片类型宏定义 nrfx_config.h nrfx_glue.h nrfx_log.h CMSIS/include 芯片类型宏定义：在编译阶段必须加入一款芯片类型宏定义，否则编译会报错，后面会在SConscript中加入芯片类型宏定义。 12345678910111213141516171819202122232425262728293031323334/* Device selection for device includes. */#if defined (NRF51) #include "nrf51.h" #include "nrf51_bitfields.h" #include "nrf51_deprecated.h"#elif defined (NRF52810_XXAA) #include "nrf52810.h" #include "nrf52810_bitfields.h" #include "nrf51_to_nrf52810.h" #include "nrf52_to_nrf52810.h"#elif defined (NRF52811_XXAA) #include "nrf52811.h" #include "nrf52811_bitfields.h" #include "nrf51_to_nrf52810.h" #include "nrf52_to_nrf52810.h" #include "nrf52810_to_nrf52811.h" #elif defined (NRF52832_XXAA) || defined (NRF52832_XXAB) #include "nrf52.h" #include "nrf52_bitfields.h" #include "nrf51_to_nrf52.h" #include "nrf52_name_change.h"#elif defined (NRF52840_XXAA) #include "nrf52840.h" #include "nrf52840_bitfields.h" #include "nrf51_to_nrf52840.h" #include "nrf52_to_nrf52840.h" #elif defined (NRF9160_XXAA) #include "nrf9160.h" #include "nrf9160_bitfields.h" #else #error "Device must be defined. See nrf.h."#endif /* NRF51, NRF52810_XXAA, NRF52811_XXAA, NRF52832_XXAA, NRF52832_XXAB, NRF52840_XXAA, NRF9160_XXAA */ nrfx_config.h:该文件可以配置nrfx驱动，可以在keil在界面配置，如下图所示。 nrfx_glue.h该文件由未实现的宏定义组成，未实现宏定义可以看成钩子函数，nrfx驱动代码会调用这些钩子函数，如果需要用到该钩子函数，则实现，若不需要则留空。 如需要用到临界区，防止嵌套中断发生，nrfx_glue.h文件如下： 123456789/** * @brief Macro for entering into a critical section. */#define NRFX_CRITICAL_SECTION_ENTER() &#123;unsigned int ctx; ctx = nrfx_enter_critical();/** * @brief Macro for exiting from a critical section. */#define NRFX_CRITICAL_SECTION_EXIT() nrfx_exit_critical(ctx);&#125; 如不需要用到临界区，不考虑嵌套中断发生的情况，nrfx_glue.h文件如下： 123456789/** * @brief Macro for entering into a critical section. */#define NRFX_CRITICAL_SECTION_ENTER() /** * @brief Macro for exiting from a critical section. */#define NRFX_CRITICAL_SECTION_EXIT() nrfx_log.h同上 CMSIS/include 根据nrfx根目录README提示，可用doxygen生成文档，生成的文档中有下图红框要求。直接下载该文件夹即可，不需要修改。 1.2. rt-thread构建环境了解nrfx后，接下来就要将其与rt-thread的构建环境关联起来。 1.2.1. 创建bsp文件夹在bsp目录下创建文件夹myboard，即rt-thread\bsp\myboard。 1.2.2. 添加bsp的模板工程 rt-thread官方NOTE：要生成 MDK 或者 IAR 的工程文件，前提条件是 BSP 目录存在一个工程模版文件，然后 scons 才会根据这份模版文件加入相关的源码，头文件搜索路径，编译参数，链接参数等。而至于这个工程是针对哪颗芯片的，则直接由这份工程模版文件指定。所以大多数情况下，这个模版文件是一份空的工程文件，用于辅助 SCons 生成 project.uvprojx 或者 project.eww。 在调用scons --target=mdk5前，需在rt-thread\bsp\myboard先提供一个mdk模板工程： 下面简单演示模板工程创建过程。 1.2.3. 添加bsp的Kconfig将rt-thread\bsp\stm32f10x\Kconfig搬运到myboard目录下，删除Kconfig文件中不需要部分。 12345config SOC_STM32F1boolselect ARCH_ARM_CORTEX_M3default ysource &quot;$BSP_DIR/drivers/Kconfig&quot; 若在myboard目录下执行menuconfig，则menuconfig会根据rt-thread\bsp\myboard\Kconfig中的语句生成rt-thread\bsp\myboard\rtconfig.h，该头文件包含各种宏定义。 rt-thread\bsp\myboard\Kconfig文件可通过source语句引用其他目录下的Kconfig文件，协助其生成所需的宏定义，如以下例子： Kconfig文件的目录路径： 1234567rt-thread├──Kconfig # root Kconfig ├──src│ └──Kconfig # kernal src Kconfig└──bsp └──myboard └──Kconfig # bsp Kconfig rt-thread\bsp\myboard\Kconfig引用rt-thread\Kconfig语句： 123456config RTT_DIR string option env=&quot;RTT_ROOT&quot; default &quot;../..&quot;source &quot;$RTT_DIR/Kconfig&quot; rt-thread\Kconfig引用rt-thread\src\Kconfig语句： 1source &quot;$RTT_DIR/src/Kconfig&quot; rt-thread\src\Kconfig协助生成宏定义内容： 123456config RT_TICK_PER_SECOND int &quot;Tick frequency, Hz&quot; range 10 1000 default 100 help System&apos;s tick frequency, Hz. 在myboard目录下执行menuconfig配置后，会在rt-thread\bsp\myboard\rtconfig.h生成如下宏定义： 123456#ifndef RT_CONFIG_H__#define RT_CONFIG_H__#define RT_TICK_PER_SECOND 100#endif 最后其他.c文件可引用该头文件，并使用RT_TICK_PER_SECOND宏定义。实现在rt-thread\bsp\myboard用menuconfig就可以配置整个工程的静态设置，如： 1234567#include &lt;rtconfig.h&gt;void SystemClock_Config(void)&#123; SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND); NVIC_SetPriority(SysTick_IRQn, 0);&#125; 1.2.4. 添加bsp的rtconfig.py将rt-thread\bsp\nrf52832\rtconfig.py搬运到myboard目录下。 当调用sconsc --target=mdk5生成mdk工程时候，脚本会根据rt-thread\bsp\myboard\rtconfig.py文件中的变量CPU=&#39;cortex-m4&#39;选择对应的文件添加进工程，如下图针对性添加了m4内核的上下文切换文件。 1.2.5. 添加bsp的SConscript/SConstruct将rt-thread\bsp\nrf52832\SConscript和rt-thread\bsp\nrf52832\SConstruct搬运到myboard目录下。 删除SConscript文件中不需要部分。 1objs = objs + SConscript(os.path.join(cwd, &apos;nRF5_SDK_13.0.0_04a0bfd/components/SConscript&apos;)) 1.2.6. 添加nrfx参考官方的做法创建一个nordic文件夹，并在myboard\nordic目录下添加以下内容： CMSIS/include文件夹 nrfx文件夹 SConscript文件 1.2.7. 添加设备驱动实现参考官方的做法创建一个drivers文件夹，并在myboard\drivers目录下添加以下内容： board.c和board.h drv_gpio.c和drv_gpio.h drv_uart.c和drv_uart.h SConscript文件 1.2.8. 添加应用层代码参考官方的做法创建一个applications文件夹，并在myboard\applications目录下添加以下内容： application.c SConscript文件 其中application.c文件的main函数中包含打印hello world的代码，至于是如何从上电运行到main函数的，可参考启动流程。 1.3. 验证环境构建结果myboard文件夹下载地址 至此，最简洁的功能移植已经完成，后面验证是否移植成功，若成功串口助手将打印hello world。 进入rt-thread\bsp\myboard路径下，右键打开env。 用usb线将板子与PC连接 验证menuconfig功能，同时配置console名字 验证scons –target=mdk5 编译，烧录，观察串口打印信息 NOTE：rt_kprintf依赖rt_console_set_device函数1、若用rt_kprintf函数打印信息，则需要一个标记为console设备的通信接口设备。2、rt_console_set_device(console_name)函数从众多已注册通信接口设备中找到与参数console_name相同名字的设备，并将该设备标记为console设备。3、rt_hw_serial_register(uart0)函数注册一个名字为uart0的通信接口设备。所以生成mdk工程前，需要用menuconfig配置console_name为uart0，否则rt_kprintf就会由于找不到通信接口设备，导致无法打印信息。]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——预备知识（1）]]></title>
    <url>%2F2019%2F09%2F25%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[磨刀不误砍柴工，前期多做点理论积累，后期才能少掉坑。 前言rt-thread简介 nimble简介 目录 1. 导读 2. 系统 3. 蓝牙 4. 硬件 5. 软件 1. 导读知识点根据需要认知的程度分为：了解、理解、专业，对于知识点不建议强行记忆，建议多看、多想和多做，所谓读书百遍其意自现。 例子 程度 备注 信号量 了解 两个函数之间的共享变量，像全局变量标志位 理解 工作机制、API使用方法，无须深究源码 专业 略 一般从网上搜一篇文章就可以达到了解的程度，理解则需要多看几篇。 刚接触一个复杂的软件的时候，不建议深究源码，我个人的习惯是按照： 软件可以运行 理解裁剪 软件刚刚好可以运行 研究细节 就是想说学习方法很重要，不要钻牛角尖。 2. 系统关于rt-thread的入门资料，rt-thread文档中心这部分做的很cool，其中“内核”、“Env工具”、“设备和驱动”、“代码贡献-软件包开发”章节，建议至少看一遍。 知识点1（理解）：内核整个章节 知识点2（了解）：env的安装（只是为了运行scons和menuconfig） 知识点3（了解）：menuconfig的使用 Kconfig（该文件决定rt_config.h包含哪些宏定义，rt_config.h会被nimble协议栈include） 知识点4（了解）：scons的使用 scons --target=mdk5（keil编译和仿真） SConscript（修改该脚本，配合scons --target=mdk5来理解协议栈） 知识点5（理解）：设备和驱动 移植芯片驱动（尽量理解，后面移植章节介绍） 知识点6（了解）：软件包 Kconfig文件 这里除了知识点3和知识点5，其他知识点rt-thread官网已提供足够资料学习。 3. 蓝牙蓝牙核心规范下载地址 蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。 不同厂家根据自家芯片的特性，用代码去实现这份文档的内容，这些代码称为蓝牙协议栈。 基于蓝牙协议栈二次开发的工作，称为蓝牙应用开发。 学习蓝牙软件门槛不高，但是会有瓶颈： 它不难理解，不像人工智能需要有数学底蕴；它只是稍微复杂一点，花时间都能看懂，所以说门槛不高。 因为协议栈不开源，看不到底层实现，所以会遇到瓶颈。 nimble低功耗蓝牙协议栈，层层划分清晰，便于我们理解复杂的实现，而全开源解决了学习蓝牙软件的瓶颈问题，是学习蓝牙规范的一个好工具。 但要是商用就要斟酌一番，毕竟开源不收钱，出现bug只能自力更生。 知识点1：（理解）学习蓝牙软件不难，商用nimble需谨慎。 知识点2：（了解）蓝牙应用开发可通过博客/Q群/论坛等途径学习 推荐红旭论坛：http://bbs.wireless-tech.cn 4. 硬件只需要掌握一个硬件平台的知识点即可。 硬件：红旭 | HX-DK夏开发板 知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO 知识点2（了解）：从官方资料了解串口TX和RX引脚编号、LED灯引脚编号以及外围电路 硬件：nordic | nrf52 dk开发板 知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO 知识点2（了解）：从开发板背面了解串口TX和RX引脚编号、LED灯引脚编号及外围电路 5. 软件 rt-thread源码下载地址（后面文章使用v4.0.0版本） nimble源码下载地址（后面文章使用v1.2.0版本） mynewt源码下载地址 nrf52_sdk包下载地址（后面文章使用nRF5_SDK_15.3.0_59ac345版本） nrf的Device_Family_Pack下载地址（后面文章使用8.24.1版本） rt-thread官方移植nimble源码下载地址]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtt+nimble揭秘系列——题外话（0）]]></title>
    <url>%2F2019%2F09%2F25%2Frtt-nimble%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[- 前言这章与技术无关，是博主的一得之见，欢迎交流，求同存异。 目录 1. 为什么选rt-thread和nimble 1.1. 关于物联网 1.2. 关于rt-thread 1.3. 关于嵌入式软件 1.4. 关于ble协议栈 1.5. 关于时间投入 1. 为什么选rt-thread和nimble1.1. 关于物联网物联网的概念近几年开始重新翻炒起来，在5G技术的加持下，明眼人都能看出来这个万亿级市场钱途一片光明。 从现在各大厂在这一块布局来看，思路都是搭建从端到云的基础设施，开放平台接入，形成自己的生态圈，等到时机成熟再花式割韭菜，现在正处于一个攻城略地的白热化阶段。 大佬们在悄咪咪的抓住先机占领市场，建立生态。同样的，作为码农就应该有笨鸟先飞，抱紧大腿，学习新知识的觉悟。 依我愚见，各大厂的物联网操作系统（iot os）是一个不错的方向。 1.2. 关于rt-thread各家iot os技术指标，比如：上下文切换时间，快那么几个us等，对绝大部分应用场景来说，意义不大，所以这里不展开，趣度之。 我之所以选择rt-thread有以下考虑： C面向对象设计 集成nimble 上手门槛低 对国产老牌嵌入式os劲旅的支持 1.3. 关于嵌入式软件不少从事嵌入式行业的软件工作者，在上学期间没有接触过软件工程知识，博主就是之一。 工作一段时间后，写软件会有“套路章法”，有的来自公司祖传代码，有的是加班时一刹灵光，其中涉及的“道理”，问就是不知道，反正这样做就对了。 再到后来了解到：面向对象思想、SOLID设计原则、设计模式、uml等等，原来代码应该这样写，业务逻辑可以这样画出来。 嵌入式离不开底层，越是底层，代码设计越是精简，若是在精简中仍保持巧妙的设计思想，在我看来就是一份值得钻研的高质量代码。 rt-thread官方介绍系统采用C面向对象设计，这就很棒。在看了rtdef.h文件之后，很舒服，故决定拜读一下，要是能在其中领悟到一丝精髓也不错。 1.4. 关于ble协议栈市场上所有BLE芯片原厂都不会完全公开自己的协议栈，没有例外。如果想要研究完整协议栈（host + controller）的实现，要么到原厂去工作，要么目前就只能找全网仅有的以下两个开源协议栈。 zephyr 该项目有linux基金会背书，各大原厂形成社区一起维护，实力毋庸置疑。虽开发工具高效但学习成本高，不适合初学者，适合对开源项目有一定经验的人。 nimble 产自apache基金会（制订apache2 license的那个组织）。代码风格干净，与os耦合程度低，注释多，功能比zephyr少，适合学习。 1.5. 关于时间投入年轻人的时间是十分宝贵的。 我觉得年轻人不应该有“反正年轻，大把试错机会，先让子弹飞一会”的观念来麻痹自己，用战术上的勤奋来掩盖战略上的懒惰，选择比努力更重要。 研究协议栈已经算是术业专攻，如果不是工作刚需和兴趣，要注意时间投入回报问题。]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>rtthread</tag>
        <tag>nimble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coder Handbook]]></title>
    <url>%2F2019%2F08%2F17%2Fcoder-handbook%2F</url>
    <content type="text"><![CDATA[大佬有云： Talk is cheap. Show me the code. –Linus Torvalds 官方来说，代码好坏体现一个程序员的职业素养，在笔者看来代码是一个程序员的门面担当，在这个颜值即正义的时代，作为程序员如何码的一手好代码，是门必修课中的必修课。 前言 写该文档为目的是：形成一套平时监督自己代码是否合理的规范。 本文大部分的理论经验参考《Clean Code》——Robert C.Martin，如有理解不对，还请斧正。 最后，会附上笔者对于一些名词、动词对和形容词的理解。 目录 1. 命名 1.1. 代码简洁不代表模糊 1.2. 有意义的变量名 1.3. 避免使用编码或者前缀 1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词 2. 函数 2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。 2.2. 使用描述性名称 2.3. 命名方式要保持一致 2.4. 函数参数 2.5. 动词与关键词 2.6. 输出参数 2.7. 分隔指令与询问 2.8. 结构化编程 2.9. 如何写出心目中的函数 3. 注释 3.1. 好注释 4. 对象和数据结构 4.1. 数据抽象 4.2. 数据结构、对象的反对称性 4.3. LoD 5. 异常处理 5.1. 别传递null值 6. 附录 6.1. 名词 6.2. 动词 6.3. 形容词 1. 命名1.1. 代码简洁不代表模糊123456789/* * 不推荐 */uint8_t array[10];/* * 推荐 */uint8_t students_id[10]; 1.2. 有意义的变量名不要写a1，a2，a3，a，b，这样的变量名，除非在特定应用场景。 1.3. 避免使用编码或者前缀以前变量名带编码是因为编译器不会帮忙检查类型，要人工检查，现在编译器会帮忙检查类型，没必要增加冗余的东西。 12345678910111213/* * 不推荐 */uint32_t u32_student_id;uint8_t u8_student_weight;uint8_t *g_student_weight;uint8_t *g_student_height;/* * 推荐 */uint32_t student_id;uint8_t student_weight; 1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词我觉得在嵌入式行业会经常使用manager，controller等词，而每个人都会对它们有不同的定义，在不同场景它们也确实有不同的意义，所以就是会产生歧义和模糊性，除非对于这些名词有比较好的区分说明和规范，否则不太推荐使用，推荐使用大家能不产生歧义的名词。 1234567891011121314151617181920212223242526272829303132333435/* * 不推荐 */struct manager &#123; ...&#125;;struct processor &#123; ...&#125;;struct data &#123; ...&#125;;struct info &#123; ...&#125;;/* * 推荐 */struct student_info &#123; uint32_t weight; uint32_t height; ...&#125;;enum customer_hobbies &#123; FOOTBALL, BASKETBALL, ...&#125;;uint8_t dev_addr[6]; 2. 函数2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。123456789101112131415161718192021222324252627282930313233343536373839404142/* * 一个抽象层（发送数据），做一件事情（发数据），推荐 */void send_fifo_data(void *fifo)&#123; if (!is_fifo_empty(fifo)) &#123; send(fifo); &#125;&#125;/* * 两个抽象层（发送数据、fifo为空），做一件事情（发数据），不推荐 */void send_fifo_data(void *fifo)&#123; if (!is_fifo_empty(fifo)) &#123; if (first_elem_in_fifo(fifo) == 0xa5) &#123; send(fifo); &#125; &#125;&#125;/* * 两个函数，两个抽象层，做了两件事情，函数自顶向下，不窜层，推荐 */void send_fifo_data(void *fifo)&#123; if (is_fifo_valid(fifo)) &#123; send(fifo); &#125;&#125;uint8_t is_fifo_valid(void *fifo)&#123; if (is_fifo_empty(fifo)) &#123; return 0; &#125; if (first_elem_in_fifo(fifo) == 0xa5) &#123; return 1; &#125;&#125; 2.2. 使用描述性名称函数内容应该尽可能短，但是函数名称没限制，只要能把事情描述清楚，长一点没问题。 2.3. 命名方式要保持一致123456789101112131415/* * 推荐 */uint32_t get_year();uint32_t get_month();uint32_t get_day();uint32_t get_hour();/* * 不推荐 */uint32_t get_year();uint32_t month_get();uint32_t fetch_day();uint32_t read_hour(); 2.4. 函数参数个数越少越好，最好没有。 参数多会导致单元测试出现很多分支，覆盖率复杂。 如果参数多于3个，说明需要定义一个结构体了。 2.5. 动词与关键词12345678910/* * 一元函数，应该遵循：动词/名词结构比较好。 */void write(void *name)void write_field(void *name)/* * 二元函数，参数包含在函数名内，可以防止我们对于参数输入顺序出错，也是不错的选择 */void is_a_larger_b(void *a, void *b); 2.6. 输出参数尽量避免输出过多参数，可以用对象参数或者返回值来替代。 123456789/* * len是希望读到buf的个数，p_len是实际读到buf的个数 */void read_bytes(void *fifo, void *buf, uint8_t len, void *p_len);/* * len是希望读到buf的个数，返回值是实际读到buf的个数 */uint32_t read_bytes(void *fifo, void *buf, uint8_t len); 2.7. 分隔指令与询问函数要么做什么事，要么回答什么事，不要两者兼得。 1234567891011121314151617181920/* * 设置名字属性，如果name已经存在，则返回1，否则返回0。（不推荐） */uint8_t set_attribute(void *name, void *val)&#123; if (name) &#123; return 1; &#125; name = val; return 0;&#125;/* * 分开两个函数比较合理，然后用以下形式实现。（推荐） */if (!is_attribute_exist(name)) &#123; set_attribute(name, val);&#125; 2.8. 结构化编程Edsger Dijkstra提出结构化编程，即每个函数，只能有一个入口和一个出口。 永远不能出现goto 循环中不能出现break和continue 每个函数只有一个return 这个原则用在复杂的大函数效果显著，在小函数可以适当出现return和break，但是goto还是不要出现。 2.9. 如何写出心目中的函数尝试 + 单元测试 + 提炼，循环上述步骤。 3. 注释3.1. 好注释 对意图的注释 12345678910111213void uart_receiver_fsm()&#123; uint8_t chr; if (is_fifo_not_empty(&amp;fifo)) &#123; chr = get_elem(&amp;fifo); /* * 当收到第一个字节时候便打开接收超时定时器， * 用于计算接收超时 */ timer_start(0); &#125;&#125; 阐释 12345678910111213/* * 当a==b的时候，compare返回0 */if (comapre(a, b) == 0) &#123; ...&#125;/* * 当a &gt; b(asc2)的时候，compare返回1 */if (comapre(a, b) == 1) &#123; ...&#125; 4. 对象和数据结构4.1. 数据抽象 抽象接口不是简单的取值器和赋值器 12345678910111213141516171819/* * 不推荐，battery对象的接口只是将能量数值以函数形式暴露， * 这里的几个接口函数就是简单取值器，没有太多抽象作用。 */typedef struct &#123; uint32_t remained_energy_in_mw; ...&#125; battery_t;uint32_t get_remained_energy_in_mw(battery_t *self);/* * 推荐，battery对象的接口将能量抽象成百分比形式， * 没有暴露具体数值和单位。 */typedef struct &#123; uint32_t remained_energy_in_mw; ...&#125; battery_t;uint32_t get_remained_percent_energy(battery_t *self); 要以最好的形式呈现对象的数据，不能随意加取值期和赋值器。 4.2. 数据结构、对象的反对称性 过程式代码：暴露数据结构细节，便于在不改动数据结构基础上增添函数。 面向对象式代码：隐藏数据结构细节，便于在不改动函数的基础上增添新类。 过程式代码难修改数据结构，因为这样需要修改全部函数。面向对向式代码难修改函数，因为这样需要修改全部类。所以需要根据实际情况权衡什么时候使用哪种代码。 混杂对象和数据结构 混杂增加了添加新函数的难度，也增加了添加数据结构的难度，两面都不讨好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/* * 推荐，过程式代码，数据结构暴露数据，不提供有意义的函数 * 优势：添加/修改新的函数不会影响数据结构（比如增加计算形状周长函数） * 缺陷：修改数据结构影响所有函数（比如增加一个新的形状） */enum &#123; SQUARE, RECTANGLE, CIRCLE,&#125;;typedef struct &#123; uint8_t type; union &#123; ... &#125; ...&#125; shape_info_t;uint32_t get_area(shape_info_t *shape_info)&#123; switch (shape_info-&gt;type) &#123; case SQUARE: ... break; case RECTANGLE: ... break; case CIRCLE: ... break; &#125;&#125;/* * 推荐，面向对象式代码，隐藏数据，暴露操作数据的函数（shape_get_area） * 优势：添加/修改新的数据结构很简单（比如增加一个长方形），对原来的函数没有任何影响。 * 缺陷：如果需要增加一个获取形状周长的函数，那么全部形状都需要修改。 * NOTE：这里的关系是is a，如果是has a关系，那么结构体变量类型shape_t应该是shape_t * */#define PI 3.1415926typedef uint32_t (*pfn_get_area_t)(void);typedef struct &#123; pfn_get_area_t get_area;&#125; shape_t;typedef struct &#123; shape_t shape_ops; uint32_t r; &#125; circle_t;typedef struct &#123; shape_t shape_ops; uint32_t side; &#125; square_t;static uint32_t __cicrle_get_area(void)&#123; return PI * r * r;&#125;static uint32_t __square_get_area(void)&#123; return side * side;&#125;circle_t c1 = &#123; .shape_ops = __cicrle_get_area,&#125;;square_t s1 = &#123; .shape_ops = __square_get_area,&#125;;uint32_t shape_get_area(shape_t *shape)&#123; return shape-&gt;get_area();&#125;void main()&#123; shape_get_area((shape_t *)&amp;c1); shape_get_area((shape_t *)&amp;s1); &#125;/* * 不推荐，一半对象，一半数据结构，既拥有函数，又拥有公共变量。 * 缺陷：添加新函数难，添加新数据结构难。 * 如果需要添加形状（即公共变量改变），则访问公共变量的函数都要修改 * 如果需要新增一个获取周长的抽象方法（即增加执行函数），则所有形状对象都要修改 */enum &#123; SQUARE, RECTANGLE, CIRCLE,&#125;;typedef struct &#123; uint8_t type; uint8_t color_var1; uint8_t color_var2;&#125; shape_info_t;typedef uint32_t (*pfn_get_color_t)(void);typedef struct &#123; shape_info_t shape_info; //公共变量 pfn_get_color_t get_color; //执行函数&#125; shape_t;typedef struct &#123; shape_t shape; uint32_t r; &#125; circle_t;typedef struct &#123; shape_t shape; uint32_t side; &#125; square_t;static uint32_t __circle_get_color(void)&#123; return color_val1 * color_val2;&#125;static uint32_t __square_get_color(void)&#123; return color_val1 + color_val2;&#125;uint8_t shape_get_color(shape_t *shape)&#123; return shape-&gt;get_color();&#125;uint32_t shape_get_area(shape_t *shape)&#123; /* * 访问公共变量 */ switch (shape-&gt;shape_info.type) &#123; case SQUARE: ... break; case RECTANGLE: ... break; case CIRCLE: ... break; &#125;&#125;circle_t c1 = &#123; .shape_info.type = CIRCLE, ...&#125;;square_t s1 = &#123; .shape_info.type = SQUARE, ...&#125;;void main()&#123; shape_get_color((shape_t *)&amp;c1)) shape_get_area((shape_t *)&amp;c1))&#125; 4.3. LoDLaw of demeter认为，模块不应该了解它所操作对象的内部情形。 火车失事（只关乎于编码风格，像火车一样的代码） 12345678910111213141516/* * 不推荐，像火车一样的代码 */output_dir = ctxt.get_options().get_scratch_dir().get_abs_path();/* * 推荐（对象） */ops = ctxt.get_options();scratch_dir = ops.get_scratch_dir();abs_path = scratch_dir.get_abs_path();/* * 如果ctxt、ops等只是单纯数据结构，而不是对象则没有违反LoD */output_dir = ctxt.ops.scratch_dir.abs_path 5. 异常处理5.1. 别传递null值调用者可能会意外传入null，自己写代码时候应该不写可以传入null的函数，这样只要发现函数列表中有null就是出问题了。 6. 附录概念解释的来源主要有 百度翻译中的牛津词典 google翻译 stackoverflow高赞答案 wikidiff.com 笔者理解 其他地方 6.1. 名词 acknowledge 解释：确认帧/应答 缩写：ack 关联词：nack address 解释：地址 缩写：addr amount 解释：合计总量，表示量 关联词：number argument 解释：Argument is the actual value of this variable that gets passed to function. 缩写：arg 关联词：parameter12345void foo(void *param);...uint8_t arg1[] = "this is my argument";foo(arg1); attribute 解释：强调事物固有的属性，或区别其他事物的特征。比如车是红色，某某品牌 缩写：attr 关联词：property backup 解释：备份 缩写：bk buffer 解释：短暂数据存储的地方 缩写：buf 关联词：fifo callback 解释：邀请返回做某事，带点因果关系的意思。 缩写：cb 关联词：handler case 解释：具体情况/事例/特殊情况 command 解释：命令/指令 缩写：cmd 关联词：event content 解释：所含之物/内容 context 解释：事情发生的背景/上下文环境 data 解释：存储在计算机中的资料/原始数据/调查资料/材料 同义词：information/results/statistics device 解释：用于做某项工作的对象或者仪器 缩写：dev driver 解释：software that controls the sending of data between a computer and a piece of equipment that is attached to it, such as a printer event 解释：发生的事情 缩写：evt fail 解释：失败 field 解释：字段/信息组 fifo 解释：先进先出算法/先进先出缓冲区 关联词：lifo frame 解释：帧有格式，包括帧头+数据部分+帧尾 关联词：pakcet header 解释：帧头 缩写：hdr handle 解释：事物控制的部分 缩写：hdl handler 解释：处理某些事物的人 缩写：hdlr identity 解释：身份/本体 缩写：id information 解释：事实/某些事物的细节 缩写：info kind 解释：a group of people or things that are the same in some way; a particular variety or type，如某个种类的音乐。 关联词：type length 解释：长度/距离/持续时间的长短 缩写：len message 解释：（书面或口头的）信息，消息，音信 缩写：msg nack 解释：表示报文有错误，要求重发。 关联词：ack/syn master 解释：具有控制力的角色 关联词：slave number 解释：一个符号，代表数字/序号/数，表示数 缩写：num 关联词：amount packet 解释：a piece of information that forms part of a message sent through a computer network 缩写：pkt 关联词：frame/payload parameter 解释：Parameter is variable in the declaration of function 缩写：param payload 解释：有效载荷，是frame中的一部分 property 解释：强调“拥有”的参数，比如车有颜色属性，有尺寸大小属性。 关联词：attribute receiver 解释：接收者 缩写：rx report 解释：新闻/报告 request 解释：(正式礼貌的)请求和要求的事 缩写：req response 解释：(口头或书面的)回复/响应 缩写：rsp result 解释：后果/结果 缩写：res self 解释：指向当前类的指针 关联词：this slave 解释：受控制的角色 关联词：master sender 解释：邮寄人 size 解释：抽象大小概念/标定大小尺寸 status 解释：(进展中的)状况/情形 string 解释：字符串，带’\0’结尾。 缩写：str 关联词：bytes succeess 解释：成功 syn 解释：在发消息之前，需要先同步。（tcp） 关联词：ack/nack this 解释：指向当前对象的指针 关联词：self transmitter 解释：发射机/发射者 缩写：tx 关联词：sender/receiver type 解释：a class or group of people or things that share particular qualities or features and are part of a larger group，如不同的人种 关联词：kind value 解释：由代数项表示的数值、数量 缩写：val 关联词：data variable 解释：可变因素 缩写：var version 解释：版本 缩写：vers manager 解释：待定 processor 解释：待定 controller 解释：待定 block 解释：由sector组成 sector 解释：由page组成 page 解释：SPI FLASH最小写操作单元 关于setting/option/preference/property/configuration的理解： Someone style: Settings: “View or modify the list of things that can be set” Options: “We have set some things already, and give you the option to enable or disable them” Preferences: “Tell us how you prefer this to work” Properties: “Change one or more properties of this item” Configuration: “We have defaults, but they’re so barebones you probably want to configure it yourself” Following an approximate lead from Visual Studio and other Microsoft products: Properties represent the characteristics of a single component or object in the application. Options alter global ways that the application works. Microsoft products use this to customise the UI toolbar, for example. There’s an implication here that you can disable UI elements altogether (e.g. a “Simple” user interface or an “Advanced” user interface). Settings and Preferences change qualities of how the application works. The implication here is to change, not disable: for example, “Metric measurements” or “British Imperial measurements”. Configuration is often where an application is customised for each user or group. 知乎： Configure some options in the settings. 程序所有的可变项叫做Settings。中文译作设置。所有的设置都是 “可选项”，Option（选项，不是期权），因为在程序世界里没有真的 开放式问题只有选择题（Option）。改变可选项的过程叫做 Configure配置（动词）。 附赠：已确定的Configure结果叫做Configuration配置（名词） 。Configure和Configuration都经常缩写为Config。一套既成的可 迁移的实现特定目的的Configuration叫做Profile，例如手机里的 静音Profile、仅震动Profile、蓝牙各种profile。 6.2. 动词 持久层/数据库操作 create 创建新的记录 read 读已存在的记录 update 更新已存在的记录 delete 删除已存在的记录 整体和个体的访问操作 put 将对象或者任意数据存进去（对象大小由sizeof决定） get 将对象或者任意数据读出来（对象大小由sizeof决定） write 将n个字节写进去 read 将n个字节读出来 恢复/复原/重置 recover 解释：从备份中获取部分文件 restore 解释：从备份中获取整个系统 refresh 解释：重装系统，但是保留应用程序和个人设置文件 reset 解释：重装系统，删除所有东西 缩写：rst 查询/寻找/搜索 inquire 解释：在某个范围内查询某指定事物（ask sth） find 解释：偶然遇到或者发现特定事物 search 解释：I searched on the internet. I found what I was looking for.（指定性没那么强） 过滤/拦截/排列 filter 解释：pass (a liquid, gas, light, or sound) through a device to remove unwanted material. 关联词：filter（名词） intercept 解释：to stop sb/sth that is going from one place to another from arriving 关联词：interceptor（名词） sort 解释：按顺序排列 学习/研究/分析 study learn research 解释：不断寻找和检查来研究某事物 analyze 解释：对当前主题进行分析 覆盖 cover 解释：把某事物放在某事物上面，如隐藏和保护 overlap 解释：延伸并部分覆盖或者替代掉某物 固定搭配 fetch 解释：获取东西 关联词：store store 解释：将东西保存起来以备以后使用 关联词：fetch start 解释：较随意的开始/创立 stop 解释：较随意的结束 begin 解释：从头开始 end 解释：终点结束 enter 解释：加入/进入/开始从事/开始活动 exit 解释：退出（计算机程序） open 解释：参考文件系统使用方法 close 解释：参考文件系统使用方法 input 解释：第三人称描述某个事物的输入 关联词：receive（第一人称） output 解释：第三人称描述某个事物的输出 关联词：transmit（第一人称） upload 解释：上传到服务器或者别的电脑 download 解释：从服务器或者别的电脑下载 set 解释：设置 clear 解释：清除 缩写：clr init 解释：是一个实例的初始化方法 deinit 解释：释放内存 plus 解释：加法 minus 解释：减法 subscribe 解释：订阅 缩写：subs publish 解释：发布 缩写：pub add 解释：增加某东西 sub 解释：减去某东西 pend 参考操作系统 post 参考操作系统 error 解释：err 缩写： ok 解释： 缩写： append 解释：在结尾插入内容 calculate 解释：计算 缩写：calc contain 解释：包含/含有/容纳 erase 解释：flash专用 indicate 解释：指示 关联词：confirm initialize 解释：类的方法，在所有实例方法和类方法执行前运行 notify 解释：正式通报，通知 implement 解释：实现 缩写：impl remove 解释：拿走，但内存还在 关联词：delete（删除释放内存）、recover transfer 解释：移交/转移 translate 解释：转变/变为 overflow 解释：溢出某个容器 peek 解释：偷看一眼 process 解释：对data作一些的操作或处理 6.3. 形容词 固定搭配 valid 解释：有效的 invalid 解释：无效的 busy 解释：忙 idle 解释：空闲 used 解释：已使用 unused 解释：没用着的/空闲的 描述真实/真的 actual 解释：形容客观存在的事实或者行为 real 解释：真实的/实际存在的，对真理的描述 描述大小 larger 解释：强调体积/能力/数量 bigger 解释：表示由“重”的意思，重要/重量。 smaller 解释：无关紧要的/小的数量 little 解释：小的尺寸/只有一点点 tiny 解释：极小的/微小的/微量的 different 解释：不同 缩写：diff equal 解释：大小、价值、数量相等或相同 expected 解释：预料的/预期的 initial 解释：初始化的 remain 解释：仍然存在/可以使用/还没被处理 temp 解释：临时 缩写：tmp]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>代码</tag>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cm_backtrace学习笔记]]></title>
    <url>%2F2019%2F05%2F24%2Fcm-backtrace%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[龙神的debug组件学习笔记。 前言最近了解cortexM的hardfault回溯，记得之前有前辈写过一个组件，趁这次机会拜读一下，并且记录下学习过程。 cmb_fault.s汇编文件组件支持IAR/KEIL/GNU，因为最近用到KEIL，所以就直接看KEIL的汇编文件了，下面摘取了一部分的代码。之前对这块没有好好的总结过，所以这次简单总结一下。 AREA |.text|, CODE, READONLY, ALIGN=2 THUMB REQUIRE8 PRESERVE8 ; NOTE: If use this file&apos;s HardFault_Handler, please comments the HardFault_Handler code on other file. IMPORT cm_backtrace_fault EXPORT HardFault_Handler HardFault_Handler PROC MOV r0, lr ; get lr MOV r1, sp ; get stack pointer (current is MSP) BL cm_backtrace_fault Fault_Loop BL Fault_Loop ;while(1) ENDP END 源码实现的功能： 当hardfault发生时，将lr和sp作为参数传递给cm_backtrace_fault； cm_backtrace_fault处理完之后，进入死循环。 QA：Q：AREA |.text|, CODE, READONLY, ALIGN=2的意义？ AREA：asm指令，参考DUI0379G_02_mdk_armasm_user_guide文档 |.text|：|.text| is used for code sections produced bythe C compiler, or for code sections otherwise associated with the C library. CODE：Contains machine instructions. READONLY is the default READONLY：Indicates that this section must not be written to. This is the default for Code areas. ALIGN=2：By default, ELF sections are aligned on a four-byte boundary. expression can haveany integer value from 0 to 31. The section is aligned on a 2expression-byte boundary. Forexample, if expression is 10, the section is aligned on a 1KB boundary.This is not the same as the way that the ALIGN directive is specified. Q：为什么需要4字节对齐？我也不知道 Q：THUMB的意义？ 参考《DUI0379G_02_mdk_armasm_user_guide》有还怎么一些话 The THUMB directive instructs the assembler to interpret subsequent instructions as Thumb instructions,using the UAL syntax. In files that contain code using different instruction sets, THUMB must precede Thumb code written inUAL syntax. 《The Definitive Guide to theARM Cortex-M0》有这么一段话： Be careful with legacy Thumb programs that use the CODE16 directive. When the CODE16directive is used, the instructions are interpreted as traditional Thumb syntax. For example,data processing op-codes without S suffixes are converted to instructions that updateAPSR when the CODE16 directive is used. However, you can reuse assembly files with theCODE16 directive because it is still supported by existing ARM development tools. Fornew assembly code, the THUMB directive is recommended, which indicates to the assemblythat the Unified Assembly Language (UAL) is used. With UAL syntax, data processinginstructions updating the APSR require the S suffix. Q：REQUIRE8和PRESERVE8的意义？ 《The Definitive Guide to theARM Cortex-M0》有这么一段话： In ARM/Keil development tools, the assembler provides the REQUIRE8 directive to indicate ifthe function requires double-word-stack alignment and the PRESERVE8 directive to indicatethat a function preserves the double-word alignment. This directive can help the assemblerto analyze your code and generate warnings if a function that requires a double-word-alignedstack frame is called by another function that does not guarantee double-word-stack alignment.Depending on your application, these directives might not be required, especially for projectsbuilt entirely with assembly code. 栈帧回溯功能分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * backtrace function call stack * * @param buffer call stack buffer * @param size buffer size * @param sp stack pointer * * @return depth */size_t cm_backtrace_call_stack(uint32_t *buffer, size_t size, uint32_t sp) &#123; ... /* copy called function address */ for (; sp &lt; stack_start_addr + stack_size; sp += sizeof(size_t)) &#123; /* the *sp value may be LR, so need decrease a word to PC */ /* * 假设用户调用了这么一段断言代码： * * void usr_assert(uin8_t zoo) * &#123; * uint32_t sp = cmb_get_msp(); * cm_backtrace_assert(sp); * foo(zoo); * &#125; * * 那么在进入cm_backtrace_assert的时候，会将foo的地址写进LR，然后将 * LR进栈，所以SP指向LR，LR-4刚好就是cm_backtrace_assert的地址 * (因为BL跳转指令刚好占4个字节）。 * 然后从该地址开始轮询已经入栈的数据，看看被压栈里的地址哪个是在代码区 * 间内的，找到就将他们保存进buffer。 * * 这里的回溯原理：找到调用栈中在代码区间内的地址 * 需要注意：code_start_addr和code_size是否定义正确，决定了是否能正 * 确找到调用的函数地址，这个和分散加载（链接脚本）有密切关系。 */ pc = *((uint32_t *) sp) - sizeof(size_t); /* the Cortex-M using thumb instruction, so the pc must be an odd number */ if (pc % 2 == 0) &#123; continue; &#125; if ((pc &gt;= code_start_addr) &amp;&amp; (pc &lt;= code_start_addr + code_size) &amp;&amp; (depth &lt; CMB_CALL_STACK_MAX_DEPTH) &amp;&amp; (depth &lt; size)) &#123; /* the second depth function may be already saved, so need ignore repeat */ if ((depth == 2) &amp;&amp; regs_saved_lr_is_valid &amp;&amp; (pc == buffer[1])) &#123; continue; &#125; buffer[depth++] = pc; &#125; &#125; return depth;&#125; 参考资料 《The Definitive Guide to theARM Cortex-M0》 《DUI0379G_02_mdk_armasm_user_guide》 《DUI0497A_cortex_m0_r0p0_generic_ug》 《DDI0419C_arm_architecture_v6m_reference_manual》]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>hardfault</tag>
        <tag>cortex</tag>
        <tag>debug</tag>
        <tag>栈帧回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE安全机制从入门到放弃]]></title>
    <url>%2F2019%2F05%2F14%2FBLE%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%2F</url>
    <content type="text"><![CDATA[网上介绍BLE安全机制的文章大多只关注业务概念，如：配对加密是什么，绑定过程是什么；而忽略了其中涉及到的信息安全知识，如：使用了加密和认证有什么用，不用又会怎么样。让新人读了有种云里雾里，知其然而不知其所以然的感觉。这里结合涉及到的信息安全知识，换一个角度来认识BLE安全机制。 前言标题中的“放弃”有点调侃的意思，是指读者在读完之后，可以不依赖别人，靠自己读蓝牙核心规范加深认识，这样收获也会更多，也是这篇博文的目标。 为了易于理解，会对蓝牙核心规范的算法进行裁剪，但是原理是不变的，标准算法应参考蓝牙核心规范。 最后，这是博主的一得之见，欢迎各位指正。 目录 密码技术初探 对称密码 diffie-hellman密钥交换算法 椭圆曲线diffie-hellman密钥交换算法 消息认证码 认证加密CCM 信息安全小结 ble安全机制初探 ble40安全机制 ble42安全机制 总结 参考资料 密码技术初探在介绍密码技术之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。 重要角色一览表 Alice和Bob分别是两家银行，Bob银行通过网络向Alice银行发送了一条500元的汇款请求：从账户B-6789向账户A-1234汇款500元。 当然，会有人在网络中尝试攻击银行间通信，妄想用非法手段牟利，其中就有这样一个分工明确的组织，由以下成员组成： Eve 窃听不同银行之间的消息，从中获取重要信息，如获知“从账户B-6789向账户A-1234汇款500元”。 Mallory： 篡改不同银行之间的消息，如修改汇款请求为“从账户B-6789向账户A-1234汇款5000000元”。 伪装成Bob银行，以Bob银行名义发送一条新的汇款请求给Alice银行。 从上述例子可知消息面临的威胁有：窃听、篡改和伪装，对应的安全特性为：机密性、一致性、是否已认证。 “威胁”和“安全特性”的关系可以这样描述： 如果消息没有加密，消息则不具有机密性，无法防止他人窃听； 如果发送者发送的消息和接收者的消息是不同的，说明消息被篡改过，不具有一致性； 如果没有对消息进行认证，无法保证消息来自正确发送者而不是伪装者。 存在威胁，就会有对应的解决方法，下面会针对每个威胁介绍对应的密码技术。 对称密码算法一般指复杂步骤，加密算法指的是用明文生成密文的步骤，解密的步骤称为解密算法，两者统称为密码算法，密码算法需要用到密钥。 所谓对称密码（symmetric cryptography）技术，即加密和解密时用的是同一个密钥，加密和解密的算法一般是公开的，如AES128。 对称密码应用图 对称密码解决的问题 如上图所示 Bob创建一条汇款请求消息； 用密钥key对它加密； 将加密后的消息发给Alice； Alice收到密文； Eve窃听到了加密后的消息，由于没有密钥key，无法解读内容； Alice用密钥key对消息解密； Alice获得一条汇款请求消息。 对称密码技术可以解决窃听的威胁。 对称密码无法解决的问题 对称密码技术可以解决窃听的威胁，但是有一个前提，就是在这之前发送者和接收者要有相同的密钥key，所以一定要先给接收者配送密钥，有以下几种方式： Bob通过网络先将key发送给Alice，但容易被Eve截取到； Bob乘坐交通工具将密钥key亲手交给Alice，或者其他网络以外的方式配送密钥，这种方式成本高维护麻烦，称为带外（Out-Of-Band）配送； 用diffie-hellman密钥交换算法解决； 用椭圆曲线diffie-hellman密钥交换算法解决。 diffie-hellman密钥交换算法先不管DH密钥交换算法是什么，我们现在关注问题是：在Eve窃听网络的情况下，如何解决Bob配送key给Alice的问题？ 密码界的前辈们从数学角度上找到了答案：利用这个数学难题，Bob和Alice可以在Eve窃听的情况下，协商出一个密钥，而Eve不知道密钥是什么。 最好解决配送问题的办法就是不配送，通过协商获得相同的密钥，是不是很神奇，话不多说，我们看看是怎么实现的。 离散对数问题 背景知识：mod符号表达的意思是求余数，如表达式5 mod 7的计算思路为：5除以7等于0，余数为5，所以5 mod 7 = 5。 现有离散对数问题如下，请问满足公式的x是多少： 为了求x，我们可以运用上面提到的背景知识来做计算，像下面这样依次尝试一遍，就可以得到x = 9。 例子的数字较小，所以很快就找到答案了，当数字很大时，计算x就会变得非常耗时，快速求出离散对数的算法到现在还没被发现，所以可以得到这样的一个简单结论： 对于上图公式，已知G、p、Y的时候，很难求出x。 接下来我们看看如何具体利用这个数学问题来协商出密钥的。 diffie-hellman密钥交换算法应用 在DH中，我们将Y称为公钥（public key），将x称为私钥（private key），则有以下结论：已知G、p、公钥的时候，很难求出私钥。 DH应用图 如上图所示 Bob和Alice选择一个公开的G和p，Eve当然也知道这个公开的G和p； Bob和Alice分别随机生成各自的私钥sb和sa； Bob和Alice根据G、p以及各自的私钥，生成公钥pb和pa； Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa； Bob和Alice计算出共享密钥DHkey。 Eve能计算出DHkey吗？ 对比三个角色最后的“已知信息”可知，只要Eve知道任一私钥（sb或sa），它就能容易算出DHkey，而这时候问题就变成了：Eve在已知G、p、公钥情况下，是否能求出私钥，这也就是我们上面提到的离散对数问题，这是很难做到的。 diffie-hellman密钥交换算法解决的问题 因为DH密钥交换算法利用了“离散对数问题”的复杂度，所以就算Eve一直窃听，Bob和Alice也能协商出一个共享密钥，而Eve却因为复杂的数学问题而没办法算出共享密钥，也就解决了对称密码中的配送问题。 椭圆曲线diffie-hellman密钥交换算法DH是利用了“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就叫椭圆曲线diffie-hellman密钥交换（ECDH）。 两者密钥交换总体流程相同，只是利用的数学问题不同而已，ECDH能够用较短的密钥长度实现较高的安全性。 椭圆曲线diffie-hellman密钥交换算法应用 ECDH中的数学问题可以这样简单定义： 已知椭圆曲线上的点Y、基点G的时候，很难求出x。其中算术符号*表示的不是普通的乘法，而是一种在椭圆曲线上的特殊算法。 在ECDH中，我们称Y为公钥（public key），x为私钥（private key）。 ECDH应用图 如上图所示 Bob和Alice选择一条密码学家推荐的椭圆曲线，选择曲线上的一个基点G； Bob和Alice分别随机生成各自的私钥sb和sa； Bob和Alice根据G以及各自的私钥，生成公钥pb和pa； Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa； Bob和Alice计算出共享密钥DHkey。 椭圆曲线diffie-hellman密钥交换算法无法解决的问题 DH和ECDH都能解决密钥配送问题，结合对称密码技术，就能保证消息的机密性，防止被窃听了，但是对于篡改和伪装的攻击，却无能为力。为了解决剩下这两个威胁，就要靠其他技术手段了。 篡改示意图 如上图所示，Mallory不需要知道密文是什么意思，但是他可以修改密文，导致Alice解密出预期以外的内容。 伪装示意图 如上图所示，Mallory夹在Bob和Alice之间并伪装他们。对于Mallory来说，DHkey是赤裸裸的，所以Bob和Alice互发的消息是没有机密性的，这种攻击也称为中间人攻击（MITM）。 消息认证码消息认证码（MAC）技术是检查信息一致性并进行认证的技术，发送者通过MAC算法可以输出一个MIC值，接收者通过校验MIC值不仅可以判断消息一致性，还能判断消息是否来自正确的发送者。 MAC技术有以下几种重要性质： 正向快速：给定明文、MAC算法和密钥key，在有限时间和有限资源内能计算出MIC。 逆向困难：给定MIC、MAC算法和明文，在有限时间内很难（基本不可能）逆推出密钥。 输入敏感：原始输入信息修改一点信息，产生的MIC看起来应该都有很大不同。 冲突避免：很难找到两段内容不同的明文，使得它们的MIC一致（发生冲突）。即对于任意两个不同的数据块，其MIC相同的可能性极小；对于一个给定的数据块，找到和它MIC相同的数据块极为困难。 MAC技术与对称加密技术有一个显著差异：加密解密是双向的，可以互相推导，而认证只能单向；加密是为了解密，MAC设计是无法解。 消息认证码解决的问题 消息经过CMAC算法之后，为何Mallory无法篡改消息和伪装呢？ 消息一致性检查和认证示意图 Mallory如果想篡改明文，那就同时也要篡改MIC，否则无法通过Alice的校验，但是应该将MIC改成多少呢？因为Malloyr没有共享密钥，所以他也不知道MIC应该是什么。如果想篡改MIC，那就同时也要篡改明文才能通过Alice的校验，由于MAC算法的逆向困难性质，Mallory不知道明文应该是什么。 Bob用CMAC算法认证一条消息并发给Alice，并要求Alice也用CMAC算法认证并返回一条消息给Bob。若Mallory伪装成Alice，由于没有认证密钥，无法返回通过Bob校验的消息。 消息认证码无法解决的问题 没错，要使用MAC技术，首先要有相同的认证密钥，又回到了之前的密钥配送问题，具体这里采用哪种方式解决配送密钥问题，视实际情况而定。 消息认证码攻击方式 对于MAC算法来说，应保证不能根据MIC和明文推测出通信双方所使用的密钥。但实际上用穷举法是可以推测出来的，如果使用密码学安全的、高强度的伪随机数生成器生成密钥，就会使得破解时间需要很长以至在现实中几乎不可能破解。而如果密钥是人为选定的，就会大大增加被推测出来的风险。 认证加密CCM其实上文一直在有意无意的强调一个事情，那就是加密和认证是独立的两个概念。加密能防止窃听，认证能防止篡改和伪装。前辈们用一种密码技术将两者融合起来——CCM（Counter with CBC-MAC）。 通过查阅资料，以我的战五渣水平只能理解到这一程度： 发送方先对明文使用MAC技术，然后对称加密成密文； 接收方先用对称加密技术解密密文，然后用MAC技术校验明文； 发送方和接收方需要至少一个共享随机数和一个共享密钥，随机数可以公开，密钥不可以公开。 个人猜测CCM应用示意图 上图只是个人猜测的示意图，有可能是不对的，因为不是术业专攻方向，没有深入研究，秉着求真精神，觉得应该提醒大家，避免误导。 放上图的目的是：加密和认证可以做在一个算法中，而且BLE就是这么用的。 信息安全小结威胁、安全特性、密码技术关系图 总结： 为了解决窃听问题，采用对称密码技术； 为了解决对称密码技术的加密密钥配送问题，采用配送密钥技术； 为了解决篡改问题，采用消息认证码技术； 为了解决伪装问题，采用消息认证码技术； 为了解决消息认证码技术的认证密钥配送问题，采用配送密钥技术。 Tips：无论消息认证码技术还是对称密码技术，都需要用到配送密钥技术，而不同的配送密钥技术本身，也会涉及到认证强度的问题。比如希望用ECDH来解决消息认证码的认证密钥配送问题，但是ECDH本身认证强度为零，所以它也需要消息认证码技术来证明ECDH过程中没有出现篡改或者伪装攻击，即又要使用消息认证码技术，导致进入了死循环。所以需要选择合适的密钥配送技术，常见的有：邮箱验证码、手机短信验证码、NFC、目测法等。 ble安全机制初探在介绍ble安全机制之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。 ble重要角色一览表 背景知识：简单来说ble设备可分为两种角色，一种是主机角色（master），另一种是从机角色（slave），有以下几种差异： 建立连接前 主机能进入扫描状态、发起连接状态，不能进入广播状态； 从机能进入广播状态，不能进入扫描状态和发起连接状态； 一定是由主机发起连接，从机只能被连接。 建立连接后 一定是由主机发起配对，但是从机能够请求主机发起配对； ble各个状态示意图 广播状态：设备正在往空中发送广播包，谁都可以收得到； 扫描状态：设备正在接收空中的广播包，看看谁在发，发什么； 发起连接状态：设备指定与另外一个设备发起连接； 明文数传阶段：两个已连接设备之间，用明文传送数据包； 配对阶段：两个已连接设备之间，运用密码技术生成各种安全强度的密钥； 加密过程：两个已连接设备之间，使用配对阶段输出的密钥，或者绑定阶段提供的密钥，衍生出最终用于加密底层数据包的密钥； 密文数传阶段：两个已连接设备之间，用密文传送数据包； 绑定阶段：用“绑定”这个词特定描述配对阶段中的第三阶段，该阶段交换绑定信息，有了绑定信息下次需要密文数传可以跳过配对阶段。 除了展示两种角色的异同，我觉得有必要通过上图澄清几个概念，加深大家的理解： 复杂密码技术是运用在已连接之后的配对阶段，所以不存在配对失败，导致ble无法正常建立连接，至多是配对失败，导致连接断开。 连接后，不一定要启动配对，如果明文数传已经满足应用要求，就没必要启动配对了。 ble40安全机制从用户角度提出问题：我现在对密码技术有初步了解了，也知道ble安全机制的一些背景知识，评估下来连接之后的明文数传风险太大，我要用到密文数传，ble提供什么样的解决方案呢？ ble4.0安全机制简单示意图 上图是ble4.0安全机制简单示意图，是上一节“建立连接后”的细节展开，观察方式从上到下为角色的时间轴，从左到右分别是不同的角色，空白地方的文本为传递的数据，虚线为可选项，双斜杠为不展开讨论的内容。 对于密文数传，ble提供解决方案分四种情况： 首次连接无绑定 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 首次连接有绑定 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传，进入绑定阶段，从机将长期密钥（LTK）发送给主机保存。 第二次连接且首次连接无绑定 第二次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 第二次连接且首次连接有绑定 第二次连接，跳过配对阶段，加密过程使用之前绑定的LTK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 由下往上读图，回答用户提出的问题： ble4.0选择CCM给明文数据认证加密，想要使用CCM，就需要一个密钥和一个随机数用于CCM认证加密，所以ble有一个“加密过程”负责输出一个密钥（sessionKey）和一个随机数（IV），而加密过程又需要一个密钥来产生sessionKey，所以ble有一个“配对阶段”来输出一个临时密钥（STK）给加密过程，或者在绑定阶段输出一个长期密钥（LTK）给加密过程下一次连接时候使用。 TK配对码的生成和配送 ble4.0的TK配对码生成和配送方式有多种，常用的两种TK配对码的生成和配送方式是：JustWorks和Passkey，他们有以下差异： JustWorks模式时，生成的TK是000000，因为这是公开的，没有配送的意义，配送目的是为了防止通信双方以外的第三方获得密钥，由于现在认证码是公开的，就没配送的意义了，而且由于认证码泄露，这种模式不能提供篡改和伪装保护。 Passkey模式时，TK的生成方式和配送方式如下：通信其中一方如Alice随机生成TK为142536，通过显示屏/短信/NFC等蓝牙以外的输出数据的方式，将配对码告知给Bob’s User，Bob’s User通过键盘往Bob设备输入142536，使得Bob和Alice拥有一个共享认证密钥，而针对蓝牙基带攻击的第三方Mallory不知道，从而提供篡改和伪装保护。 下面来看一下图，Passkey模式是怎么做到认证保护的。 认证保护示意图 通过正常认证过程，可以发现Bob和Alice只在空中交互了两次，所以Mallory的攻击时机有两个，第一个是Bob和Alice交换MIC的时刻，另一个是在Bob和Alice交换明文的时刻。 分两种攻击行为 篡改MIC或者明文其中一项，属于篡改攻击。 如果篡改MIC，那就是在未知明文和TK的情况下，凭空捏造一个EMIC，而且这个EMIC还要能够通过后续校验，这个几乎不可能。MIC是果，明文和TK是因，因果倒置不可能吧。 如果篡改明文，那就是给定MIC，基于MAC算法且未知认证密钥TK的情况下，推导出另一份明文，根据MAC算法性质，这个是很难做到的。 同时篡改MIC和明文，属于伪装攻击，也叫MITM攻击。 因为伪造认证码EMIC和伪造明文Erand是Mallory提供的，计算过程可能是EMIC = MAC(EK, Erand)，而真实配对码TK和伪造配对码EKEY只有百万分之一的几率是相同的，所以看作是不相同的，也即EK != TK，根据MAC的输入敏感性质，EMIC != MAC(TK, Erand)，最终认证失败。 ble4.0真的足够安全吗？ 我们先列出ble4.0安全机制各个密钥的安全依赖关系： CCM -&gt; sessionKey -&gt; STK(LTK) -&gt; TK 可以看到，最终的源头是TK认证码，只有保证TK足够安全，密文才能保证安全，也就是说不能让非法分子获得TK，否则他们就能够将密文解密了。 一般我们依靠MAC算法本身的性质，可以保证认证密钥不被推算出来，但是但是这些性质的前提是：认证密钥是使用密码学安全的、高强度的伪随机数生成器生成的，而且这些密钥位数很多，以至于无法穷举。 而实际TK的取值是000000~999999，最多只有100万种可能性，先抓取配对阶段（phase2.2）中用到的明文、MIC，再通过穷举的方式，就可以推算出TK了。 我们分析一下，如果在整个安全机制过程中，一直存在窃听者Eve，那么我们会面临什么威胁。 Tips：在这里也顺带分析静态配对码和动态配对码的区别，静态配对码是指每次输入都是固定的TK值，动态配对码是指每次输入都是动态产生的TK值，其实核心规范里面没有提过静态配对码，但是很多人会希望有如下功能：在一个设备预设一个配对码为123456，然后配对阶段时另一个设备输入配对码123456则通过认证，否则不通过，其实对于ble来说，由于TK可以被破解，所以静态配对码没有起到安全保护作用。 如果是静态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。 Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改； Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改； 伪装Bob或者Alice与对方首次连接，因为TK是静态配对码，通过认证，伪装成功。 如果是动态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。 Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改； Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改； 伪装Bob或者Alice与对方首次连接，因为TK是动态配对码，之前破解的TK用不上，无法通过认证，伪装失败。 总结出几个观点： 因为“加密”都依赖于认证码TK，而TK容易被穷举破解，加密则形同虚设。 上面描述的威胁，首先是窃听成功，才能篡改成功，问题是出在了窃听上。正常情况下对于密文的处理，CCM需要先解密，后认证。如果Eve没有窃听成功，乱篡改Bob发出的CCM认证加密过的密文，那么Alice解密出来的数据几乎不可能通过后续认证的。正是因为Eve窃听成功，知道篡改哪部分内容，所以才会造成威胁。解决窃听问题，就能同时解决篡改问题了。 TK是不安全的，以至于如果使用静态配对码而不是动态配对码，就无法解决伪装问题，如果认证码不像TK那样范围窄，静态配对码技术本身也没什么问题，但是最好还是定期更新。 上面总结的也是ble4.2安全机制里面做的一部分改善，比如增加破解TK的难度，引入ECDH解决窃听问题。 ble42安全机制上一节，我们分析了ble4.0的安全“漏洞”， 接下来简单说一下ble4.2作出的应对措施。 无法改变的前提： 配对码是6个字节。 可能的攻击方式： Eve窃听整个过程，从而破解TK，下一次可以伪装Bob和Alice主动发起连接认证。 Eve窃听整个过程，从而破解TK，从而得到STK，然后窃取LTK。 Mallory发起MITM攻击，即使攻击失败，包含整个TK信息的MAC和MIC会被Mallory获得。（虽然我不知道有什么用） 提出对应解决的方案： 动态认证码； ECDH保证机密性； 将TK拆成20bit，每次认证一个bit，攻击失败只会暴露1个bit，不会暴露整个TK。 BLE4.2与BLE4.0的安全机制区别主要体现在“配对阶段”的phase2，在这个阶段引入了ECDH，下面展开passkey模式的phase2（包括phase2.1~2.3）。 BLE4.2 phase2示意图 在“Authentication Stage1”过程，可以发现Bob和Alice只在空中交互了三次，所以Mallory的攻击时机有三个： 交换公钥的时刻 交换MIC的时刻 交换明文的时刻。 后两个攻击方式，在BLE4.0已经分析过了，至于第一个攻击时机，因为公钥是也是MAC算法里面的一个参数，所以它也不能被随意篡改，如果改了后面的Ea和Eb校验就不通过了，即给ECDH也提供了MITM保护。 Tips：这里之所以可以提供MITM保护的实质是人的参与，通过观察的方法获得配对码，绕开了蓝牙空中传输来获得配对码，从而不会受到第三者攻击。 对比BLE4.2和BLE4.0的主要区别： BLE4.2没有STK，在配对过程直接生成LTK，因为LTK在配对阶段就已经强制生成了，加密过程直接使用LTK，BLE4.2的绑定阶段(phase3)不会发送LTK。 LTK是DHkey衍生出来的，DHkey是第三方无法窃听也无法破解出来的，所以可以保证后面用CCM加密后数据的机密性。 BLE4.2完美解决了BLE4.0的安全漏洞。 总结文章提到的只是BLE常见的一些概念，其他如：签名（Signed）、授权（Authorization）之类都没有提及，有兴趣的读者可以去核心规范探索一番。 参考资料里面有许多优秀的书籍和文章，比如密码技术相关知识我是从《图解密码技术》获知的，关于具体的实战抓包分析，吹爆“BLE配对过程详解”这篇文章。 最后最后，感谢您阅读到最后，这是对我最大的鼓励，也希望这篇博文能让您有一点点的收获。 后记一开始是想将MESH加进来的，但是考虑到还没上过正式的项目去体验过，怕写出来理解的不够透彻，所以还是算了，以后有机会再单独开一篇吧，但是有兴趣的朋友可以私底下一起交流。 参考资料 《图解密码技术》 BLE配对过程详解 BLE核心规范 Hash算法总结 穷举法破解BLE的TK值]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>BLE</tag>
        <tag>安全机制</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建实战]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架，支持个性化的配置。这篇博文记录了搭建过程。 目录 配置主题 配置风格 配置语言 配置描述 配置目录 配置头像 配置拉条 配置社交 配置打赏 配置菜单 配置标签 配置分类 配置评论 配置分享 配置版权 配置脚注 配置统计 配置搜索 博文置顶 博文插图 配置主题修改博客工程根目录下的_config.yml文件 theme: hexo-theme-next 配置风格修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 scheme: Mist 配置语言修改博客工程根目录下的_config.yml文件 language: zh-CN 配置描述修改博客工程根目录下的_config.yml文件 description: &quot;Stay hungry, Stay foolish.&quot; 配置目录修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 toc: enable: true number: false 配置头像将头像图片文件123.jpg放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 avatar: url: /images/123.jpg 配置拉条none 配置社交修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 social: GitHub: https://github.com/jaydenh215 || github 配置打赏将打赏图片文件wechatpay.jpg放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 reward_settings: enable: true comment: “如果觉得还不错，请我喝杯咖啡吧~” reward: wechatpay: /images/wechatpay.jpg 配置菜单修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 menu: home: / || home tags: /tags/ || tags categories: /categories/ || th 配置标签增加一个页面（page）用来汇总标签 hexo new page tags 修改生成的页面文件内容（/source/tags/index.md） --- title: tags date: 2019-05-10 13:49:39 type: &quot;tags&quot; --- 给文章添加标签属性 --- title: 博客个性化配置 date: 2019-05-10 10:00:00 tags: - 博客 - 搭建 - 环境 - 配置 --- 配置分类增加一个页面（page）用来汇总类别 hexo new page categories 修改生成的页面文件内容（/source/categories/index.md） --- title: categories date: 2019-05-10 13:44:06 type: &quot;categories&quot; --- 给文章添加类别属性 --- title: 博客个性化配置 date: 2019-05-10 10:00:00 categories: - 社交 --- 配置评论next主题集成了许多第三方厂家的评论功能插件，选择比较精简的Valine。 修改主题目录（/themes/hexo-theme-next）下的_config.yml文件，主要是app id和app key。 valine: enable: true appid: xxxxxxxxxx appkey: xxxxxxxxxx guest_info: nick,mail notify: true placeholder: Comment here ... 增加评论区之后，右下角会有Power by Valine，可以这样删掉： 找到/themes/hexo-theme-next/layout/_third-party/comments/valine.swig文件并修改代码 修改前： &lt;script&gt; var GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;]; var guest = &apos;{{ theme.valine.guest_info }}&apos;; guest = guest.split(&apos;,&apos;).filter(function(item) { return GUEST.indexOf(item) &gt; -1; }); new Valine({ el: &apos;#comments&apos;, verify: {{ theme.valine.verify }}, notify: {{ theme.valine.notify }}, appId: &apos;{{ theme.valine.appid }}&apos;, appKey: &apos;{{ theme.valine.appkey }}&apos;, placeholder: &apos;{{ theme.valine.placeholder }}&apos;, avatar: &apos;{{ theme.valine.avatar }}&apos;, meta: guest, pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10, visitor: {{ theme.valine.visitor }}, lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos; }); &lt;/script&gt; 修改后： &lt;script&gt; var GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;]; var guest = &apos;{{ theme.valine.guest_info }}&apos;; guest = guest.split(&apos;,&apos;).filter(function(item) { return GUEST.indexOf(item) &gt; -1; }); new Valine({ el: &apos;#comments&apos;, verify: {{ theme.valine.verify }}, notify: {{ theme.valine.notify }}, appId: &apos;{{ theme.valine.appid }}&apos;, appKey: &apos;{{ theme.valine.appkey }}&apos;, placeholder: &apos;{{ theme.valine.placeholder }}&apos;, avatar: &apos;{{ theme.valine.avatar }}&apos;, meta: guest, pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10, visitor: {{ theme.valine.visitor }}, lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos; }); //新增 var infoEle= document.querySelector(&apos;#comments .info&apos;); if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0) { infoEle.childNodes.forEach(function(item) { item.parentNode.removeChild(item); }); } &lt;/script&gt; 配置分享修改博客工程根目录下的_config.yml文件 baidushare: true 修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 baidushare: type: button 按照链接中的方法，将static放进/themes/hexo-theme-next/source目录下。 修改baidushare.swig文件中的代码。 修改前： .src=&apos;//bdimg.share.baidu.com/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)]; 修改后： .src=&apos;/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)]; 配置版权修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 creative_commons: post: true 修改博客工程根目录下的_config.yml文件 url: https://jaydenh215.github.io/ 配置脚注修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 footer: powered: enable: false theme: enable: false 配置统计next主题集成了许多第三方厂家的统计功能插件，选择LeanCloud。 完成上述步骤之后，会发现阅读次数后面没有数字，那是因为LeanCloud和next主题还没有联系起来，需要按照该博主的方法来实现。 部署云引擎以保证访客数量不被随意篡改 20190514：总是有问题，所以现在先把leancloud_visitors安全设置为false。 配置搜索next主题推荐使用Local Search 博文置顶参考这里 博文插图修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 post_asset_folder: true 这样每次hexo new XX，都会同时生成一个XX文件夹用来放图片。 为了去掉插图的边框，找到/themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl文件并修改代码。 img { box-sizing: border-box; margin: auto; padding: 0px; border: 0px; }]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>搭建</tag>
        <tag>配置</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
