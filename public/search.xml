<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F16%2FBLE%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%2F%E6%95%B0%E6%8D%AE%E5%85%AC%E5%BC%8F%E6%88%AA%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[$$ 7^x mod 13 = 8 $$$$ 7^0 mod 13 = 1 $$$$ 7^1 mod 13 = 7 $$$$ 7^2 mod 13 = 10 $$$$ 7^3 mod 13 = 5 $$$$ 7^4 mod 13 = 9 $$$$ 7^5 mod 13 = 11 $$$$ 7^6 mod 13 = 12 $$$$ 7^7 mod 13 = 6 $$$$ 7^8 mod 13 = 3 $$$$ 7^9 mod 13 = 8$$ $$ Y=G^xmodp $$ $$ Y=x * G $$ $$ MIC=MAC(plaintext, key) $$]]></content>
  </entry>
  <entry>
    <title><![CDATA[BLE安全机制从入门到放弃]]></title>
    <url>%2F2019%2F05%2F14%2FBLE%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%2F</url>
    <content type="text"><![CDATA[网上介绍BLE安全机制的文章大多只关注业务概念，如：配对加密是什么，绑定过程是什么；而忽略了其中涉及到的信息安全知识，如：使用了加密和认证有什么用，不用又会怎么样。让新人读了有种云里雾里，知其然而不知其所以然的感觉。这里结合涉及到的信息安全知识，换一个角度来认识BLE安全机制。 前言标题中的“放弃”有点调侃的意思，是指读者在读完之后，可以不依赖别人，靠自己读蓝牙核心规范加深认识，这样收获也会更多，也是这篇博文的目标。 为了易于理解，会对蓝牙核心规范以及组网规范中的算法进行裁剪，但是原理是不变的，标准算法应参考蓝牙核心规范以及组网规范。 最后，这是博主的一得之见，欢迎各位指正。 目录 密码技术初探 对称密码 diffie-hellman密钥交换算法 椭圆曲线diffie-hellman密钥交换算法 消息认证码 认证加密CCM 信息安全小结 ble安全机制初探 ble40安全机制 ble42安全机制 mesh安全机制初探 参考资料 密码技术初探在介绍密码技术之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。 重要角色一览表 Alice和Bob分别是两家银行，Bob银行通过网络向Alice银行发送了一条500元的汇款请求：从账户B-6789向账户A-1234汇款500元。 当然，会有人在网络中尝试攻击银行间通信，妄想用非法手段牟利，其中就有这样一个分工明确的组织，由以下成员组成： Eve 窃听不同银行之间的消息，从中获取重要信息，如获知“从账户B-6789向账户A-1234汇款500元”。 Mallory： 篡改不同银行之间的消息，如修改汇款请求为“从账户B-6789向账户A-1234汇款5000000元”。 伪装成Bob银行，以Bob银行名义发送一条新的汇款请求给Alice银行。 从上述例子可知消息面临的威胁有：窃听、篡改和伪装，对应的安全特性为：机密性、一致性、是否已认证。 “威胁”和“安全特性”的关系可以这样描述： 如果消息没有加密，消息则不具有机密性，无法防止他人窃听； 如果发送者发送的消息和接收者的消息是不同的，说明消息被篡改过，不具有一致性； 如果没有对消息进行认证，无法保证消息来自正确发送者而不是伪装者。 存在威胁，就会有对应的解决方法，下面会针对每个威胁介绍对应的密码技术。 对称密码算法一般指复杂步骤，加密算法指的是用明文生成密文的步骤，解密的步骤称为解密算法，两者统称为密码算法，密码算法需要用到密钥。 所谓对称密码（symmetric cryptography）技术，即加密和解密时用的是同一个密钥，加密和解密的算法一般是公开的，如AES128。 对称密码应用图 对称密码解决的问题 如上图所示 Bob创建一条汇款请求消息； 用密钥key对它加密； 将加密后的消息发给Alice； Alice收到密文； Eve窃听到了加密后的消息，由于没有密钥key，无法解读内容； Alice用密钥key对消息解密； Alice获得一条汇款请求消息。 对称密码技术可以解决窃听的威胁。 对称密码无法解决的问题 对称密码技术可以解决窃听的威胁，但是有一个前提，就是在这之前发送者和接收者要有相同的密钥key，所以一定要先给接收者配送密钥，有以下几种方式： Bob通过网络先将key发送给Alice，但容易被Eve截取到； Bob乘坐交通工具将密钥key亲手交给Alice，或者其他网络以外的方式配送密钥，这种方式成本高维护麻烦，称为带外（Out-Of-Band）配送； 用diffie-hellman密钥交换算法解决； 用椭圆曲线diffie-hellman密钥交换算法解决。 diffie-hellman密钥交换算法先不管DH密钥交换算法是什么，我们现在关注问题是：在Eve窃听网络的情况下，如何解决Bob配送key给Alice的问题？ 密码界的前辈们从数学角度上找到了答案：利用这个数学难题，Bob和Alice可以在Eve窃听的情况下，协商出一个密钥，而Eve不知道密钥是什么。 最好解决配送问题的办法就是不配送，通过协商获得相同的密钥，是不是很神奇，话不多说，我们看看是怎么实现的。 离散对数问题 背景知识：mod符号表达的意思是求余数，如表达式5 mod 7的计算思路为：5除以7等于0，余数为5，所以5 mod 7 = 5。 现有离散对数问题如下，请问满足公式的x是多少： 为了求x，我们可以运用上面提到的背景知识来做计算，像下面这样依次尝试一遍，就可以得到x = 9。 例子的数字较小，所以很快就找到答案了，当数字很大时，计算x就会变得非常耗时，快速求出离散对数的算法到现在还没被发现，所以可以得到这样的一个简单结论： 对于上图公式，已知G、p、Y的时候，很难求出x。 接下来我们看看如何具体利用这个数学问题来协商出密钥的。 diffie-hellman密钥交换算法应用 在DH中，我们将Y称为公钥（public key），将x称为私钥（private key），则有以下结论：已知G、p、公钥的时候，很难求出私钥。 DH应用图 如上图所示 Bob和Alice选择一个公开的G和p，Eve当然也知道这个公开的G和p； Bob和Alice分别随机生成各自的私钥sb和sa； Bob和Alice根据G、p以及各自的私钥，生成公钥pb和pa； Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa； Bob和Alice计算出共享密钥DHkey。 Eve能计算出DHkey吗？ 对比三个角色最后的“已知信息”可知，只要Eve知道任一私钥（sb或sa），它就能容易算出DHkey，而这时候问题就变成了：Eve在已知G、p、公钥情况下，是否能求出私钥，这也就是我们上面提到的离散对数问题，这是很难做到的。 diffie-hellman密钥交换算法解决的问题 因为DH密钥交换算法利用了“离散对数问题”的复杂度，所以就算Eve一直窃听，Bob和Alice也能协商出一个共享密钥，而Eve却因为复杂的数学问题而没办法算出共享密钥，也就解决了对称密码中的配送问题。 椭圆曲线diffie-hellman密钥交换算法DH是利用了“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就叫椭圆曲线diffie-hellman密钥交换（ECDH）。 两者密钥交换总体流程相同，只是利用的数学问题不同而已，ECDH能够用较短的密钥长度实现较高的安全性。 椭圆曲线diffie-hellman密钥交换算法应用 ECDH中的数学问题可以这样简单定义： 已知椭圆曲线上的点Y、基点G的时候，很难求出x。其中算术符号*表示的不是普通的乘法，而是一种在椭圆曲线上的特殊算法。 在ECDH中，我们称Y为公钥（public key），x为私钥（private key）。 ECDH应用图 如上图所示 Bob和Alice选择一条密码学家推荐的椭圆曲线，选择曲线上的一个基点G； Bob和Alice分别随机生成各自的私钥sb和sa； Bob和Alice根据G以及各自的私钥，生成公钥pb和pa； Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa； Bob和Alice计算出共享密钥DHkey。 椭圆曲线diffie-hellman密钥交换算法无法解决的问题 DH和ECDH都能解决密钥配送问题，结合对称密码技术，就能保证消息的机密性，防止被窃听了，但是对于篡改和伪装的攻击，却无能为力。为了解决剩下这两个威胁，就要靠其他技术手段了。 篡改示意图 如上图所示，Mallory不需要知道密文是什么意思，但是他可以修改密文，导致Alice解密出预期以外的内容。 伪装示意图 如上图所示，Mallory夹在Bob和Alice之间并伪装他们。对于Mallory来说，DHkey是赤裸裸的，所以Bob和Alice互发的消息是没有机密性的，这种攻击也称为中间人攻击（MITM）。 消息认证码消息认证码（MAC）技术是检查信息一致性并进行认证的技术，发送者通过MAC算法可以输出一个MIC值，接收者通过校验MIC值不仅可以判断消息一致性，还能判断消息是否来自正确的发送者。 MAC技术有以下几种重要性质： 正向快速：给定明文、MAC算法和密钥key，在有限时间和有限资源内能计算出MIC。 逆向困难：给定MIC、MAC算法和明文，在有限时间内很难（基本不可能）逆推出密钥。 输入敏感：原始输入信息修改一点信息，产生的MIC看起来应该都有很大不同。 冲突避免：很难找到两段内容不同的明文，使得它们的MIC一致（发生冲突）。即对于任意两个不同的数据块，其MIC相同的可能性极小；对于一个给定的数据块，找到和它MIC相同的数据块极为困难。 MAC技术与对称加密技术有一个显著差异：加密解密是双向的，可以互相推导，而认证只能单向；加密是为了解密，MAC设计是无法解。 消息认证码解决的问题 消息经过CMAC算法之后，为何Mallory无法篡改消息和伪装呢？ 消息一致性检查和认证示意图 Mallory如果想篡改明文，那就同时也要篡改MIC，否则无法通过Alice的校验，但是应该将MIC改成多少呢？因为Malloyr没有共享密钥，所以他也不知道MIC应该是什么。如果想篡改MIC，那就同时也要篡改明文才能通过Alice的校验，由于MAC算法的逆向困难性质，Mallory不知道明文应该是什么。 Bob用CMAC算法认证一条消息并发给Alice，并要求Alice也用CMAC算法认证并返回一条消息给Bob。若Mallory伪装成Alice，由于没有认证密钥，无法返回通过Bob校验的消息。 消息认证码无法解决的问题 没错，要使用MAC技术，首先要有相同的认证密钥，又回到了之前的密钥配送问题，具体这里采用哪种方式解决配送密钥问题，视实际情况而定。 消息认证码攻击方式 对于MAC算法来说，应保证不能根据MIC和明文推测出通信双方所使用的密钥。但实际上用穷举法是可以推测出来的，如果使用密码学安全的、高强度的伪随机数生成器生成密钥，就会使得破解时间需要很长以至在现实中几乎不可能破解。而如果密钥是人为选定的，就会大大增加被推测出来的风险。 认证加密CCM其实上文一直在有意无意的强调一个事情，那就是加密和认证是独立的两个概念。加密能防止窃听，认证能防止篡改和伪装。前辈们用一种密码技术将两者融合起来——CCM（Counter with CBC-MAC）。 通过查阅资料，以我的战五渣水平只能理解到这一程度： 发送方先对明文使用MAC技术，然后对称加密成密文； 接收方先用对称加密技术解密密文，然后用MAC技术校验明文； 发送方和接收方需要至少一个共享随机数和一个共享密钥，随机数可以公开，密钥不可以公开。 个人猜测CCM应用示意图 上图只是个人猜测的示意图，有可能是不对的，因为不是术业专攻方向，没有深入研究，秉着求真精神，觉得应该提醒大家，避免误导。 放上图的目的是：加密和认证可以做在一个算法中，而且BLE就是这么用的。 信息安全小结威胁、安全特性、密码技术关系图 总结： 为了解决窃听问题，采用对称密码技术； 为了解决对称密码技术的加密密钥配送问题，采用配送密钥技术； 为了解决篡改问题，采用消息认证码技术； 为了解决伪装问题，采用消息认证码技术； 为了解决消息认证码技术的认证密钥配送问题，采用配送密钥技术。 Tips：无论消息认证码技术还是对称密码技术，都需要用到配送密钥技术，而不同的配送密钥技术本身，也会涉及到认证强度的问题。比如希望用ECDH来解决消息认证码的认证密钥配送问题，但是ECDH本身认证强度为零，所以它也需要消息认证码技术来证明ECDH过程中没有出现篡改或者伪装攻击，即又要使用消息认证码技术，导致进入了死循环。所以需要选择合适的密钥配送技术，常见的有：邮箱验证码、手机短信验证码、NFC、目测法等。 ble安全机制初探在介绍ble安全机制之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。 ble重要角色一览表 背景知识：简单来说ble设备可分为两种角色，一种是主机角色（master），另一种是从机角色（slave），有以下几种差异： 建立连接前 主机能进入扫描状态、发起连接状态，不能进入广播状态； 从机能进入广播状态，不能进入扫描状态和发起连接状态； 一定是由主机发起连接，从机只能被连接。 建立连接后 一定是由主机发起配对，但是从机能够请求主机发起配对； ble各个状态示意图 广播状态：设备正在往空中发送广播包，谁都可以收得到； 扫描状态：设备正在接收空中的广播包，看看谁在发，发什么； 发起连接状态：设备指定与另外一个设备发起连接； 明文数传阶段：两个已连接设备之间，用明文传送数据包； 配对阶段：两个已连接设备之间，运用密码技术生成各种安全强度的密钥； 加密过程：两个已连接设备之间，使用配对阶段输出的密钥，或者绑定阶段提供的密钥，生成密文； 密文数传阶段：两个已连接设备之间，用密文传送数据包； 绑定阶段：用“绑定”这个词特定描述配对阶段中的第三阶段，该阶段交换绑定信息，有了绑定信息下次需要密文数传可以跳过配对阶段。 除了展示两种角色的异同，我觉得有必要通过上图澄清几个概念，加深大家的理解： 复杂密码技术是运用在已连接之后的配对阶段，所以不存在配对失败，导致ble无法正常建立连接，至多是配对失败，导致连接断开。 连接后，不一定要启动配对，如果明文数传已经满足应用要求，就没必要启动配对了。 ble40安全机制从用户角度提出问题：我现在对密码技术有初步了解了，也知道ble安全机制的一些背景知识，评估下来连接之后的明文数传风险太大，我要用到密文数传，ble提供什么样的解决方案呢？ ble4.0安全机制简单示意图 上图是ble4.0安全机制简单示意图，是上一节“建立连接后”的细节展开，观察方式从上到下为角色的时间轴，从左到右分别是不同的角色，空白地方的文本为传递的数据，虚线为可选项，双斜杠为不展开讨论的内容。 对于密文数传，ble提供解决方案分四种情况： 首次连接无绑定 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 首次连接有绑定 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传，进入绑定阶段，从机将长期密钥（LTK）发送给主机保存。 第二次连接且首次连接无绑定 第二次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 第二次连接且首次连接有绑定 第二次连接，跳过配对阶段，加密过程使用之前绑定的LTK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。 由下往上读图，回答用户提出的问题： ble4.0选择CCM给明文数据认证加密，想要使用CCM，就需要一个密钥和一个随机数用于CCM认证加密，所以ble有一个“加密过程”负责输出一个密钥（sessionKey）和一个随机数（IV），而加密过程又需要一个密钥来产生sessionKey，所以ble有一个“配对阶段”来输出一个临时密钥（STK）给加密过程，或者在绑定阶段输出一个长期密钥（LTK）给加密过程下一次连接时候使用。 TK配对码的生成和配送 ble4.0的TK配对码生成和配送方式有多种，常用的两种TK配对码的生成和配送方式是：JustWorks和Passkey，他们有以下差异： JustWorks模式时，生成的TK是000000，因为这是公开的，没有配送的意义，配送目的是为了防止通信双方以外的第三方获得密钥，由于现在认证码是公开的，就没配送的意义了，而且由于认证码泄露，这种模式不能提供篡改和伪装保护。 Passkey模式时，TK的生成方式和配送方式如下：通信其中一方如Alice随机生成TK为142536，通过显示屏/短信/NFC等蓝牙以外的输出数据的方式，将配对码告知给Bob’s User，Bob’s User通过键盘往Bob设备输入142536，使得Bob和Alice拥有一个共享认证密钥，而针对蓝牙基带攻击的第三方Mallory不知道，从而提供篡改和伪装保护。 下面来看一下图，Passkey模式是怎么做到认证保护的。 MITM保护示意图 通过正常认证过程，可以发现Bob和Alice只在空中交互了两次，所以Mallory的攻击时机有两个，第一个是Bob和Alice交换MIC的时刻，另一个是在Bob和Alice交换明文的时刻。 分两种攻击行为 篡改MIC或者明文其中一项，属于篡改攻击。 如果篡改MIC，那就是在未知明文和TK的情况下，凭空捏造一个EMIC，而且这个EMIC还要能够通过后续校验，这个几乎不可能。MIC是果，明文和TK是因，因果倒置不可能吧。 如果篡改明文，那就是给定MIC，基于MAC算法且未知认证密钥TK的情况下，推导出另一份明文，根据MAC算法性质，这个是很难做到的。 同时篡改MIC和明文，属于伪装攻击，也叫MITM攻击。 因为伪造认证码EMIC和伪造明文Erand是Mallory提供的，计算过程可能是EMIC = MAC(EK, Erand)，而真实配对码TK和伪造配对码EKEY只有百万分之一的几率是相同的，所以看作是不相同的，也即EK != TK，根据MAC的输入敏感性质，EMIC != MAC(TK, Erand)，最终认证失败。 ble4.0真的足够安全吗？ 我们先列出ble4.0安全机制各个密钥的安全依赖关系： CCM -&gt; sessionKey -&gt; STK(LTK) -&gt; TK 可以看到，最终的源头是TK认证码，只有保证TK足够安全，密文才能保证安全，也就是说不能让非法分子获得TK，否则他们就能够将密文解密了。 一般我们依靠MAC算法本身的性质，可以保证认证密钥不被推算出来，但是但是这些性质的前提是：认证密钥是使用密码学安全的、高强度的伪随机数生成器生成的，而且这些密钥位数很多，以至于无法穷举。 而实际TK的取值是000000~999999，最多只有100万种可能性，通过穷举的方式，抓取配对阶段（phase2.2）中用到的明文、MIC，就可以推算出TK了。 我们分析一下，如果在整个安全机制过程中，一直存在窃听者Eve，那么我们会面临什么威胁。 Tips：在这里也顺带分析静态配对码和动态配对码的区别，静态配对码是指每次输入都是固定的TK值，动态配对码是指每次输入都是动态产生的TK值，其实核心规范里面没有提过静态配对码，但是很多人会希望有如下功能：在一个设备预设一个配对码为123456，然后配对阶段时另一个设备输入配对码123456则通过认证，否则不通过，其实对于ble来说，由于TK可以被破解，所以静态配对码没有起到安全保护作用。 如果是静态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。 Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改； Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改； 伪装Bob或者Alice与对方首次连接，因为TK是静态配对码，通过认证，伪装成功。 如果是动态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。 Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改； Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改； 伪装Bob或者Alice与对方首次连接，因为TK是动态配对码，之前破解的TK用不上，无法通过认证，伪装失败。 总结出几个观点： 因为“认证”和“加密”都依赖于认证码TK，而TK不能提供很好的安全性（取值范围太窄），问题很大。 上面描述的威胁，首先是窃听成功，才能篡改成功，问题是出在了窃听上。正常情况下对于密文的处理，CCM需要先解密，后认证。如果Eve没有窃听成功，乱篡改Bob发出的CCM认证加密过的密文，那么Alice解密出来的数据几乎不可能通过后续认证的。正是因为Eve窃听成功，知道篡改哪部分内容，所以才会造成威胁。解决窃听问题，就能同时解决篡改问题了。 TK是不安全的，以至于如果使用静态配对码而不是动态配对码，就无法解决伪装问题，如果认证码不像TK那样范围窄，静态配对码技术本身也没什么问题，但是最好还是定期更新。 上面总结的也是ble4.2安全机制里面做的一部分改善，比如增加破解TK的难度，引入ECDH解决窃听问题，还有就是如果需要究极安全模式还是用动态认证码吧。 ble42安全机制mesh安全机制初探参考资料 《图解密码技术》 BLE配对过程详解 BLE核心规范 Hash算法总结 穷举法破解BLE的TK值]]></content>
      <categories>
        <category>一得之见</category>
      </categories>
      <tags>
        <tag>BLE</tag>
        <tag>安全机制</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建实战]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架，支持个性化的配置。这篇博文记录了搭建过程。 目录 配置主题 配置风格 配置语言 配置描述 配置目录 配置头像 配置拉条 配置社交 配置打赏 配置菜单 配置标签 配置分类 配置评论 配置分享 配置版权 配置脚注 配置统计 配置搜索 博文置顶 博文插图 配置主题修改博客工程根目录下的_config.yml文件 theme: hexo-theme-next 配置风格修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 scheme: Mist 配置语言修改博客工程根目录下的_config.yml文件 language: zh-CN 配置描述修改博客工程根目录下的_config.yml文件 description: &quot;Stay hungry, Stay foolish.&quot; 配置目录修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 toc: enable: true number: false 配置头像将头像图片文件123.jpg放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 avatar: url: /images/123.jpg 配置拉条none 配置社交修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 social: GitHub: https://github.com/jaydenh215 || github 配置打赏将打赏图片文件wechatpay.jpg放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 reward_settings: enable: true comment: “如果觉得还不错，请我喝杯咖啡吧~” reward: wechatpay: /images/wechatpay.jpg 配置菜单修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 menu: home: / || home tags: /tags/ || tags categories: /categories/ || th 配置标签增加一个页面（page）用来汇总标签 hexo new page tags 修改生成的页面文件内容（/source/tags/index.md） --- title: tags date: 2019-05-10 13:49:39 type: &quot;tags&quot; --- 给文章添加标签属性 --- title: 博客个性化配置 date: 2019-05-10 10:00:00 tags: - 博客 - 搭建 - 环境 - 配置 --- 配置分类增加一个页面（page）用来汇总类别 hexo new page categories 修改生成的页面文件内容（/source/categories/index.md） --- title: categories date: 2019-05-10 13:44:06 type: &quot;categories&quot; --- 给文章添加类别属性 --- title: 博客个性化配置 date: 2019-05-10 10:00:00 categories: - 社交 --- 配置评论next主题集成了许多第三方厂家的评论功能插件，选择比较精简的Valine。 修改主题目录（/themes/hexo-theme-next）下的_config.yml文件，主要是app id和app key。 valine: enable: true appid: xxxxxxxxxx appkey: xxxxxxxxxx guest_info: nick,mail notify: true placeholder: Comment here ... 增加评论区之后，右下角会有Power by Valine，可以这样删掉： 找到/themes/hexo-theme-next/layout/_third-party/comments/valine.swig文件并修改代码 修改前： &lt;script&gt; var GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;]; var guest = &apos;{{ theme.valine.guest_info }}&apos;; guest = guest.split(&apos;,&apos;).filter(function(item) { return GUEST.indexOf(item) &gt; -1; }); new Valine({ el: &apos;#comments&apos;, verify: {{ theme.valine.verify }}, notify: {{ theme.valine.notify }}, appId: &apos;{{ theme.valine.appid }}&apos;, appKey: &apos;{{ theme.valine.appkey }}&apos;, placeholder: &apos;{{ theme.valine.placeholder }}&apos;, avatar: &apos;{{ theme.valine.avatar }}&apos;, meta: guest, pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10, visitor: {{ theme.valine.visitor }}, lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos; }); &lt;/script&gt; 修改后： &lt;script&gt; var GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;]; var guest = &apos;{{ theme.valine.guest_info }}&apos;; guest = guest.split(&apos;,&apos;).filter(function(item) { return GUEST.indexOf(item) &gt; -1; }); new Valine({ el: &apos;#comments&apos;, verify: {{ theme.valine.verify }}, notify: {{ theme.valine.notify }}, appId: &apos;{{ theme.valine.appid }}&apos;, appKey: &apos;{{ theme.valine.appkey }}&apos;, placeholder: &apos;{{ theme.valine.placeholder }}&apos;, avatar: &apos;{{ theme.valine.avatar }}&apos;, meta: guest, pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10, visitor: {{ theme.valine.visitor }}, lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos; }); //新增 var infoEle= document.querySelector(&apos;#comments .info&apos;); if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0) { infoEle.childNodes.forEach(function(item) { item.parentNode.removeChild(item); }); } &lt;/script&gt; 配置分享修改博客工程根目录下的_config.yml文件 baidushare: true 修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 baidushare: type: button 按照链接中的方法，将static放进/themes/hexo-theme-next/source目录下。 修改baidushare.swig文件中的代码。 修改前： .src=&apos;//bdimg.share.baidu.com/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)]; 修改后： .src=&apos;/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)]; 配置版权修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 creative_commons: post: true 修改博客工程根目录下的_config.yml文件 url: https://jaydenh215.github.io/ 配置脚注修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 footer: powered: enable: false theme: enable: false 配置统计next主题集成了许多第三方厂家的统计功能插件，选择LeanCloud。 完成上述步骤之后，会发现阅读次数后面没有数字，那是因为LeanCloud和next主题还没有联系起来，需要按照该博主的方法来实现。 部署云引擎以保证访客数量不被随意篡改 20190514：总是有问题，所以现在先把leancloud_visitors安全设置为false。 配置搜索next主题推荐使用Local Search 博文置顶参考这里 博文插图修改主题目录（/themes/hexo-theme-next）下的_config.yml文件 post_asset_folder: true 这样每次hexo new XX，都会同时生成一个XX文件夹用来放图片。 为了去掉插图的边框，找到/themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl文件并修改代码。 img { box-sizing: border-box; margin: auto; padding: 0px; border: 0px; }]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>搭建</tag>
        <tag>配置</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
