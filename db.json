{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar_backup.gif","path":"images/avatar_backup.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/exturl.js","path":"js/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/affix.js","path":"js/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/post-details.js","path":"js/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/B419BCF613F9497BB3B75D9E1D863EA0.png","path":"images/B419BCF613F9497BB3B75D9E1D863EA0.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/imgshare.css","path":"static/api/css/imgshare.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/like.css","path":"static/api/css/like.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_popup.css","path":"static/api/css/share_popup.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/select_share.css","path":"static/api/css/select_share.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style0_16.css","path":"static/api/css/share_style0_16.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style0_24.css","path":"static/api/css/share_style0_24.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style0_32.css","path":"static/api/css/share_style0_32.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style1_32.css","path":"static/api/css/share_style1_32.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style2.css","path":"static/api/css/share_style2.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style1_24.css","path":"static/api/css/share_style1_24.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style2_16.css","path":"static/api/css/share_style2_16.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style2_24.css","path":"static/api/css/share_style2_24.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style2_32.css","path":"static/api/css/share_style2_32.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style4.css","path":"static/api/css/share_style4.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/weixin_popup.css","path":"static/api/css/weixin_popup.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style1_16.css","path":"static/api/css/share_style1_16.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/css/slide_share.css","path":"static/api/css/slide_share.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share.js","path":"static/api/js/share.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/data.js","path":"static/api/js/trans/data.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/logger.js","path":"static/api/js/trans/logger.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_0_16.png","path":"static/api/img/share/icons_0_16.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_0_24.png","path":"static/api/img/share/icons_0_24.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_0_32.png","path":"static/api/img/share/icons_0_32.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_1_16.png","path":"static/api/img/share/icons_1_16.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_1_24.png","path":"static/api/img/share/icons_1_24.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_1_32.png","path":"static/api/img/share/icons_1_32.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l0.gif","path":"static/api/img/share/l0.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l1.gif","path":"static/api/img/share/l1.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l2.gif","path":"static/api/img/share/l2.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l3.gif","path":"static/api/img/share/l3.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l4.gif","path":"static/api/img/share/l4.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l5.gif","path":"static/api/img/share/l5.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_2_24.png","path":"static/api/img/share/icons_2_24.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l6.gif","path":"static/api/img/share/l6.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l7.gif","path":"static/api/img/share/l7.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l8.gif","path":"static/api/img/share/l8.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/pop_c.gif","path":"static/api/img/share/pop_c.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r0.gif","path":"static/api/img/share/r0.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r1.gif","path":"static/api/img/share/r1.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r3.gif","path":"static/api/img/share/r3.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r4.gif","path":"static/api/img/share/r4.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r5.gif","path":"static/api/img/share/r5.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r6.gif","path":"static/api/img/share/r6.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r7.gif","path":"static/api/img/share/r7.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r8.gif","path":"static/api/img/share/r8.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/sc.png","path":"static/api/img/share/sc.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/selectshare_close.png","path":"static/api/img/share/selectshare_close.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/share-search-icon.png","path":"static/api/img/share/share-search-icon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/base/class.js","path":"static/api/js/base/class.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r2.gif","path":"static/api/img/share/r2.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/anticheat.js","path":"static/api/js/component/anticheat.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/animate.js","path":"static/api/js/component/animate.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/comm_tools.js","path":"static/api/js/component/comm_tools.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/pop_base.js","path":"static/api/js/component/pop_base.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/pop_dialog.js","path":"static/api/js/component/pop_dialog.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/pop_popup.js","path":"static/api/js/component/pop_popup.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/pop_popup_slide.js","path":"static/api/js/component/pop_popup_slide.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/qrcode.js","path":"static/api/js/component/qrcode.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/conf/const.js","path":"static/api/js/conf/const.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/conf/define.js","path":"static/api/js/conf/define.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share/api_base.js","path":"static/api/js/share/api_base.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share/combine_api.js","path":"static/api/js/share/combine_api.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share/image_api.js","path":"static/api/js/share/image_api.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share/like_api.js","path":"static/api/js/share/like_api.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share/likeshare.js","path":"static/api/js/share/likeshare.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share/select_api.js","path":"static/api/js/share/select_api.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share/share_api.js","path":"static/api/js/share/share_api.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/share/slide_api.js","path":"static/api/js/share/slide_api.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/component/partners.js","path":"static/api/js/component/partners.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_2_32.png","path":"static/api/img/share/icons_2_32.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/trans_bdxc.js","path":"static/api/js/trans/trans_bdxc.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/trans_bdysc.js","path":"static/api/js/trans/trans_bdysc.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/trans_weixin.js","path":"static/api/js/trans/trans_weixin.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/view/image_view.js","path":"static/api/js/view/image_view.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/view/like_view.js","path":"static/api/js/view/like_view.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/view/select_view.js","path":"static/api/js/view/select_view.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/view/share_view.js","path":"static/api/js/view/share_view.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_2_16.png","path":"static/api/img/share/icons_2_16.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/view/view_base.js","path":"static/api/js/view/view_base.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/base/tangram.js","path":"static/api/js/base/tangram.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/trans.js","path":"static/api/js/trans/trans.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/start/router.js","path":"static/api/js/start/router.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/static/api/js/view/slide_view.js","path":"static/api/js/view/slide_view.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1558682601277},{"_id":"themes/hexo-theme-next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1558682601278},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1558682601278},{"_id":"themes/hexo-theme-next/.git","hash":"3425b125179f900ab9d79c9d7c71331936367a72","modified":1558682597419},{"_id":"themes/hexo-theme-next/.gitignore","hash":"69e702b833c6aa9646ad24c45dd9cf00ab5ce6b9","modified":1558682601287},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1558682601278},{"_id":"themes/hexo-theme-next/.all-contributorsrc","hash":"43eb0149c78e464c695f0dd758bb8c59353182b3","modified":1558682601276},{"_id":"themes/hexo-theme-next/_config.yml","hash":"61813e125a80cafd08bc4c44f766b40e0fe89395","modified":1558682601289},{"_id":"themes/hexo-theme-next/README.md","hash":"3f72e5a5051ca2bdaccdda684c46dc4fdb4413a6","modified":1558682601288},{"_id":"themes/hexo-theme-next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1558682601288},{"_id":"themes/hexo-theme-next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1558682601289},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1558682601287},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1558682601287},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"6407d9063bd88ede299ff7c2a59cf2c82e079476","modified":1558682601298},{"_id":"themes/hexo-theme-next/bower.json","hash":"070292487d141982c9bef64bd32e1cb39d03d395","modified":1558682601289},{"_id":"themes/hexo-theme-next/package.json","hash":"d3ea523f723aafd6bebcd8a47a0d976c69dfeaf5","modified":1558682601341},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"78756d8a45b22bdaa51f12b06907bff44afee83e","modified":1558682601280},{"_id":"themes/hexo-theme-next/.github/CODE_OF_CONDUCT.md","hash":"f7ddb7faed8031a9f40eae4ee7bb48c1bc50fd14","modified":1558682601280},{"_id":"themes/hexo-theme-next/.github/eslint-disable-bot.yml","hash":"e06053d417579ed967a94166deb6bda5ce41d805","modified":1558682601283},{"_id":"themes/hexo-theme-next/.github/config.yml","hash":"cbd06d0c40afa9fdf056765120e9085826b00d20","modified":1558682601283},{"_id":"themes/hexo-theme-next/.github/auto_assign.yml","hash":"9fe0dbe3f6edc59bf10ea25b14eba0e92e2c8f42","modified":1558682601283},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"66e529edef048f3fab87d9670fa8999f483292bf","modified":1558682601282},{"_id":"themes/hexo-theme-next/.github/lock.yml","hash":"4f1070097b614b24050f238694127e3573ce8472","modified":1558682601284},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"1e212fe229bd659726b4a3bcf4b5b14e0310ba3a","modified":1558682601281},{"_id":"themes/hexo-theme-next/.github/mergeable.yml","hash":"1105a6eb0d4ee1b1bf1554c5c51a47160abed62a","modified":1558682601285},{"_id":"themes/hexo-theme-next/.github/weekly-digest.yml","hash":"6db3bcad65c3156de298f6a3ffd3ba887af4aa4f","modified":1558682601286},{"_id":"themes/hexo-theme-next/.github/topissuebot.yml","hash":"5091c3bc6f3df303d16d853ce65a302601c1e875","modified":1558682601286},{"_id":"themes/hexo-theme-next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1558682601285},{"_id":"themes/hexo-theme-next/.github/stale.yml","hash":"85975c43d606c39b91c0ad32197154be9d482a09","modified":1558682601285},{"_id":"themes/hexo-theme-next/.github/release-drafter.yml","hash":"0f826b5ea4646008e2e147dca8b4842ecf96d093","modified":1558682601285},{"_id":"themes/hexo-theme-next/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1558682601292},{"_id":"themes/hexo-theme-next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"721a1aa9feed1b580ab99af8e69ed22699121e88","modified":1558682601293},{"_id":"themes/hexo-theme-next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1558682601293},{"_id":"themes/hexo-theme-next/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1558682601292},{"_id":"themes/hexo-theme-next/docs/MATH.md","hash":"7d0330c250082a86897d1c96fbb4ef5df59538af","modified":1558682601293},{"_id":"themes/hexo-theme-next/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1558682601292},{"_id":"themes/hexo-theme-next/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1558682601293},{"_id":"themes/hexo-theme-next/docs/ALGOLIA-SEARCH.md","hash":"1e49c08b446678336b2eacc8bf581faca969f34b","modified":1558682601291},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1558682601340},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"5d06ee8f477ffc39932d0251aa792ffcaf8faf14","modified":1558682601340},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"af74e97d57cf00cde6f8dbd4364f27910915454e","modified":1558682601340},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"e79f43df0e9a6cf48bbf00882de48c5a58080247","modified":1558682601340},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"283519d4d5b67814412863a3e0212bac18bcc5a0","modified":1558682601341},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"79b3221344da335743b5ef5a82efa9338d64feb0","modified":1558682601299},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1558682601299},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1558682601299},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"ad0ac6a1ff341f8eab9570e7fb443962948c5f9d","modified":1558682601339},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"61bc56e77e653684fc834f63dcbdadf18687c748","modified":1558682601339},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"ba786b1baba49021928e2e508da53f2fd1369b3f","modified":1558682601305},{"_id":"themes/hexo-theme-next/languages/fa.yml","hash":"3227072c7e1bfb16ec0517394b60632f4be921dd","modified":1558682601300},{"_id":"themes/hexo-theme-next/languages/es.yml","hash":"db1a9f2af477212544c830c2dd986400e26ddd6a","modified":1558682601300},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"f3302a4dfdc9be38a52d6e081411574b1ea01671","modified":1558682601301},{"_id":"themes/hexo-theme-next/languages/fr.yml","hash":"2429c90dad5bb865e3a969be2b373f19b3a77b3b","modified":1558682601300},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"31eb878b53d60ff47e3e534cdd7a839c8801ac6e","modified":1558682601301},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"75f2fe142f76bf623e34ed3570598226f55f2b8b","modified":1558682601301},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"c7de8b77f44e75be4f04423088a1c891537aa601","modified":1558682601302},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"3f25eca504ee5a519987b4402731f1bb7f5191c9","modified":1558682601301},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"ca5072c967e5eb1178ffed91827459eda6e4e6e2","modified":1558682601302},{"_id":"themes/hexo-theme-next/languages/nl.yml","hash":"08f16ce395dacc88847fc30dc6b985ce22fb8948","modified":1558682601302},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1558682601302},{"_id":"themes/hexo-theme-next/languages/zh-CN.yml","hash":"069f15da910d6f9756be448167c07ea5aa5dc346","modified":1558682601303},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"e2f0dd7f020a36aa6b73ed4d00dcc4259a7e5e9d","modified":1558682601303},{"_id":"themes/hexo-theme-next/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1558682601302},{"_id":"themes/hexo-theme-next/languages/uk.yml","hash":"6320439c6e9ff81e5b8f8129ca16e9a744b37032","modified":1558682601303},{"_id":"themes/hexo-theme-next/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1558682601304},{"_id":"themes/hexo-theme-next/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1558682601303},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1558682601342},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1558682601343},{"_id":"source/_posts/ADC相关性能参数概念.md","hash":"5ceca0033c9ae446d925b73ec11546da8fa3f8cf","modified":1571808565068},{"_id":"source/_posts/BLE安全机制从入门到放弃.md","hash":"066493df74f7f81b4ed55d5160a30d40def1dcec","modified":1559969351013},{"_id":"source/_posts/cm-backtrace学习笔记.md","hash":"b171e21799d13b9a8951e5e6ec2dcec4b3ce06d6","modified":1559203980779},{"_id":"source/_posts/coder-handbook.md","hash":"0a79d4cf6fb6b3e29e0b1133410d43680527664a","modified":1568860677442},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）.md","hash":"2089f8bc7247e893a43f763b43d331815f6efce8","modified":1571807456537},{"_id":"source/_posts/rtt-nimble揭秘系列——移植nimble（3）.md","hash":"76d6c256c1dca81cdbb9a60c088e1802800d22ae","modified":1571807456950},{"_id":"source/_posts/rtt-nimble揭秘系列——预备知识（1）.md","hash":"e39b8bd758216fba44c0757a2325751eed62dea3","modified":1571807456995},{"_id":"source/_posts/rtt-nimble揭秘系列——题外话（0）.md","hash":"6933ee33492700b53674853b4a02e271a394ed1d","modified":1570426882588},{"_id":"source/_posts/博客搭建实战.md","hash":"d0655b40623475289b58ef2ccef8ba3ae09ea73a","modified":1558682573148},{"_id":"source/_posts/浅谈BLE核心架构和数据帧.md","hash":"a3eaccb48a4aef879c689177b5eec2fd803df3c0","modified":1571807456996},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1558682601459},{"_id":"source/categories/index.md","hash":"5d4ede611790e1420ddea55b80b3bf01bcd71f2b","modified":1558682573157},{"_id":"source/tags/index.md","hash":"b0c1bee3277fc56dc734f52003ff70eda42d79ea","modified":1558682573157},{"_id":"themes/hexo-theme-next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1558682601290},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1558682601460},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1558682601460},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558682601396},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"795b8ddb251da8e2327299d5f7dbf446fb9867c6","modified":1558682601281},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"245917ffaa296bc2d9a85444acf639077ca25944","modified":1558682601281},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/non-english.md","hash":"ae22e700b7c63c60746321719a20d34022ad78d9","modified":1558682601282},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"59b2b45e151972bbe08582cde22f398e58832765","modified":1558682601282},{"_id":"themes/hexo-theme-next/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1558682601294},{"_id":"themes/hexo-theme-next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1558682601295},{"_id":"themes/hexo-theme-next/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1558682601294},{"_id":"themes/hexo-theme-next/docs/ru/README.md","hash":"aeb95129ab1da9ec41786bfa86dc32c739ee6358","modified":1558682601294},{"_id":"themes/hexo-theme-next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"aaf25d304793344e2d026062768c93005723f5c6","modified":1558682601295},{"_id":"themes/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"508caa37443407860d03f4d8bd56b007585125ef","modified":1558682601296},{"_id":"themes/hexo-theme-next/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1558682601297},{"_id":"themes/hexo-theme-next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"b17fc344ff61603f83387c0f9b2b2189aae81d50","modified":1558682601298},{"_id":"themes/hexo-theme-next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1558682601298},{"_id":"themes/hexo-theme-next/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1558682601304},{"_id":"themes/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"018a259694f4a8c7c384e1f323531442cba5fbf3","modified":1558682601296},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1558682601305},{"_id":"themes/hexo-theme-next/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1558682601297},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1558682601305},{"_id":"themes/hexo-theme-next/docs/zh-CN/MATH.md","hash":"db2797f161e1e7a4987cbfa3d1be682266dfbba6","modified":1558682601298},{"_id":"themes/hexo-theme-next/docs/zh-CN/README.md","hash":"4016948fdb971e4f905efb7a5bb3add3dd58e7a8","modified":1558682601298},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"891ab67815969dd8736cb22fbbb3f791b8fff4e4","modified":1558682601306},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"d0b9e841d55c974d02f43823a06a2627f8e46431","modified":1558682601308},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"9a79dde1412b1b1473380e8b6cacfe1930ed321b","modified":1558682601309},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"076eef45ccbba3a6c7d936662306a76d0da0407d","modified":1558682601307},{"_id":"themes/hexo-theme-next/layout/_partials/github-banner.swig","hash":"1ad13269b43b900356f3bdab7947d6a86f035a2c","modified":1558682601310},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1558682601314},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"91017f58f83d9505ce99109fffdc51c032bf017e","modified":1558682601307},{"_id":"themes/hexo-theme-next/layout/_partials/post-edit.swig","hash":"dee345054d564dd56f74bb143942d3edd1cb8150","modified":1558682601314},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"cccd93d30787675010b1a74ef02eb5b813ec1d96","modified":1558682601320},{"_id":"themes/hexo-theme-next/layout/_scripts/exturl.swig","hash":"c2e8f4b3a2bf991320ecc827dcdc227399ad5b51","modified":1558682601320},{"_id":"themes/hexo-theme-next/layout/_scripts/next-boot.swig","hash":"50c3ae6b50f173ae70f8c3312f7c6da1097eb9b6","modified":1558682601320},{"_id":"themes/hexo-theme-next/layout/_scripts/noscript.swig","hash":"efb3404a3303622f3be60944d9d1926972c5c248","modified":1558682601321},{"_id":"themes/hexo-theme-next/layout/_scripts/scroll-cookie.swig","hash":"8a992b7fe42b9c1a5eb9d937b0827aed91586d94","modified":1558682601324},{"_id":"themes/hexo-theme-next/layout/_third-party/baidu-push.swig","hash":"87bcb495f7ddd81cc3fe2c2a886e51c08053019b","modified":1558682601330},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"4130f995f0c4f81a44266194ecae9df96fad174c","modified":1558682601325},{"_id":"themes/hexo-theme-next/layout/_third-party/bookmark.swig","hash":"4b93dc7ac0573c402aabcb5c933bbcb893b07c51","modified":1558682601332},{"_id":"themes/hexo-theme-next/layout/_third-party/chatra.swig","hash":"87182367d7954457cb2498bbfa9445c03c2d619e","modified":1558682601332},{"_id":"themes/hexo-theme-next/layout/_third-party/mermaid.swig","hash":"80dfc0879866e6512cb67590a3b2d8741a66f980","modified":1558682601336},{"_id":"themes/hexo-theme-next/layout/_third-party/copy-code.swig","hash":"e0d65688661875200cb4dd401fc5ac833c697f91","modified":1558682601335},{"_id":"themes/hexo-theme-next/layout/_third-party/pangu.swig","hash":"76f5933925670044ec65b454295ba7e0a8439986","modified":1558682601337},{"_id":"themes/hexo-theme-next/layout/_third-party/quicklink.swig","hash":"7cc1294a5fbedf3502688248a433c358339e5ae0","modified":1558682601337},{"_id":"themes/hexo-theme-next/layout/_third-party/pdf.swig","hash":"4ae61c7efb16e962385bfe522a38c4d29cdcccbe","modified":1558682601337},{"_id":"themes/hexo-theme-next/layout/_third-party/tidio.swig","hash":"b44010cd577e4d063c3406772938c4b117ec7b7b","modified":1558682601339},{"_id":"themes/hexo-theme-next/scripts/filters/exturl.js","hash":"b19c7c1021e57367b3b3bbf5678381017ed5667d","modified":1558682601341},{"_id":"themes/hexo-theme-next/scripts/helpers/next-url.js","hash":"a40ce6bc852bb4bff8b9f984fa064741dd151e96","modified":1558682601342},{"_id":"themes/hexo-theme-next/scripts/helpers/engine.js","hash":"cdb6152582313268d970ffeef99b4a8a7850f034","modified":1558682601342},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"7db4ad4a8dd5420dad2f6890f5299945df0af970","modified":1558682601336},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"95a520f6529424a03c7ead6dbfd5e626d672febb","modified":1558682601343},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1558682601344},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"f9f25905adecfb8be49def4ff3b0b8bbc6955d84","modified":1558682601345},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"a6b2264215c555c553b2c5db85fa90678798d0d5","modified":1558682601345},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"23d839333422375e85d44e476f554faf49973a3c","modified":1558682601345},{"_id":"themes/hexo-theme-next/scripts/tags/include-raw.js","hash":"ab4a82a7246265717556c7a42f897430340b88cf","modified":1558682601346},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1558682601347},{"_id":"themes/hexo-theme-next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1558682601347},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1558682601348},{"_id":"themes/hexo-theme-next/scripts/tags/pdf.js","hash":"ab995f0fc60d60f637220e2651111b775b8a06de","modified":1558682601347},{"_id":"themes/hexo-theme-next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1558682601348},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1558682601347},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"c476dc3693a9dd0be2d136a45b0d7fdef55d4d92","modified":1558682601337},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1558682601398},{"_id":"themes/hexo-theme-next/source/images/avatar_backup.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1558682601405},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"882cd0b68c493af1b6d945660f9c21085e006ffc","modified":1558682601338},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1558682601406},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1558682601406},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1558682601407},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1558682601408},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1558682601398},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1558682601408},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1558682601408},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1558682601409},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1558682601409},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1558682601407},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1558682601409},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1558682601410},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1558682601408},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1558682601409},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1558682601407},{"_id":"themes/hexo-theme-next/source/js/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1558682601411},{"_id":"themes/hexo-theme-next/source/js/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1558682601411},{"_id":"themes/hexo-theme-next/source/js/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1558682601411},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1558682601406},{"_id":"themes/hexo-theme-next/source/js/js.cookie.js","hash":"f11e84def0352b7dd6393f1b83e55a40ab468686","modified":1558682601412},{"_id":"themes/hexo-theme-next/source/js/motion.js","hash":"d0a6d9dbcc57159e54bbb1f683b86632ae0b78f0","modified":1558682601412},{"_id":"themes/hexo-theme-next/source/js/next-boot.js","hash":"696a0c2cf158001576d56b48195ec8e39e835b47","modified":1558682601413},{"_id":"themes/hexo-theme-next/source/js/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1558682601414},{"_id":"themes/hexo-theme-next/source/js/post-details.js","hash":"7d309b771e86c7e22ce11cc25625481ef7d5985c","modified":1558682601413},{"_id":"source/_posts/ADC相关性能参数概念/量化误差.jpg","hash":"90e2fa48b90e2661a81dfc565b71ee2d1a8f89ba","modified":1571808361213},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"5e7d28bc539e84f8b03e68df82292f7fc0f2d023","modified":1558682601396},{"_id":"themes/hexo-theme-next/source/js/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1558682601414},{"_id":"themes/hexo-theme-next/source/js/utils.js","hash":"fed16cd4fa5fac8cb4a63633d1840792a056f2be","modified":1558682601415},{"_id":"source/_posts/BLE安全机制从入门到放弃/7^xmod13=8.png","hash":"dbfff87af84204fd53dfee761c3aed2f18b9c76b","modified":1558682573131},{"_id":"source/_posts/BLE安全机制从入门到放弃/DH.epgz","hash":"c96a3bf69dd22d7b9eb2fc0e2137f59484ef550b","modified":1558682573134},{"_id":"source/_posts/BLE安全机制从入门到放弃/ECDH.epgz","hash":"f542b7d155dd935b88d34d24ae2c444046355600","modified":1558682573135},{"_id":"source/_posts/BLE安全机制从入门到放弃/DH.png","hash":"d6435da8c3d0b8053b2291f4cf4a79ef0e937359","modified":1558682573135},{"_id":"source/_posts/BLE安全机制从入门到放弃/ECDH.png","hash":"fc08f4a537b4811b5ccda562e78cf73a59250387","modified":1558682573136},{"_id":"source/_posts/BLE安全机制从入门到放弃/7^xmod13=y.png","hash":"da1c6da03d06b035d0abcd25b734ccd5f053e8a4","modified":1558682573131},{"_id":"source/_posts/BLE安全机制从入门到放弃/BleImportantPerson.png","hash":"84b49ce09bbee06c626886b08a0472f794fe585f","modified":1558682573132},{"_id":"source/_posts/BLE安全机制从入门到放弃/ImportantPerson.png","hash":"020d61af6dc195fe4d2423c6f3389ce6e772bee0","modified":1558682573136},{"_id":"source/_posts/BLE安全机制从入门到放弃/CCM.png","hash":"c2283e671c52118d3c371cef58ec98b14e63d0b3","modified":1559969351026},{"_id":"source/_posts/BLE安全机制从入门到放弃/KindOfPhase.epgz","hash":"b2e52539f360093a3f2f3087f65128e9b94507e8","modified":1558682573137},{"_id":"source/_posts/BLE安全机制从入门到放弃/CCM.epgz","hash":"69cb2f04fe49ee0120196950d43919f1c38a4e07","modified":1558682573132},{"_id":"source/_posts/BLE安全机制从入门到放弃/ImportantPerson.epgz","hash":"02b442bd7f481363ff5cc1df4226a63d66375adc","modified":1558682573136},{"_id":"source/_posts/BLE安全机制从入门到放弃/MITM.epgz","hash":"95106d9a21316667f875daa25e25e54eceb0c0c4","modified":1558755171252},{"_id":"source/_posts/BLE安全机制从入门到放弃/SecurityTechnology.png","hash":"71ee835fa867b0f1ac3122ad2abb9125022345bb","modified":1558682573140},{"_id":"source/_posts/BLE安全机制从入门到放弃/ECDHMITM.epgz","hash":"792a94ae8630e2d74978366a0471aa2b1adab8d3","modified":1559969678689},{"_id":"source/_posts/BLE安全机制从入门到放弃/SymmetricCryptography.epgz","hash":"b2b2eae710fa45612c518aa2e3b0096d2648f728","modified":1558682573143},{"_id":"source/_posts/BLE安全机制从入门到放弃/SecurityTechnology.epgz","hash":"75b268b49d6996e56ff2ef4ebc5f635877050f17","modified":1558682573140},{"_id":"source/_posts/BLE安全机制从入门到放弃/SmpAndEncryption.epgz","hash":"10cff84d5ef55d8fa716e9349b7177e68bd97234","modified":1558682573141},{"_id":"source/_posts/BLE安全机制从入门到放弃/SymmetricCryptography.png","hash":"d63bd461151b6219179d4ca383ae286ba7d40659","modified":1558682573143},{"_id":"source/_posts/BLE安全机制从入门到放弃/authentication.png","hash":"71e0d4dd0e3be4b08e486be8225a7ca18ec4fce1","modified":1558682573144},{"_id":"source/_posts/BLE安全机制从入门到放弃/camouflage.epgz","hash":"e92fd4a11801f1fa7a00e1ab7d93d222f8deec1a","modified":1558682573144},{"_id":"source/_posts/BLE安全机制从入门到放弃/MAC.png","hash":"47943a1da3fd9dfa69b73f401d4322193a07b035","modified":1558682573138},{"_id":"source/_posts/BLE安全机制从入门到放弃/tamper.epgz","hash":"80c9019b730fae4e6e2e19717c41c478dbfa0843","modified":1558682573146},{"_id":"source/_posts/BLE安全机制从入门到放弃/camouflage.png","hash":"3abe2376eb89a91fc2bab329c290500f67da5a81","modified":1558682573146},{"_id":"source/_posts/浅谈BLE核心架构和数据帧/ble_communicate.svg","hash":"531eb3488afe1c91ccdc69095b2ea7291e41d062","modified":1571807456996},{"_id":"source/_posts/浅谈BLE核心架构和数据帧/ble_core_architecture.png","hash":"c9a5cec085a4bd17d700f56010f11f98582fb5ca","modified":1571807456997},{"_id":"source/_posts/BLE安全机制从入门到放弃/KindOfPhase.png","hash":"13b978c9fd394bfecb8f0aac4b3c8ba6c6caa8a4","modified":1558682573138},{"_id":"source/_posts/BLE安全机制从入门到放弃/tamper.png","hash":"73dfccb2519f153b34bea3160462d48056582168","modified":1558682573147},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558682601384},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558682601384},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558682601385},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558682601394},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558682601396},{"_id":"themes/hexo-theme-next/source/images/B419BCF613F9497BB3B75D9E1D863EA0.png","hash":"3832f45e642417161423260d21a8a05959de548e","modified":1558682601398},{"_id":"themes/hexo-theme-next/source/images/wechatpay.jpg","hash":"f48b46fee8c09cc7c8fabd98f7e34de0a9b3f46a","modified":1558682601410},{"_id":"source/_posts/BLE安全机制从入门到放弃/ECDHMITM.png","hash":"4064f1eeec1886a422fe4190aebc125f2f36c777","modified":1559969671653},{"_id":"source/_posts/BLE安全机制从入门到放弃/MITM.png","hash":"32c080d403881e1ff8b8ac68f73f9aa977c12fcd","modified":1558682573140},{"_id":"source/_posts/BLE安全机制从入门到放弃/authentication.epgz","hash":"ea1448480ee1f5d0970e8cd67978342ee87cdd9e","modified":1558682573143},{"_id":"source/_posts/浅谈BLE核心架构和数据帧/ble_core_traffic_bearers.png","hash":"53ed29a12e66bc9bcbeb53c23e10d174ff5ce048","modified":1571807456999},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1558682601306},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-item.swig","hash":"25aea3d764b952f3f6d28ab86d7212d138e892df","modified":1558682601306},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"b57bf9c865bed0f22157176a8085de168a1aef77","modified":1558682601310},{"_id":"themes/hexo-theme-next/layout/_partials/head/head-unique.swig","hash":"fd079a414ca0f42f4cddd00247a9d5a5f58c4d8e","modified":1558682601310},{"_id":"themes/hexo-theme-next/layout/_partials/head/head.swig","hash":"466e69a4b4fbdc57f33e60a16b0d87e494385e21","modified":1558682601311},{"_id":"themes/hexo-theme-next/layout/_partials/page/breadcrumb.swig","hash":"2b905ddd5dea8558c3fd95aacad241da6b6800f4","modified":1558682601313},{"_id":"themes/hexo-theme-next/layout/_partials/page/page-header.swig","hash":"f46699a9daa5fef599733cbab35cb75cf7a05444","modified":1558682601314},{"_id":"themes/hexo-theme-next/layout/_partials/header/brand.swig","hash":"03f669356bbaa70144b743f3312178e1981ac3a8","modified":1558682601311},{"_id":"themes/hexo-theme-next/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1558682601312},{"_id":"themes/hexo-theme-next/layout/_partials/header/menu.swig","hash":"39c4ad0e36b7c1260da98ba345f7bd72a2ac0f2e","modified":1558682601312},{"_id":"themes/hexo-theme-next/layout/_partials/header/sub-menu.swig","hash":"e015c7d9b84062b60b15b36be3ef11929dd10943","modified":1558682601313},{"_id":"source/_posts/BLE安全机制从入门到放弃/SmpAndEncryption.png","hash":"ec56885d66837e822303bfe2dcd63fc92306c835","modified":1558682573142},{"_id":"themes/hexo-theme-next/layout/_partials/post/reward.swig","hash":"f62b801c7999da67b4bdca9c5e373b9b5ed039dc","modified":1558682601315},{"_id":"themes/hexo-theme-next/layout/_partials/post/wechat-subscriber.swig","hash":"60d131a3065622566f1398e6f3d1dd552b7b0172","modified":1558682601316},{"_id":"themes/hexo-theme-next/layout/_partials/post/post-related.swig","hash":"f331ad02beea8990066d32ad6ec9f859672c3615","modified":1558682601315},{"_id":"themes/hexo-theme-next/layout/_partials/search/index.swig","hash":"f14e9e8c27af82f1bfe794e252dec0d7e521f503","modified":1558682601317},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"31245e09ce0465b994cebd94223a531585c4eab4","modified":1558682601317},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"c609097b95eb6127c2784f47f2230e6e6efc0be2","modified":1558682601319},{"_id":"source/_posts/BLE安全机制从入门到放弃/y=xg.png","hash":"06de3fd8179dcbaa0ca2ea9cba20f7043e167846","modified":1558682573147},{"_id":"source/_posts/BLE安全机制从入门到放弃/g^xmodp=y.png","hash":"19f6daaa5b7f731848ca27c5002d013840780ded","modified":1558682573146},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"cf87ab778618a32119ec1c4ac2079a51385b1913","modified":1558682601322},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a62c93f19429f159bcf0c2e533ffc619aa399755","modified":1558682601323},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"3c548934b97cc426544947f7a2ae35c270b5e33f","modified":1558682601323},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"7ef07edd2a97a3774229990d2f0a6eefa31bd015","modified":1558682601324},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"828eb9c47f34090c841a2e9a0b3f31b0e4ccf40a","modified":1558682601324},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1558682601317},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"e5d777e9a48381dff233b154336d0e19736519dc","modified":1558682601319},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"66d562b3778dbc839f7c00103bd0099c5d61602a","modified":1558682601325},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"73576c9683d9ad9b124916dc6c660607fe7cc1fa","modified":1558682601326},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"335005a9f8b36349f0ad0a7beeba6969c55fc7f7","modified":1558682601328},{"_id":"themes/hexo-theme-next/layout/_partials/search/algolia-search.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1558682601316},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"83dd7df11b100bae38c9faab9a478f92149a0315","modified":1558682601325},{"_id":"themes/hexo-theme-next/layout/_partials/share/likely.swig","hash":"647e8677d1ccfb3f7918dd3ea2ff7078504a845d","modified":1558682601319},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"54d7993ae773573ee103c22802b7e98b193e1a3a","modified":1558682601329},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"53202062267391353d49f269e7eb74eb87d30921","modified":1558682601328},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/growingio.swig","hash":"623e73bedef067ac24a398ef27c8197295da872d","modified":1558682601329},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"39928f358dd13d9fc1a4641800e57be157ecd815","modified":1558682601329},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"2e1de38f44af00209129d4051b7ae307cb11ad68","modified":1558682601328},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"8ab040fccba41675bc835973515530af8a51f8bd","modified":1558682601328},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"d18c87d7839e7407e39acd2998bcc9e0b34611b0","modified":1558682601330},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"d685df1516cb138d7a83bac5d7878a1e0fa8bc04","modified":1558682601333},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"4cff8bf5c42c62f7f0ac1f0d70f839dae39ba77a","modified":1558682601330},{"_id":"themes/hexo-theme-next/layout/_partials/post/post-copyright.swig","hash":"be6683db6a269d83bb0441d7cf74db63a240fa8a","modified":1558682601315},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"71fb01bcad43bc9410ab19190373b9f7e59215b5","modified":1558682601329},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"a22d1ea29a5ffe46199ab7d108a291a05af8d5b6","modified":1558682601330},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"1a5d94f5779a2ce13abc886dd78e0617f89c34b9","modified":1558682601335},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"b3818fd0b3028dadf341b6d0b180e1243683de6a","modified":1558682601334},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"9a4923d2aa5182531ea7a7fb9abe824450026208","modified":1558682601334},{"_id":"themes/hexo-theme-next/layout/_third-party/math/index.swig","hash":"43a20fa0e9ae2f4254f04813f9c619dd36b49ae5","modified":1558682601336},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitalk.swig","hash":"4e86e1ace90a70bb8862f5e6de9dbe7bfc046bee","modified":1558682601334},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqusjs.swig","hash":"8b4a94dd80b3bac7c5390c8a7fd377b88c2cb78e","modified":1558682601333},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"ce533f44dd0f090dcf164ce31a722176e61dde2e","modified":1558682601335},{"_id":"themes/hexo-theme-next/layout/_third-party/math/katex.swig","hash":"ea1c136f960667a0a13b334db497b9b19c41f629","modified":1558682601336},{"_id":"themes/hexo-theme-next/layout/_third-party/math/mathjax.swig","hash":"767ba29f258db5d2e5baf875a6f36ac1d44df6a3","modified":1558682601336},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"078bd2d5815eb23e8c5f74467dc0042babea00ae","modified":1558682601338},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1558682601383},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"1aabac9e37a8f4451c86d09037b3a1f8b30eaf5e","modified":1558682601384},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"bc3fc9d053b3d1fc0cd3918bf9a629a6f38f6414","modified":1558682601333},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"21a14a19149f1cb8e011c477f29dd1352675605b","modified":1558682601385},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search.swig","hash":"143ef265c96a8ea2fb93c36c5ffb9c5e940f7693","modified":1558682601338},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1558682601394},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"e9b0752f08398709e787546a246baca12b4c557f","modified":1558682601394},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"da7049f3d9a157abe0ecc62611edcf43605ba84d","modified":1558682601395},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1558682601383},{"_id":"themes/hexo-theme-next/source/js/schemes/muse.js","hash":"ccc0c5cd4ec6f8159c98990ad83f11a5c0b0234c","modified":1558682601413},{"_id":"themes/hexo-theme-next/source/js/schemes/pisces.js","hash":"3eea56cc9ce47bb4760930c4c69cebf847a7fbb2","modified":1558682601414},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"ebc95eeb8966d17cdc7dd0de009deaef1fe65064","modified":1558682601395},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"d45ca53af17d1d83fd27f8ed0917a72f0060e1a9","modified":1558682601339},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1558682601426},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1558682601427},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1558682601415},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1558682601416},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1558682601416},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1558682601417},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1558682601417},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/nrfx_config.png","hash":"acff63e662587474e3b3bce3ab8f125e29d846ce","modified":1571807456892},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/rtconfig_keil.png","hash":"242761f78c302f19b40bd67f586eb6f94554ef6a","modified":1571807456949},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/cmsis_include.png","hash":"bc1745ac0e89634ec81b733b0d42458f9670e030","modified":1571807456567},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1558682601386},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1558682601387},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"8da8416213127595dfc4d2b358639194647e7bd3","modified":1558682601386},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"40f266e24af4dedc9497056ab18ebcfda38dd47d","modified":1558682601387},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"6aee54cd5a20181e18596565356bd54c66e33823","modified":1558682601388},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"06d9d00257abd28414ec0b746f866bf9911cf5ec","modified":1558682601388},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"04706657af638f2746ae59520e6fc78577c7682c","modified":1558682601389},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"157e6915dcf5990566e463acffa71043b2651c07","modified":1558682601390},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"25f05ed8da68d034dce7f06e0f20f6cd55841070","modified":1558682601388},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"6aee54cd5a20181e18596565356bd54c66e33823","modified":1558682601391},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1558682601391},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"b9619c9827f969ca2e2f5878552362a7b858918f","modified":1558682601392},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1558682601427},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"234b44cfd03f9c9e3e179ff5fd698ac876341913","modified":1558682601390},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"e73d6da74c5755442e831d8fd7d922c5b32bd892","modified":1558682601392},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"adb7379f3b9001840eb38b260434e89365771a81","modified":1558682601394},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"0b3001909f3446843b226030524ea8498d4d8997","modified":1558682601393},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"5c0ca7f801859cff254d2f5b7d1a70d66ff61a8d","modified":1558682601349},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"a609ff811f2b2764f5470236fe2fb1f3aa6ccba5","modified":1558682601386},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"5b5e0a02a7bf63de9efcd33a4e482939cce5822d","modified":1558682601393},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1558682601350},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"997058180065d986e05df72992cc2cbfd7febd7e","modified":1558682601350},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0d6f0df798449b710e1e5dbd43d470089b2a3c95","modified":1558682601393},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"463817cbbd804ce134cb3e7e721431cb0e1616f2","modified":1558682601349},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"a4c6ee546a94fd69e5b7a1e4c054ab8cacb73d2a","modified":1558682601365},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"9fd526db0527c71243f05e18086f937dc67b1c3e","modified":1558682601350},{"_id":"themes/hexo-theme-next/source/css/_common/components/rainbow.styl","hash":"cfa64bd8ee2ff9f943673e339d69341e76fbf031","modified":1558682601370},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"40144394fdfe05d400f39f6763f66f75479a2e34","modified":1558682601381},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"35c6fd7eab3779bd9e38b7ba8825ab0c67a1be7a","modified":1558682601381},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"9c6194177533619a6f6685dc7e890dcbec456241","modified":1558682601381},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"fec36a14080104b5862e9f021eab117d87c5f7c5","modified":1558682601382},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1558682601382},{"_id":"themes/hexo-theme-next/source/css/_common/components/scrollbar.styl","hash":"afdd21533db18d846e1a2663b1199761b1bd2c1e","modified":1558682601370},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"107f42aa590ec4ba0765a0bc5d735f0f09edc0ff","modified":1558682601382},{"_id":"themes/hexo-theme-next/source/static/api/css/imgshare.css","hash":"7465b359751d368f4a45f7823dc4a1918bba7f5f","modified":1558682601428},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"1a4ac0d119f2126ef8951897338706edce112235","modified":1558682601380},{"_id":"themes/hexo-theme-next/source/static/api/css/like.css","hash":"2024d58206df01b858c38f07957f928b44e14cb3","modified":1558682601429},{"_id":"themes/hexo-theme-next/source/static/api/css/share_popup.css","hash":"338ba2b30ef8ce0c84cd36b37d7f8482996291dc","modified":1558682601429},{"_id":"themes/hexo-theme-next/source/static/api/css/select_share.css","hash":"d0259abdb410193cf761e42bffaa51e70327a0cd","modified":1558682601429},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style0_16.css","hash":"090e77e9e6e9b8ee0d73a233cbe46499de935bdd","modified":1558682601430},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style0_24.css","hash":"7d1f9f32b80f91001f4f951aa045180cde22d82e","modified":1558682601430},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style0_32.css","hash":"7c2d12ea532c8a55c102b649bb23ef5bf53b3ed3","modified":1558682601431},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style1_32.css","hash":"626d67a4c0bb72a152e90d25dbf281c0c35a2140","modified":1558682601431},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style2.css","hash":"1ad451187cde8a74843fd398b924ca0ac911e9be","modified":1558682601432},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style1_24.css","hash":"3ee5f745c863b4f68299fe5dc125f913ca619c07","modified":1558682601431},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style2_16.css","hash":"572c8e856988e463eb865f38d33ba003cc20d083","modified":1558682601432},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style2_24.css","hash":"917d963d3be111064cbb1d122963da91ee3724a0","modified":1558682601432},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style2_32.css","hash":"3657bbc4b5bbc66ebca4906ee0a1cbf9f98be883","modified":1558682601433},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style4.css","hash":"0a9e2ed712a5ef5c4699c038cd001a0d688a0fdf","modified":1558682601433},{"_id":"themes/hexo-theme-next/source/static/api/css/weixin_popup.css","hash":"5e6c5084bfd16051de5776c2e136a5462b08a32c","modified":1558682601433},{"_id":"themes/hexo-theme-next/source/static/api/css/share_style1_16.css","hash":"aeb4e9fa96cfa0167481e1f4007079dc3f3c6c27","modified":1558682601431},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1558682601418},{"_id":"themes/hexo-theme-next/source/static/api/css/slide_share.css","hash":"3898feaf45559b039f885bee8f9e831f48adb20c","modified":1558682601433},{"_id":"themes/hexo-theme-next/source/static/api/js/share.js","hash":"73bdb33580128e6c79a726a25f98092c0faa369d","modified":1558682601451},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/data.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558682601455},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/logger.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1558682601455},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1558682601422},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1558682601419},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1558682601424},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1558682601389},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1558682601389},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1558682601391},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"2df409df04fdb52d7234876a9f6e502edd4e3929","modified":1558682601352},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/github-banner.styl","hash":"a8f4d4b86acaa34c99111b2dde5d0779cc7e0de6","modified":1558682601352},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"c9cfb4b99e1ec8ec9cf075cb761b8f7fa5fe63fd","modified":1558682601352},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1558682601353},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"b8647d6140141b0a160607f6353e4d4594cca92e","modified":1558682601353},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"33200f60bd6a8bbfc66dd49a239bcc75c2f564c1","modified":1558682601353},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"3a0efe849587b34f20d4e260028dc799215b0bb3","modified":1558682601354},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"9c1a082e6c1f96187a099c3f4cb5424c0c9fd06e","modified":1558682601361},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"e5a5f8747fdf2ca960e4e73c081b8952afd62224","modified":1558682601362},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"fa1cea6fcc3f552d57cc7d28380a304859139bf6","modified":1558682601363},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1558682601363},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"9a8fb61bd2d184de9d206e62ba8961d1845c5669","modified":1558682601364},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"024e8ff40ca881c6fbf45712897e22f58a3811ab","modified":1558682601360},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1558682601364},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"c27527cdeb9e3a9f447f7238f442a5dc33fde4e6","modified":1558682601364},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"c97c819a65f6967485184399397601e5133deda6","modified":1558682601364},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1558682601365},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1558682601362},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"b6a241626783d2ac115d683fd59ec283af68e5bb","modified":1558682601366},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"a73346f999b31355075cd58637946a8950cf6f7e","modified":1558682601366},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"fc94dd09b4245143b452d6cf2fc4c12134d99d6d","modified":1558682601366},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"f3b0d259e991ac86454ae5eac6bc94dc8691d8c9","modified":1558682601365},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reading_progress.styl","hash":"4aad8e36178faaa71a767af0084d578df4c09f73","modified":1558682601367},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1558682601368},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1558682601368},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"d77f85d3af2d7090d84b28ab01c6a49f92eec647","modified":1558682601367},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"c8009fd9598a661b7d23158b5121b6ac266939e9","modified":1558682601369},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"ccd0b1309acff0c676fdcc848a8ae2d05f0369ab","modified":1558682601368},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"539fc0880b2e035e8316d5d4b423703195c1b7ba","modified":1558682601369},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"981795aad232c8bd3f52a0ed8720db696d18a234","modified":1558682601369},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"e17a00d22e4b11af8ca71d1a278b804b8e40f2cc","modified":1558682601366},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"03a4e75e963e3e7cc393d588b1495a88d52e0e40","modified":1558682601371},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"e58bb8b7127aa21e8260493a425ec00fcb25d338","modified":1558682601372},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"615fca7dff197a2ca3df674cf963ce70b8525985","modified":1558682601369},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"a5484d8436b2b7862faf6e7309a9e7b88cdd0027","modified":1558682601370},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"ab1776c5dc537beabb0ab81a0f04e08bebad070b","modified":1558682601370},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"7e2ba73073daaea0a18c3d67ff137dd683af7011","modified":1558682601372},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"0eadef0381f696de7f88d7dc5f0ddc3cd5d309b3","modified":1558682601372},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1558682601374},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"3cb387fa70017f3c24a1a1884461d29deda54585","modified":1558682601373},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"b43421291bf85b589e8d0ec853e238d36ab80631","modified":1558682601375},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"ed3a2960ebce7396d1893bb8e08c99c7d9259140","modified":1558682601373},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/pdf.styl","hash":"3baeeb51cfe123e99235ee1816d0e1f6a97c7852","modified":1558682601376},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"fde59300ec38868676ff5ed495b9dc9b02d07ffc","modified":1558682601374},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"da7a21f5a2f7dcf4c5a4788d7670159ca4132b65","modified":1558682601376},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1558682601375},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"54c5398c7bf5b8bd9f38a9ece1dd82a9255f9a30","modified":1558682601376},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"a01484e350ad5fc9b1fdfbfafb2ddd9687ad4d20","modified":1558682601378},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"2fbe52f955da41c7a14eb09918bf86a252e4504f","modified":1558682601378},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"2a1008f1044b450b806adc166754ba9513e68375","modified":1558682601378},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"4305813408a1cd6aba764a7769b94b081d383d4f","modified":1558682601377},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"6880467b4f6d7b057fb8291aa10966429a0a3bff","modified":1558682601379},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"35dc9f3990fadff3ea038d4e8ac75923219886ed","modified":1558682601379},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"9801977a23268e36c5deefd270423f6f1a0c3bb2","modified":1558682601379},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/copy-code.styl","hash":"d9c244b1c3a09a7fccd3c3f732e6fb112a8cd565","modified":1558682601377},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"7cf42f96ba6b249c75e00dad251ebacf7de61e6c","modified":1558682601380},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"ed8a12982c0497eeb9d7642781abeb801428f83d","modified":1558682601378},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_0_16.png","hash":"0eec1e81a04664b2032bd389513349e9bd5d5b0f","modified":1558682601434},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_0_24.png","hash":"a89223f9714c8c4fa169430a327963ca6a1c9a6e","modified":1558682601435},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_0_32.png","hash":"c20521634fdacef39631031671528713e6ba6081","modified":1558682601435},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_1_16.png","hash":"3793c3265429ab7b830bfaf18322259cd0b4c4ef","modified":1558682601436},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_1_24.png","hash":"9f1d472095dbe138ef7aff069b1d18cae6ffa942","modified":1558682601436},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"020fac447d7a17c03e2802f0f724ae0738088354","modified":1558682601375},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9204c79c05d620ecd5d411cdf11e27441b6281dc","modified":1558682601372},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"13d365ee626c01f17ec664b3f54f51d8b9ee7cf4","modified":1558682601367},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_1_32.png","hash":"09825de5f238c97e4374d545961d6e0d5bbfb3e2","modified":1558682601437},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l0.gif","hash":"738b92632b0a9789a9eb568b8d101eb64f55f6e0","modified":1558682601438},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l1.gif","hash":"70e1932ca7a622ed3322b683eceb7a590860a55e","modified":1558682601439},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l2.gif","hash":"e6a5d6104c226a686d48759e0268e09d762e242e","modified":1558682601439},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l3.gif","hash":"26c0dd37d98df63abb9d3d83e01bb47c34ee3f0f","modified":1558682601439},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l4.gif","hash":"8a9c3cf99766d3f07a9c480cfdffdc3197b9a6b9","modified":1558682601440},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l5.gif","hash":"148706f56b8ef4fd9d8483d0ac3a6730e72fc0ad","modified":1558682601440},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_2_24.png","hash":"e47fb87c533f2be89f22901f0864d9b5ef83412d","modified":1558682601438},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l6.gif","hash":"f4b8e3188f744f13aca46b27b451d55d9e209c48","modified":1558682601440},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l7.gif","hash":"e4f7e5e56c8f4eb026b5cb0affe3bd69c31af261","modified":1558682601440},{"_id":"themes/hexo-theme-next/source/static/api/img/share/l8.gif","hash":"ec7dbc7703961356e05528d2844b983f225445e4","modified":1558682601441},{"_id":"themes/hexo-theme-next/source/static/api/img/share/pop_c.gif","hash":"e8b9ece6ddaa47ccb2c15f2396d1cd3020740603","modified":1558682601441},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r0.gif","hash":"882f255fbafc0136a3917c1dd40db88879c1b1c1","modified":1558682601441},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r1.gif","hash":"96064d132ee2477c0e444c2e18162f9d1dc9e9c2","modified":1558682601441},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r3.gif","hash":"ecdd21f1457be54afc96e2d005524eef93d7bf85","modified":1558682601442},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r4.gif","hash":"517435e69a2215a0f003e75a4861154ca963c30e","modified":1558682601442},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r5.gif","hash":"e61b32d1830390303927bdab21823959f8dc7023","modified":1558682601442},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r6.gif","hash":"4bc01e08ef0015fddf5b8c7257c094ec584ca3ee","modified":1558682601442},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r7.gif","hash":"3c596c924910c93cf3e37cc1b2870dbf271151e2","modified":1558682601443},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r8.gif","hash":"c068ece54a72a3f2428d4f1b5ca7c176f027dd4e","modified":1558682601443},{"_id":"themes/hexo-theme-next/source/static/api/img/share/sc.png","hash":"e5a2ca56973a3d6608e7e3a48ebd9fa5ebda9991","modified":1558682601443},{"_id":"themes/hexo-theme-next/source/static/api/img/share/selectshare_close.png","hash":"6f3666278268890a153c85fb9f04ac848c442561","modified":1558682601444},{"_id":"themes/hexo-theme-next/source/static/api/img/share/share-search-icon.png","hash":"0629677a7eb5aa3e8bab3faa310c6d8c467a3287","modified":1558682601444},{"_id":"themes/hexo-theme-next/source/static/api/js/base/class.js","hash":"db02960fb51f69a0d50dc9ed626a998be3884706","modified":1558682601445},{"_id":"themes/hexo-theme-next/source/static/api/img/share/r2.gif","hash":"67c84a67be3b039892e9cb8c7c29ed29813bf60f","modified":1558682601441},{"_id":"themes/hexo-theme-next/source/static/api/js/component/anticheat.js","hash":"ee6b11a7ed39ae67c1c2aeeef96b4a0f40f8083c","modified":1558682601447},{"_id":"themes/hexo-theme-next/source/static/api/js/component/animate.js","hash":"17a3495543db66e4eb56a81a93edf3e41ca8cc31","modified":1558682601446},{"_id":"themes/hexo-theme-next/source/static/api/js/component/comm_tools.js","hash":"28d096a61f54e64bdbc32d172ae20e7f6e9656a7","modified":1558682601447},{"_id":"themes/hexo-theme-next/source/static/api/js/component/pop_base.js","hash":"eae6e120c149a21caa2883c533ccc40bc07fda51","modified":1558682601448},{"_id":"themes/hexo-theme-next/source/static/api/js/component/pop_dialog.js","hash":"4417d2fa9ad8ff6c79a2352ef07e9d10a1313ee0","modified":1558682601449},{"_id":"themes/hexo-theme-next/source/static/api/js/component/pop_popup.js","hash":"aface5a8c3f71e9e024bf0df5b361ed8f5452f50","modified":1558682601449},{"_id":"themes/hexo-theme-next/source/static/api/js/component/pop_popup_slide.js","hash":"45a72013fba95249ca965fd4d98f3bbde7a7098a","modified":1558682601449},{"_id":"themes/hexo-theme-next/source/static/api/js/component/qrcode.js","hash":"2e3cc4cc5545556dd97ab899ff32d3ab7ccee808","modified":1558682601450},{"_id":"themes/hexo-theme-next/source/static/api/js/conf/const.js","hash":"7da7df37d0f3d3e1977a8d107c98a3c1ecdb39c2","modified":1558682601450},{"_id":"themes/hexo-theme-next/source/static/api/js/conf/define.js","hash":"ee0afad836be1553980501855752ccd79fe1fe0e","modified":1558682601451},{"_id":"themes/hexo-theme-next/source/static/api/js/share/api_base.js","hash":"cbacd664451f80955c2ff4caccd4b9110062c714","modified":1558682601452},{"_id":"themes/hexo-theme-next/source/static/api/js/share/combine_api.js","hash":"7ad3c5396bf20704e87f98ebe118034ed3cc7b22","modified":1558682601452},{"_id":"themes/hexo-theme-next/source/static/api/js/share/image_api.js","hash":"43a93415f2a5dd34760042c2bcd9f4692feecb5d","modified":1558682601452},{"_id":"themes/hexo-theme-next/source/static/api/js/share/like_api.js","hash":"4034b10f8f34367c6db47ae092e5b4107c2fb8b4","modified":1558682601452},{"_id":"themes/hexo-theme-next/source/static/api/js/share/likeshare.js","hash":"2d14ab97cc3dc294c51c0d6814f4ea45f4b4e312","modified":1558682601453},{"_id":"themes/hexo-theme-next/source/static/api/js/share/select_api.js","hash":"bf259a7912ee6124d741dbb5e45cab40bfa45e90","modified":1558682601453},{"_id":"themes/hexo-theme-next/source/static/api/js/share/share_api.js","hash":"f7b86d0cc063f692a73a174d04e77cbe3c5facc7","modified":1558682601454},{"_id":"themes/hexo-theme-next/source/static/api/js/share/slide_api.js","hash":"c317e3f7fec13d89178e475f26a689bb94e5aa76","modified":1558682601454},{"_id":"themes/hexo-theme-next/source/static/api/js/component/partners.js","hash":"a4c275ffb4d3557280211e6bf0573485b397ffd8","modified":1558682601448},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_2_32.png","hash":"deba62865245a6b5aafa446787d72165c703b943","modified":1558682601438},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/trans_bdxc.js","hash":"a512ebfca0319ab38d06b7b0fb74bcdc942dc46e","modified":1558682601456},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/trans_bdysc.js","hash":"28bb985a03b6b1da5a89a143331932a12126c9c3","modified":1558682601456},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/trans_weixin.js","hash":"e68e9bc91ee6fbcd64ac788463870f01602a8562","modified":1558682601457},{"_id":"themes/hexo-theme-next/source/static/api/js/view/image_view.js","hash":"bb66297a5bd2c7dd931b9145f5d4a616876f3373","modified":1558682601457},{"_id":"themes/hexo-theme-next/source/static/api/js/view/like_view.js","hash":"c1b6a3f3f89ac734c6da284c1ba1dde2ada4e250","modified":1558682601457},{"_id":"themes/hexo-theme-next/source/static/api/js/view/select_view.js","hash":"2611efec1d31d85609feea0c57e14d3f817a6220","modified":1558682601458},{"_id":"themes/hexo-theme-next/source/static/api/js/view/share_view.js","hash":"f445ce9cbbcf887da5e248b1cfadc03ab7df76d0","modified":1558682601458},{"_id":"themes/hexo-theme-next/source/static/api/img/share/icons_2_16.png","hash":"07340442cb61aabb419dd226f4bfb206a7577f52","modified":1558682601437},{"_id":"themes/hexo-theme-next/source/static/api/js/view/view_base.js","hash":"b3fd7dafde05d63af3dfe9e0a59f9367f81402c5","modified":1558682601459},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1558682601418},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1558682601423},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1558682601426},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"b36eea093bd4b32056b5de6f370ff57e50b25a49","modified":1558682601371},{"_id":"themes/hexo-theme-next/source/static/api/js/base/tangram.js","hash":"f3ecbed4c05dba6a28df137e9a4e66c9ccfbd220","modified":1558682601446},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1558682601421},{"_id":"themes/hexo-theme-next/source/static/api/js/trans/trans.js","hash":"cb82afecdbede8d5a00b6c5ea9595187b6408376","modified":1558682601456},{"_id":"themes/hexo-theme-next/source/static/api/js/start/router.js","hash":"27bc546a9c796b15e59442aaf09ae645a2ed4c74","modified":1558682601455},{"_id":"themes/hexo-theme-next/source/static/api/js/view/slide_view.js","hash":"973ded5cd15eb119e79ffd9326af3a44167b26bd","modified":1558682601459},{"_id":"themes/hexo-theme-next/source/images/avatar.jpg","hash":"17e067ec0dafc30e00c810a274653a7fced4853b","modified":1558682601405},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/port_done.gif","hash":"f5d7c4812811e82d575e04823043426f682eb896","modified":1571807456928},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/create_template_mdk.gif","hash":"16aadb4a340e59214630af5d021d9215e1aa6f06","modified":1571807456874},{"_id":"source/_posts/rtt-nimble揭秘系列——移植nimble（3）/ble_hr.gif","hash":"098e0f7d0f5308a2eed18c3cab0ae3645d834f10","modified":1571807456977},{"_id":"public/search.xml","hash":"481e892a8b19fbd7ed9bfcf7ea7b34ba4d49d61e","modified":1571808578044},{"_id":"public/leancloud_counter_security_urls.json","hash":"0bfabc140ef70efaa3ba0d0aa61c9fb9771fac6f","modified":1571808578044},{"_id":"public/categories/index.html","hash":"6e9b892a127888a4763674982a6a21176454902d","modified":1571808578076},{"_id":"public/tags/index.html","hash":"0fb6d28b867056b2b5662f17f061db5cf6535a70","modified":1571808578076},{"_id":"public/2019/10/23/ADC相关性能参数概念/index.html","hash":"5f79bd08a5f898714f38be1335e9eaae1a85edcf","modified":1571808578076},{"_id":"public/2019/10/09/浅谈BLE核心架构和数据帧/index.html","hash":"07d3c78f388a1d54c0f30df1d92729754671b4af","modified":1571808578076},{"_id":"public/2019/10/09/rtt-nimble揭秘系列——移植nimble（3）/index.html","hash":"12c0f1aa8346291eccc9e29a7220204cdf75b172","modified":1571808578076},{"_id":"public/2019/10/09/rtt-nimble揭秘系列——移植bsp（2）/index.html","hash":"834fdad4a6e732df58f2b0876b90c3b73ea34f17","modified":1571808578076},{"_id":"public/2019/09/25/rtt-nimble揭秘系列——预备知识（1）/index.html","hash":"910553ea80270797acad6773f4b506993db4905d","modified":1571808578077},{"_id":"public/2019/09/25/rtt-nimble揭秘系列——题外话（0）/index.html","hash":"3b46f4249d7a901bca28d920d0c70565e2609551","modified":1571808578077},{"_id":"public/2019/08/17/coder-handbook/index.html","hash":"c6dd0a4483d8582ca21632b4c68ae15128cb37b9","modified":1571808578077},{"_id":"public/2019/05/24/cm-backtrace学习笔记/index.html","hash":"299273c530c0ed3f43b9b00d7dd0edc95ed8a3cb","modified":1571808578077},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/index.html","hash":"78dd0c45f36aa28ce5cdd66900e77f1dc989fff7","modified":1571808578077},{"_id":"public/2019/05/10/博客搭建实战/index.html","hash":"ece5a6eb0d68d047bdb37f43452eef5fe48ff134","modified":1571808578077},{"_id":"public/archives/index.html","hash":"43536b7a84bc29042a39c2b9edeb47e3ff9c4357","modified":1571808578077},{"_id":"public/archives/2019/index.html","hash":"e30969d48abaa6c5b01e44cd935fba42ad2336f4","modified":1571808578077},{"_id":"public/archives/2019/05/index.html","hash":"7f6ea1d5d469d6f8014f15422eb194c8a9982db4","modified":1571808578077},{"_id":"public/archives/2019/08/index.html","hash":"de69bb3b4ebfb159f1d3059e40923396d44a7214","modified":1571808578077},{"_id":"public/archives/2019/09/index.html","hash":"f32ff304cffa8ae0794ba55e6021c0522906d1a4","modified":1571808578077},{"_id":"public/archives/2019/10/index.html","hash":"1bf7481b0038dea4c251ae9ec19e5707288359ce","modified":1571808578077},{"_id":"public/categories/术业专攻/index.html","hash":"45fc239d7e4f0ed7b5ae6f14f44587d5938fd132","modified":1571808578078},{"_id":"public/categories/一得之见/index.html","hash":"a05bf13d6037be819ea7b742aa1560f8786d4da0","modified":1571808578078},{"_id":"public/categories/工具/index.html","hash":"0b385580966591f0119d76a62fc39dfd671927a7","modified":1571808578078},{"_id":"public/categories/软件工程/index.html","hash":"9fc3fff34effd1c556db1972e63d05495793b293","modified":1571808578079},{"_id":"public/index.html","hash":"ff4e615b264ca66778c29dae10e493bdba4de9d0","modified":1571808578079},{"_id":"public/tags/ADC/index.html","hash":"b20a1f23fa2ba8c05a699f1d506f3f3e9df96f5c","modified":1571808578079},{"_id":"public/tags/hardfault/index.html","hash":"0e23078654bea65149e22d1973e314bd60f94335","modified":1571808578079},{"_id":"public/tags/cortex/index.html","hash":"aa780e0a2f5e4d3a81ebc988aa4c4ef09ffec909","modified":1571808578079},{"_id":"public/tags/debug/index.html","hash":"3ba8bf7954858770cd2f5d0a859ea8e104a264e5","modified":1571808578080},{"_id":"public/tags/栈帧回溯/index.html","hash":"c70ab75ba64cf6469fc5de077c862115333dd198","modified":1571808578080},{"_id":"public/tags/rtthread/index.html","hash":"58d4140aeec85318840ec2bac2518929fd5b9f48","modified":1571808578080},{"_id":"public/tags/nimble/index.html","hash":"79ce9fd123a594f602dd00a7d161f76ea5fab4c4","modified":1571808578080},{"_id":"public/tags/ble/index.html","hash":"5d913e8c00879184d27bd3db10c57d5b1149d7c0","modified":1571808578080},{"_id":"public/tags/Hexo/index.html","hash":"6de149ac55d2cd81aea4c1ddfdcaee69b611ae3b","modified":1571808578080},{"_id":"public/tags/博客/index.html","hash":"6a98dac13b3f5751e3379d5b1d2ef15ed70ceff6","modified":1571808578080},{"_id":"public/tags/搭建/index.html","hash":"0dbe8879d171c11ac06eac6304ce83df3019684f","modified":1571808578080},{"_id":"public/tags/配置/index.html","hash":"92b322b61ca82fb26e0bd074ac4ef3f916b0a693","modified":1571808578080},{"_id":"public/tags/工具/index.html","hash":"319eea09fdcc2ba21193b48ad54737d109d226e9","modified":1571808578080},{"_id":"public/tags/BLE/index.html","hash":"66021440676f1ec376fc51062ee0f2411b5a75ed","modified":1571808578080},{"_id":"public/tags/安全机制/index.html","hash":"752dd62feea392b42d8489744ef1d4bdf52fc021","modified":1571808578080},{"_id":"public/tags/蓝牙/index.html","hash":"8abaf5ecb42bb2cf465ee84c632cf8808bff8137","modified":1571808578081},{"_id":"public/tags/代码/index.html","hash":"69c346f79393a475854c26be7fc6a77610b112a5","modified":1571808578081},{"_id":"public/tags/整洁/index.html","hash":"8312678382d1d50c29c1f480602a9503d1d3cde1","modified":1571808578081},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1571808578098},{"_id":"public/images/avatar_backup.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1571808578098},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1571808578098},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1571808578099},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1571808578099},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1571808578099},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1571808578099},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1571808578099},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1571808578099},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1571808578099},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1571808578099},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1571808578099},{"_id":"public/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1571808578099},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1571808578099},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1571808578099},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1571808578099},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1571808578099},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1571808578099},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1571808578099},{"_id":"public/static/api/img/share/icons_0_16.png","hash":"0eec1e81a04664b2032bd389513349e9bd5d5b0f","modified":1571808578099},{"_id":"public/static/api/img/share/icons_0_24.png","hash":"a89223f9714c8c4fa169430a327963ca6a1c9a6e","modified":1571808578099},{"_id":"public/static/api/img/share/icons_1_16.png","hash":"3793c3265429ab7b830bfaf18322259cd0b4c4ef","modified":1571808578100},{"_id":"public/static/api/img/share/icons_0_32.png","hash":"c20521634fdacef39631031671528713e6ba6081","modified":1571808578100},{"_id":"public/static/api/img/share/icons_1_24.png","hash":"9f1d472095dbe138ef7aff069b1d18cae6ffa942","modified":1571808578100},{"_id":"public/static/api/img/share/icons_1_32.png","hash":"09825de5f238c97e4374d545961d6e0d5bbfb3e2","modified":1571808578100},{"_id":"public/static/api/img/share/l0.gif","hash":"738b92632b0a9789a9eb568b8d101eb64f55f6e0","modified":1571808578100},{"_id":"public/static/api/img/share/l2.gif","hash":"e6a5d6104c226a686d48759e0268e09d762e242e","modified":1571808578100},{"_id":"public/static/api/img/share/l1.gif","hash":"70e1932ca7a622ed3322b683eceb7a590860a55e","modified":1571808578100},{"_id":"public/static/api/img/share/l3.gif","hash":"26c0dd37d98df63abb9d3d83e01bb47c34ee3f0f","modified":1571808578100},{"_id":"public/static/api/img/share/l4.gif","hash":"8a9c3cf99766d3f07a9c480cfdffdc3197b9a6b9","modified":1571808578100},{"_id":"public/static/api/img/share/l5.gif","hash":"148706f56b8ef4fd9d8483d0ac3a6730e72fc0ad","modified":1571808578100},{"_id":"public/static/api/img/share/l6.gif","hash":"f4b8e3188f744f13aca46b27b451d55d9e209c48","modified":1571808578100},{"_id":"public/static/api/img/share/icons_2_24.png","hash":"e47fb87c533f2be89f22901f0864d9b5ef83412d","modified":1571808578101},{"_id":"public/static/api/img/share/l7.gif","hash":"e4f7e5e56c8f4eb026b5cb0affe3bd69c31af261","modified":1571808578101},{"_id":"public/static/api/img/share/pop_c.gif","hash":"e8b9ece6ddaa47ccb2c15f2396d1cd3020740603","modified":1571808578101},{"_id":"public/static/api/img/share/r0.gif","hash":"882f255fbafc0136a3917c1dd40db88879c1b1c1","modified":1571808578101},{"_id":"public/static/api/img/share/l8.gif","hash":"ec7dbc7703961356e05528d2844b983f225445e4","modified":1571808578101},{"_id":"public/static/api/img/share/r1.gif","hash":"96064d132ee2477c0e444c2e18162f9d1dc9e9c2","modified":1571808578101},{"_id":"public/static/api/img/share/r3.gif","hash":"ecdd21f1457be54afc96e2d005524eef93d7bf85","modified":1571808578101},{"_id":"public/static/api/img/share/r4.gif","hash":"517435e69a2215a0f003e75a4861154ca963c30e","modified":1571808578101},{"_id":"public/static/api/img/share/r5.gif","hash":"e61b32d1830390303927bdab21823959f8dc7023","modified":1571808578101},{"_id":"public/static/api/img/share/r6.gif","hash":"4bc01e08ef0015fddf5b8c7257c094ec584ca3ee","modified":1571808578101},{"_id":"public/static/api/img/share/r8.gif","hash":"c068ece54a72a3f2428d4f1b5ca7c176f027dd4e","modified":1571808578102},{"_id":"public/static/api/img/share/sc.png","hash":"e5a2ca56973a3d6608e7e3a48ebd9fa5ebda9991","modified":1571808578102},{"_id":"public/static/api/img/share/r7.gif","hash":"3c596c924910c93cf3e37cc1b2870dbf271151e2","modified":1571808578102},{"_id":"public/static/api/img/share/share-search-icon.png","hash":"0629677a7eb5aa3e8bab3faa310c6d8c467a3287","modified":1571808578102},{"_id":"public/static/api/img/share/selectshare_close.png","hash":"6f3666278268890a153c85fb9f04ac848c442561","modified":1571808578102},{"_id":"public/static/api/img/share/r2.gif","hash":"67c84a67be3b039892e9cb8c7c29ed29813bf60f","modified":1571808578102},{"_id":"public/static/api/img/share/icons_2_32.png","hash":"deba62865245a6b5aafa446787d72165c703b943","modified":1571808578102},{"_id":"public/static/api/img/share/icons_2_16.png","hash":"07340442cb61aabb419dd226f4bfb206a7577f52","modified":1571808578102},{"_id":"public/2019/10/23/ADC相关性能参数概念/量化误差.jpg","hash":"90e2fa48b90e2661a81dfc565b71ee2d1a8f89ba","modified":1571808578103},{"_id":"public/2019/10/09/浅谈BLE核心架构和数据帧/ble_core_architecture.png","hash":"c9a5cec085a4bd17d700f56010f11f98582fb5ca","modified":1571808578103},{"_id":"public/2019/10/09/浅谈BLE核心架构和数据帧/ble_communicate.svg","hash":"531eb3488afe1c91ccdc69095b2ea7291e41d062","modified":1571808578103},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/7^xmod13=8.png","hash":"dbfff87af84204fd53dfee761c3aed2f18b9c76b","modified":1571808578103},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/CCM.png","hash":"c2283e671c52118d3c371cef58ec98b14e63d0b3","modified":1571808578103},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/7^xmod13=y.png","hash":"da1c6da03d06b035d0abcd25b734ccd5f053e8a4","modified":1571808578103},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/DH.epgz","hash":"c96a3bf69dd22d7b9eb2fc0e2137f59484ef550b","modified":1571808578103},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/ECDH.epgz","hash":"f542b7d155dd935b88d34d24ae2c444046355600","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/ECDH.png","hash":"fc08f4a537b4811b5ccda562e78cf73a59250387","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/ImportantPerson.png","hash":"020d61af6dc195fe4d2423c6f3389ce6e772bee0","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/KindOfPhase.epgz","hash":"b2e52539f360093a3f2f3087f65128e9b94507e8","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/KindOfPhase.png","hash":"13b978c9fd394bfecb8f0aac4b3c8ba6c6caa8a4","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/MAC.png","hash":"47943a1da3fd9dfa69b73f401d4322193a07b035","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/MITM.epgz","hash":"95106d9a21316667f875daa25e25e54eceb0c0c4","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/SecurityTechnology.epgz","hash":"75b268b49d6996e56ff2ef4ebc5f635877050f17","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/SecurityTechnology.png","hash":"71ee835fa867b0f1ac3122ad2abb9125022345bb","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/CCM.epgz","hash":"69cb2f04fe49ee0120196950d43919f1c38a4e07","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/SmpAndEncryption.epgz","hash":"10cff84d5ef55d8fa716e9349b7177e68bd97234","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/SymmetricCryptography.epgz","hash":"b2b2eae710fa45612c518aa2e3b0096d2648f728","modified":1571808578104},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/SymmetricCryptography.png","hash":"d63bd461151b6219179d4ca383ae286ba7d40659","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/authentication.epgz","hash":"ea1448480ee1f5d0970e8cd67978342ee87cdd9e","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/camouflage.epgz","hash":"e92fd4a11801f1fa7a00e1ab7d93d222f8deec1a","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/authentication.png","hash":"71e0d4dd0e3be4b08e486be8225a7ca18ec4fce1","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/camouflage.png","hash":"3abe2376eb89a91fc2bab329c290500f67da5a81","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/g^xmodp=y.png","hash":"19f6daaa5b7f731848ca27c5002d013840780ded","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/tamper.epgz","hash":"80c9019b730fae4e6e2e19717c41c478dbfa0843","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/y=xg.png","hash":"06de3fd8179dcbaa0ca2ea9cba20f7043e167846","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/ImportantPerson.epgz","hash":"02b442bd7f481363ff5cc1df4226a63d66375adc","modified":1571808578105},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/DH.png","hash":"d6435da8c3d0b8053b2291f4cf4a79ef0e937359","modified":1571808578106},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/tamper.png","hash":"73dfccb2519f153b34bea3160462d48056582168","modified":1571808578106},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/BleImportantPerson.png","hash":"84b49ce09bbee06c626886b08a0472f794fe585f","modified":1571808578106},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1571808578106},{"_id":"public/images/B419BCF613F9497BB3B75D9E1D863EA0.png","hash":"3832f45e642417161423260d21a8a05959de548e","modified":1571808578891},{"_id":"public/images/wechatpay.jpg","hash":"f48b46fee8c09cc7c8fabd98f7e34de0a9b3f46a","modified":1571808578892},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1571808578893},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1571808578893},{"_id":"public/2019/10/09/浅谈BLE核心架构和数据帧/ble_core_traffic_bearers.png","hash":"53ed29a12e66bc9bcbeb53c23e10d174ff5ce048","modified":1571808578893},{"_id":"public/2019/10/09/rtt-nimble揭秘系列——移植bsp（2）/rtconfig_keil.png","hash":"242761f78c302f19b40bd67f586eb6f94554ef6a","modified":1571808578893},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/ECDHMITM.png","hash":"4064f1eeec1886a422fe4190aebc125f2f36c777","modified":1571808578894},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/MITM.png","hash":"32c080d403881e1ff8b8ac68f73f9aa977c12fcd","modified":1571808578894},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/SmpAndEncryption.png","hash":"ec56885d66837e822303bfe2dcd63fc92306c835","modified":1571808578894},{"_id":"public/2019/05/14/BLE安全机制从入门到放弃/ECDHMITM.epgz","hash":"792a94ae8630e2d74978366a0471aa2b1adab8d3","modified":1571808578894},{"_id":"public/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1571808578902},{"_id":"public/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1571808578902},{"_id":"public/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1571808578902},{"_id":"public/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1571808578902},{"_id":"public/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1571808578902},{"_id":"public/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1571808578902},{"_id":"public/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1571808578902},{"_id":"public/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1571808578902},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1571808578902},{"_id":"public/static/api/css/like.css","hash":"2024d58206df01b858c38f07957f928b44e14cb3","modified":1571808578902},{"_id":"public/static/api/css/select_share.css","hash":"d0259abdb410193cf761e42bffaa51e70327a0cd","modified":1571808578902},{"_id":"public/static/api/css/share_popup.css","hash":"338ba2b30ef8ce0c84cd36b37d7f8482996291dc","modified":1571808578902},{"_id":"public/static/api/css/share_style0_16.css","hash":"090e77e9e6e9b8ee0d73a233cbe46499de935bdd","modified":1571808578902},{"_id":"public/static/api/css/share_style0_32.css","hash":"7c2d12ea532c8a55c102b649bb23ef5bf53b3ed3","modified":1571808578902},{"_id":"public/static/api/css/share_style2.css","hash":"1ad451187cde8a74843fd398b924ca0ac911e9be","modified":1571808578902},{"_id":"public/static/api/css/share_style1_24.css","hash":"3ee5f745c863b4f68299fe5dc125f913ca619c07","modified":1571808578902},{"_id":"public/static/api/css/share_style2_16.css","hash":"572c8e856988e463eb865f38d33ba003cc20d083","modified":1571808578902},{"_id":"public/static/api/css/share_style2_24.css","hash":"917d963d3be111064cbb1d122963da91ee3724a0","modified":1571808578902},{"_id":"public/static/api/css/share_style2_32.css","hash":"3657bbc4b5bbc66ebca4906ee0a1cbf9f98be883","modified":1571808578902},{"_id":"public/static/api/css/share_style4.css","hash":"0a9e2ed712a5ef5c4699c038cd001a0d688a0fdf","modified":1571808578903},{"_id":"public/static/api/css/share_style1_16.css","hash":"aeb4e9fa96cfa0167481e1f4007079dc3f3c6c27","modified":1571808578903},{"_id":"public/static/api/css/weixin_popup.css","hash":"5e6c5084bfd16051de5776c2e136a5462b08a32c","modified":1571808578903},{"_id":"public/static/api/css/slide_share.css","hash":"3898feaf45559b039f885bee8f9e831f48adb20c","modified":1571808578903},{"_id":"public/static/api/js/trans/data.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1571808578903},{"_id":"public/static/api/js/trans/logger.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1571808578903},{"_id":"public/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1571808578903},{"_id":"public/static/api/css/share_style0_24.css","hash":"7d1f9f32b80f91001f4f951aa045180cde22d82e","modified":1571808578903},{"_id":"public/static/api/css/share_style1_32.css","hash":"626d67a4c0bb72a152e90d25dbf281c0c35a2140","modified":1571808578903},{"_id":"public/static/api/js/base/class.js","hash":"db02960fb51f69a0d50dc9ed626a998be3884706","modified":1571808578903},{"_id":"public/static/api/js/component/anticheat.js","hash":"ee6b11a7ed39ae67c1c2aeeef96b4a0f40f8083c","modified":1571808578903},{"_id":"public/static/api/js/component/animate.js","hash":"17a3495543db66e4eb56a81a93edf3e41ca8cc31","modified":1571808578903},{"_id":"public/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1571808578903},{"_id":"public/static/api/js/component/pop_base.js","hash":"eae6e120c149a21caa2883c533ccc40bc07fda51","modified":1571808578903},{"_id":"public/static/api/js/component/pop_dialog.js","hash":"4417d2fa9ad8ff6c79a2352ef07e9d10a1313ee0","modified":1571808578903},{"_id":"public/static/api/js/component/pop_popup.js","hash":"aface5a8c3f71e9e024bf0df5b361ed8f5452f50","modified":1571808578903},{"_id":"public/static/api/js/component/pop_popup_slide.js","hash":"45a72013fba95249ca965fd4d98f3bbde7a7098a","modified":1571808578903},{"_id":"public/static/api/js/conf/const.js","hash":"7da7df37d0f3d3e1977a8d107c98a3c1ecdb39c2","modified":1571808578903},{"_id":"public/static/api/js/conf/define.js","hash":"ee0afad836be1553980501855752ccd79fe1fe0e","modified":1571808578903},{"_id":"public/static/api/js/share/api_base.js","hash":"cbacd664451f80955c2ff4caccd4b9110062c714","modified":1571808578903},{"_id":"public/static/api/js/share/combine_api.js","hash":"7ad3c5396bf20704e87f98ebe118034ed3cc7b22","modified":1571808578903},{"_id":"public/static/api/js/share/image_api.js","hash":"43a93415f2a5dd34760042c2bcd9f4692feecb5d","modified":1571808578903},{"_id":"public/static/api/js/share/likeshare.js","hash":"2d14ab97cc3dc294c51c0d6814f4ea45f4b4e312","modified":1571808578903},{"_id":"public/static/api/js/share/like_api.js","hash":"4034b10f8f34367c6db47ae092e5b4107c2fb8b4","modified":1571808578903},{"_id":"public/static/api/js/share/select_api.js","hash":"bf259a7912ee6124d741dbb5e45cab40bfa45e90","modified":1571808578903},{"_id":"public/static/api/js/share/share_api.js","hash":"f7b86d0cc063f692a73a174d04e77cbe3c5facc7","modified":1571808578903},{"_id":"public/static/api/js/share/slide_api.js","hash":"c317e3f7fec13d89178e475f26a689bb94e5aa76","modified":1571808578904},{"_id":"public/static/api/js/component/partners.js","hash":"a4c275ffb4d3557280211e6bf0573485b397ffd8","modified":1571808578904},{"_id":"public/static/api/js/trans/trans_bdxc.js","hash":"a512ebfca0319ab38d06b7b0fb74bcdc942dc46e","modified":1571808578904},{"_id":"public/static/api/js/trans/trans_bdysc.js","hash":"28bb985a03b6b1da5a89a143331932a12126c9c3","modified":1571808578904},{"_id":"public/static/api/js/trans/trans_weixin.js","hash":"e68e9bc91ee6fbcd64ac788463870f01602a8562","modified":1571808578904},{"_id":"public/static/api/js/view/image_view.js","hash":"bb66297a5bd2c7dd931b9145f5d4a616876f3373","modified":1571808578904},{"_id":"public/static/api/js/view/like_view.js","hash":"c1b6a3f3f89ac734c6da284c1ba1dde2ada4e250","modified":1571808578904},{"_id":"public/static/api/js/view/select_view.js","hash":"2611efec1d31d85609feea0c57e14d3f817a6220","modified":1571808578904},{"_id":"public/static/api/js/component/comm_tools.js","hash":"28d096a61f54e64bdbc32d172ae20e7f6e9656a7","modified":1571808578904},{"_id":"public/static/api/js/view/view_base.js","hash":"b3fd7dafde05d63af3dfe9e0a59f9367f81402c5","modified":1571808578904},{"_id":"public/static/api/js/trans/trans.js","hash":"cb82afecdbede8d5a00b6c5ea9595187b6408376","modified":1571808578904},{"_id":"public/static/api/js/start/router.js","hash":"27bc546a9c796b15e59442aaf09ae645a2ed4c74","modified":1571808578904},{"_id":"public/static/api/js/view/slide_view.js","hash":"973ded5cd15eb119e79ffd9326af3a44167b26bd","modified":1571808578904},{"_id":"public/static/api/js/view/share_view.js","hash":"f445ce9cbbcf887da5e248b1cfadc03ab7df76d0","modified":1571808578904},{"_id":"public/css/main.css","hash":"1c96f2d9b1f2c40c76c76b619f9159660c2ffdd9","modified":1571808578904},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1571808578904},{"_id":"public/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1571808578910},{"_id":"public/js/utils.js","hash":"81913c5f75d0949443833cf4269ad63bd7f9be6f","modified":1571808578910},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1571808578911},{"_id":"public/static/api/css/imgshare.css","hash":"c3624a2dde649ed28b2e5d1f050fd971fbaf71a0","modified":1571808578911},{"_id":"public/static/api/js/component/qrcode.js","hash":"2e3cc4cc5545556dd97ab899ff32d3ab7ccee808","modified":1571808578911},{"_id":"public/2019/10/09/rtt-nimble揭秘系列——移植bsp（2）/cmsis_include.png","hash":"bc1745ac0e89634ec81b733b0d42458f9670e030","modified":1571808578911},{"_id":"public/2019/10/09/rtt-nimble揭秘系列——移植bsp（2）/nrfx_config.png","hash":"acff63e662587474e3b3bce3ab8f125e29d846ce","modified":1571808578911},{"_id":"public/static/api/js/share.js","hash":"73bdb33580128e6c79a726a25f98092c0faa369d","modified":1571808578912},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1571808578912},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1571808578920},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1571808578920},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1571808578920},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1571808578969},{"_id":"public/static/api/js/base/tangram.js","hash":"e1952e27f6dc3d6339128cec157acef8cc0a775f","modified":1571808579000},{"_id":"public/images/avatar.jpg","hash":"17e067ec0dafc30e00c810a274653a7fced4853b","modified":1571808579008},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1571808579011},{"_id":"public/2019/10/09/rtt-nimble揭秘系列——移植bsp（2）/port_done.gif","hash":"f5d7c4812811e82d575e04823043426f682eb896","modified":1571808579014},{"_id":"public/2019/10/09/rtt-nimble揭秘系列——移植bsp（2）/create_template_mdk.gif","hash":"16aadb4a340e59214630af5d021d9215e1aa6f06","modified":1571808579022},{"_id":"public/2019/10/09/rtt-nimble揭秘系列——移植nimble（3）/ble_hr.gif","hash":"098e0f7d0f5308a2eed18c3cab0ae3645d834f10","modified":1571808579024}],"Category":[{"name":"术业专攻","_id":"ck22u8q640004gcg82ifv6mvm"},{"name":"一得之见","_id":"ck22u8q6c000cgcg81o0cybtw"},{"name":"工具","_id":"ck22u8q7r0013gcg8466mehaj"},{"name":"软件工程","_id":"ck22u8qau001ogcg8oq9u6xfo"}],"Data":[],"Page":[{"title":"categories","date":"2019-05-10T05:44:06.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-05-10 13:44:06\ntype: \"categories\" \n---\n","updated":"2019-05-24T07:22:53.157Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck22u8q600001gcg878f80ryc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-05-10T05:49:39.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-05-10 13:49:39\ntype: \"tags\"\n---\n","updated":"2019-05-24T07:22:53.157Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck22u8q630003gcg8zdwwuden","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ADC相关性能参数概念","date":"2019-10-23T05:12:15.000Z","_content":"\n-\n<!-- more --> \n\n前言\n===\n\n补基础\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 量化误差](#1-量化误差)\n- [2. DNL](#2-dnl)\n- [3. INL](#3-inl)\n- [4. SNR](#4-snr)\n- [5. ENOB](#5-enob)\n- [6. THD](#6-thd)\n- [7. ADC的输入阻抗](#7-adc的输入阻抗)\n- [8. ADC的转换时间](#8-adc的转换时间)\n- [9. 参考资料](#9-参考资料)\n\n<!-- /TOC -->\n\n# 1. 量化误差\n\n用简单3bit ADC来说明。\n\n输入电压被数字化，以8个离散电平来划分，分别由代码000b到111b去代表它们，每一代码跨越Vref/8的电压范围。\n\n代码宽度一般被定义为一个最低有效位（Least Significant Bit，LSB）。\n\n> NOTE：code width(n) = v(n+1) - v(n)  \n这里v(n+1)表示输出代码由n跳变为n+1时对应的模拟输入电压，v(n)表示输出代码由n-1跳变为n的模拟输入电压。v(n+1) - v(n)表示输出代码n的代码宽度。\n\n若假定Vref＝8V时，每个代码之间的电压变换就代表1V。如图中橙色线所示，即当输入电压为0.5V或者1.5V时，ADC输出的结果都是1V（001b），这里的误差称为`量化误差`。\n\n![](量化误差.jpg)\n\n量化误差是±0.5LSB，但是ADC实际的LSB应该参考ENOB而不是分辨率位数。\n\n# 2. DNL\n\nDNL，即微分非线性，表征的是我们ADC的实际刻度与理想刻度之间的差值。\n\nDNL是ADC的`相邻代码之间的实际差值`与`相邻代码之间的理想差值`的误差。\n\n比如说我们手中普通的尺子，正常情况下一小格长度应该是标准的1mm。但是由于生产精度，材质，受力引发的形变等影响，尺子上上标注的1小格长度可能并不是标准的1mm，可能是0.98mm，也可能是1.02mm。\n\n比如说我们尺子上的某两个相邻的刻度线之间长度已经变成了0.98mm，那么我们就可以说“A刻度线到B刻度线的DNL是（0.98-1）/1=0.02 LSB”，这里的LSB就是指我们的一个最小刻度对应的长度是多少，对于一般的尺子就是1mm。\n\n![](DNL.jpg)\n\n将尺子转成ADC，即：\n\n从001b到010b过渡过程的DNL为0LSB，因为刚好为1LSB。\n\n从000b到001b过渡过程就有个0.2LSB的DNL，因为此时有1.2LSB的代码宽度。\n\n> NOTE：如果在datasheet中没有清楚说明DNL参数的话，可视该转换器没有漏码，即暗示它有优于±1LSB的DNL。\n\n# 3. INL\n\nINL，即积分非线性，表征的是大信号的线性误差，是指ADC给定输入所包含全部DNL的累计代数和。\n\nINL是ADC的所有代码点上对应的理想模拟量和真实模拟量之间误差最大的那一点的值。\n\n![](INL.jpg)\n\n如图，即本来100b对应的理想模拟量是Vref/2，但是真实模拟量介于3Vref/8~4Vref/8，则说这里存在INL误差。出现这种情况的原因。\n\n从整个输出代码来看，每个输入电压代码步距差异累积起来以后和理想值相比会产生一个总差异，这个差异就是非线性积分误差。\n\n> NOTE：  \nINL(n) = INL(n-1) + (DNL(n) + DNL(n-1)) / 2 \n即\nINL(n) = DNL(1) + DNL(2) + ....DNL(n) / 2\n\n# 4. SNR\n\n# 5. ENOB\n\n# 6. THD\n\n# 7. ADC的输入阻抗\n\n# 8. ADC的转换时间\n\n\n# 9. 参考资料\n- [谈谈ADC的相关性能参数(一)](https://blog.csdn.net/u011834881/article/details/80115283)\n- [ADC的INL和DNL](https://blog.csdn.net/tianhen791/article/details/38736217)\n- [对ADC（DAC）的线性度（INL和DNL）的一点理解](https://blog.csdn.net/wzk456/article/details/39055215)\n- [ADC参数解释和关键指标](https://wenku.baidu.com/view/456923f4eff9aef8951e0655.html)","source":"_posts/ADC相关性能参数概念.md","raw":"---\ntitle: ADC相关性能参数概念\ndate: 2019-10-23 13:12:15\ntags:\n- ADC\n\ncategories:\n- 术业专攻\n\n---\n\n-\n<!-- more --> \n\n前言\n===\n\n补基础\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 量化误差](#1-量化误差)\n- [2. DNL](#2-dnl)\n- [3. INL](#3-inl)\n- [4. SNR](#4-snr)\n- [5. ENOB](#5-enob)\n- [6. THD](#6-thd)\n- [7. ADC的输入阻抗](#7-adc的输入阻抗)\n- [8. ADC的转换时间](#8-adc的转换时间)\n- [9. 参考资料](#9-参考资料)\n\n<!-- /TOC -->\n\n# 1. 量化误差\n\n用简单3bit ADC来说明。\n\n输入电压被数字化，以8个离散电平来划分，分别由代码000b到111b去代表它们，每一代码跨越Vref/8的电压范围。\n\n代码宽度一般被定义为一个最低有效位（Least Significant Bit，LSB）。\n\n> NOTE：code width(n) = v(n+1) - v(n)  \n这里v(n+1)表示输出代码由n跳变为n+1时对应的模拟输入电压，v(n)表示输出代码由n-1跳变为n的模拟输入电压。v(n+1) - v(n)表示输出代码n的代码宽度。\n\n若假定Vref＝8V时，每个代码之间的电压变换就代表1V。如图中橙色线所示，即当输入电压为0.5V或者1.5V时，ADC输出的结果都是1V（001b），这里的误差称为`量化误差`。\n\n![](量化误差.jpg)\n\n量化误差是±0.5LSB，但是ADC实际的LSB应该参考ENOB而不是分辨率位数。\n\n# 2. DNL\n\nDNL，即微分非线性，表征的是我们ADC的实际刻度与理想刻度之间的差值。\n\nDNL是ADC的`相邻代码之间的实际差值`与`相邻代码之间的理想差值`的误差。\n\n比如说我们手中普通的尺子，正常情况下一小格长度应该是标准的1mm。但是由于生产精度，材质，受力引发的形变等影响，尺子上上标注的1小格长度可能并不是标准的1mm，可能是0.98mm，也可能是1.02mm。\n\n比如说我们尺子上的某两个相邻的刻度线之间长度已经变成了0.98mm，那么我们就可以说“A刻度线到B刻度线的DNL是（0.98-1）/1=0.02 LSB”，这里的LSB就是指我们的一个最小刻度对应的长度是多少，对于一般的尺子就是1mm。\n\n![](DNL.jpg)\n\n将尺子转成ADC，即：\n\n从001b到010b过渡过程的DNL为0LSB，因为刚好为1LSB。\n\n从000b到001b过渡过程就有个0.2LSB的DNL，因为此时有1.2LSB的代码宽度。\n\n> NOTE：如果在datasheet中没有清楚说明DNL参数的话，可视该转换器没有漏码，即暗示它有优于±1LSB的DNL。\n\n# 3. INL\n\nINL，即积分非线性，表征的是大信号的线性误差，是指ADC给定输入所包含全部DNL的累计代数和。\n\nINL是ADC的所有代码点上对应的理想模拟量和真实模拟量之间误差最大的那一点的值。\n\n![](INL.jpg)\n\n如图，即本来100b对应的理想模拟量是Vref/2，但是真实模拟量介于3Vref/8~4Vref/8，则说这里存在INL误差。出现这种情况的原因。\n\n从整个输出代码来看，每个输入电压代码步距差异累积起来以后和理想值相比会产生一个总差异，这个差异就是非线性积分误差。\n\n> NOTE：  \nINL(n) = INL(n-1) + (DNL(n) + DNL(n-1)) / 2 \n即\nINL(n) = DNL(1) + DNL(2) + ....DNL(n) / 2\n\n# 4. SNR\n\n# 5. ENOB\n\n# 6. THD\n\n# 7. ADC的输入阻抗\n\n# 8. ADC的转换时间\n\n\n# 9. 参考资料\n- [谈谈ADC的相关性能参数(一)](https://blog.csdn.net/u011834881/article/details/80115283)\n- [ADC的INL和DNL](https://blog.csdn.net/tianhen791/article/details/38736217)\n- [对ADC（DAC）的线性度（INL和DNL）的一点理解](https://blog.csdn.net/wzk456/article/details/39055215)\n- [ADC参数解释和关键指标](https://wenku.baidu.com/view/456923f4eff9aef8951e0655.html)","slug":"ADC相关性能参数概念","published":1,"updated":"2019-10-25T10:42:47.628Z","_id":"ck22u8q5u0000gcg8fuq0yyqk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>-<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>补基础</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-量化误差\">1. 量化误差</a></li>\n<li><a href=\"#2-dnl\">2. DNL</a></li>\n<li><a href=\"#3-inl\">3. INL</a></li>\n<li><a href=\"#4-snr\">4. SNR</a></li>\n<li><a href=\"#5-enob\">5. ENOB</a></li>\n<li><a href=\"#6-thd\">6. THD</a></li>\n<li><a href=\"#7-adc的输入阻抗\">7. ADC的输入阻抗</a></li>\n<li><a href=\"#8-adc的转换时间\">8. ADC的转换时间</a></li>\n<li><a href=\"#9-参考资料\">9. 参考资料</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-量化误差\"><a href=\"#1-量化误差\" class=\"headerlink\" title=\"1. 量化误差\"></a>1. 量化误差</h1><p>用简单3bit ADC来说明。</p>\n<p>输入电压被数字化，以8个离散电平来划分，分别由代码000b到111b去代表它们，每一代码跨越Vref/8的电压范围。</p>\n<p>代码宽度一般被定义为一个最低有效位（Least Significant Bit，LSB）。</p>\n<blockquote>\n<p>NOTE：code width(n) = v(n+1) - v(n)<br>这里v(n+1)表示输出代码由n跳变为n+1时对应的模拟输入电压，v(n)表示输出代码由n-1跳变为n的模拟输入电压。v(n+1) - v(n)表示输出代码n的代码宽度。</p>\n</blockquote>\n<p>若假定Vref＝8V时，每个代码之间的电压变换就代表1V。如图中橙色线所示，即当输入电压为0.5V或者1.5V时，ADC输出的结果都是1V（001b），这里的误差称为<code>量化误差</code>。</p>\n<p><img src=\"量化误差.jpg\" alt></p>\n<p>量化误差是±0.5LSB，但是ADC实际的LSB应该参考ENOB而不是分辨率位数。</p>\n<h1 id=\"2-DNL\"><a href=\"#2-DNL\" class=\"headerlink\" title=\"2. DNL\"></a>2. DNL</h1><p>DNL，即微分非线性，表征的是我们ADC的实际刻度与理想刻度之间的差值。</p>\n<p>DNL是ADC的<code>相邻代码之间的实际差值</code>与<code>相邻代码之间的理想差值</code>的误差。</p>\n<p>比如说我们手中普通的尺子，正常情况下一小格长度应该是标准的1mm。但是由于生产精度，材质，受力引发的形变等影响，尺子上上标注的1小格长度可能并不是标准的1mm，可能是0.98mm，也可能是1.02mm。</p>\n<p>比如说我们尺子上的某两个相邻的刻度线之间长度已经变成了0.98mm，那么我们就可以说“A刻度线到B刻度线的DNL是（0.98-1）/1=0.02 LSB”，这里的LSB就是指我们的一个最小刻度对应的长度是多少，对于一般的尺子就是1mm。</p>\n<p><img src=\"DNL.jpg\" alt></p>\n<p>将尺子转成ADC，即：</p>\n<p>从001b到010b过渡过程的DNL为0LSB，因为刚好为1LSB。</p>\n<p>从000b到001b过渡过程就有个0.2LSB的DNL，因为此时有1.2LSB的代码宽度。</p>\n<blockquote>\n<p>NOTE：如果在datasheet中没有清楚说明DNL参数的话，可视该转换器没有漏码，即暗示它有优于±1LSB的DNL。</p>\n</blockquote>\n<h1 id=\"3-INL\"><a href=\"#3-INL\" class=\"headerlink\" title=\"3. INL\"></a>3. INL</h1><p>INL，即积分非线性，表征的是大信号的线性误差，是指ADC给定输入所包含全部DNL的累计代数和。</p>\n<p>INL是ADC的所有代码点上对应的理想模拟量和真实模拟量之间误差最大的那一点的值。</p>\n<p><img src=\"INL.jpg\" alt></p>\n<p>如图，即本来100b对应的理想模拟量是Vref/2，但是真实模拟量介于3Vref/8~4Vref/8，则说这里存在INL误差。出现这种情况的原因。</p>\n<p>从整个输出代码来看，每个输入电压代码步距差异累积起来以后和理想值相比会产生一个总差异，这个差异就是非线性积分误差。</p>\n<blockquote>\n<p>NOTE：<br>INL(n) = INL(n-1) + (DNL(n) + DNL(n-1)) / 2<br>即<br>INL(n) = DNL(1) + DNL(2) + ….DNL(n) / 2</p>\n</blockquote>\n<h1 id=\"4-SNR\"><a href=\"#4-SNR\" class=\"headerlink\" title=\"4. SNR\"></a>4. SNR</h1><h1 id=\"5-ENOB\"><a href=\"#5-ENOB\" class=\"headerlink\" title=\"5. ENOB\"></a>5. ENOB</h1><h1 id=\"6-THD\"><a href=\"#6-THD\" class=\"headerlink\" title=\"6. THD\"></a>6. THD</h1><h1 id=\"7-ADC的输入阻抗\"><a href=\"#7-ADC的输入阻抗\" class=\"headerlink\" title=\"7. ADC的输入阻抗\"></a>7. ADC的输入阻抗</h1><h1 id=\"8-ADC的转换时间\"><a href=\"#8-ADC的转换时间\" class=\"headerlink\" title=\"8. ADC的转换时间\"></a>8. ADC的转换时间</h1><h1 id=\"9-参考资料\"><a href=\"#9-参考资料\" class=\"headerlink\" title=\"9. 参考资料\"></a>9. 参考资料</h1><ul>\n<li><a href=\"https://blog.csdn.net/u011834881/article/details/80115283\" target=\"_blank\" rel=\"noopener\">谈谈ADC的相关性能参数(一)</a></li>\n<li><a href=\"https://blog.csdn.net/tianhen791/article/details/38736217\" target=\"_blank\" rel=\"noopener\">ADC的INL和DNL</a></li>\n<li><a href=\"https://blog.csdn.net/wzk456/article/details/39055215\" target=\"_blank\" rel=\"noopener\">对ADC（DAC）的线性度（INL和DNL）的一点理解</a></li>\n<li><a href=\"https://wenku.baidu.com/view/456923f4eff9aef8951e0655.html\" target=\"_blank\" rel=\"noopener\">ADC参数解释和关键指标</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>-<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>补基础</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-量化误差\">1. 量化误差</a></li>\n<li><a href=\"#2-dnl\">2. DNL</a></li>\n<li><a href=\"#3-inl\">3. INL</a></li>\n<li><a href=\"#4-snr\">4. SNR</a></li>\n<li><a href=\"#5-enob\">5. ENOB</a></li>\n<li><a href=\"#6-thd\">6. THD</a></li>\n<li><a href=\"#7-adc的输入阻抗\">7. ADC的输入阻抗</a></li>\n<li><a href=\"#8-adc的转换时间\">8. ADC的转换时间</a></li>\n<li><a href=\"#9-参考资料\">9. 参考资料</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-量化误差\"><a href=\"#1-量化误差\" class=\"headerlink\" title=\"1. 量化误差\"></a>1. 量化误差</h1><p>用简单3bit ADC来说明。</p>\n<p>输入电压被数字化，以8个离散电平来划分，分别由代码000b到111b去代表它们，每一代码跨越Vref/8的电压范围。</p>\n<p>代码宽度一般被定义为一个最低有效位（Least Significant Bit，LSB）。</p>\n<blockquote>\n<p>NOTE：code width(n) = v(n+1) - v(n)<br>这里v(n+1)表示输出代码由n跳变为n+1时对应的模拟输入电压，v(n)表示输出代码由n-1跳变为n的模拟输入电压。v(n+1) - v(n)表示输出代码n的代码宽度。</p>\n</blockquote>\n<p>若假定Vref＝8V时，每个代码之间的电压变换就代表1V。如图中橙色线所示，即当输入电压为0.5V或者1.5V时，ADC输出的结果都是1V（001b），这里的误差称为<code>量化误差</code>。</p>\n<p><img src=\"量化误差.jpg\" alt></p>\n<p>量化误差是±0.5LSB，但是ADC实际的LSB应该参考ENOB而不是分辨率位数。</p>\n<h1 id=\"2-DNL\"><a href=\"#2-DNL\" class=\"headerlink\" title=\"2. DNL\"></a>2. DNL</h1><p>DNL，即微分非线性，表征的是我们ADC的实际刻度与理想刻度之间的差值。</p>\n<p>DNL是ADC的<code>相邻代码之间的实际差值</code>与<code>相邻代码之间的理想差值</code>的误差。</p>\n<p>比如说我们手中普通的尺子，正常情况下一小格长度应该是标准的1mm。但是由于生产精度，材质，受力引发的形变等影响，尺子上上标注的1小格长度可能并不是标准的1mm，可能是0.98mm，也可能是1.02mm。</p>\n<p>比如说我们尺子上的某两个相邻的刻度线之间长度已经变成了0.98mm，那么我们就可以说“A刻度线到B刻度线的DNL是（0.98-1）/1=0.02 LSB”，这里的LSB就是指我们的一个最小刻度对应的长度是多少，对于一般的尺子就是1mm。</p>\n<p><img src=\"DNL.jpg\" alt></p>\n<p>将尺子转成ADC，即：</p>\n<p>从001b到010b过渡过程的DNL为0LSB，因为刚好为1LSB。</p>\n<p>从000b到001b过渡过程就有个0.2LSB的DNL，因为此时有1.2LSB的代码宽度。</p>\n<blockquote>\n<p>NOTE：如果在datasheet中没有清楚说明DNL参数的话，可视该转换器没有漏码，即暗示它有优于±1LSB的DNL。</p>\n</blockquote>\n<h1 id=\"3-INL\"><a href=\"#3-INL\" class=\"headerlink\" title=\"3. INL\"></a>3. INL</h1><p>INL，即积分非线性，表征的是大信号的线性误差，是指ADC给定输入所包含全部DNL的累计代数和。</p>\n<p>INL是ADC的所有代码点上对应的理想模拟量和真实模拟量之间误差最大的那一点的值。</p>\n<p><img src=\"INL.jpg\" alt></p>\n<p>如图，即本来100b对应的理想模拟量是Vref/2，但是真实模拟量介于3Vref/8~4Vref/8，则说这里存在INL误差。出现这种情况的原因。</p>\n<p>从整个输出代码来看，每个输入电压代码步距差异累积起来以后和理想值相比会产生一个总差异，这个差异就是非线性积分误差。</p>\n<blockquote>\n<p>NOTE：<br>INL(n) = INL(n-1) + (DNL(n) + DNL(n-1)) / 2<br>即<br>INL(n) = DNL(1) + DNL(2) + ….DNL(n) / 2</p>\n</blockquote>\n<h1 id=\"4-SNR\"><a href=\"#4-SNR\" class=\"headerlink\" title=\"4. SNR\"></a>4. SNR</h1><h1 id=\"5-ENOB\"><a href=\"#5-ENOB\" class=\"headerlink\" title=\"5. ENOB\"></a>5. ENOB</h1><h1 id=\"6-THD\"><a href=\"#6-THD\" class=\"headerlink\" title=\"6. THD\"></a>6. THD</h1><h1 id=\"7-ADC的输入阻抗\"><a href=\"#7-ADC的输入阻抗\" class=\"headerlink\" title=\"7. ADC的输入阻抗\"></a>7. ADC的输入阻抗</h1><h1 id=\"8-ADC的转换时间\"><a href=\"#8-ADC的转换时间\" class=\"headerlink\" title=\"8. ADC的转换时间\"></a>8. ADC的转换时间</h1><h1 id=\"9-参考资料\"><a href=\"#9-参考资料\" class=\"headerlink\" title=\"9. 参考资料\"></a>9. 参考资料</h1><ul>\n<li><a href=\"https://blog.csdn.net/u011834881/article/details/80115283\" target=\"_blank\" rel=\"noopener\">谈谈ADC的相关性能参数(一)</a></li>\n<li><a href=\"https://blog.csdn.net/tianhen791/article/details/38736217\" target=\"_blank\" rel=\"noopener\">ADC的INL和DNL</a></li>\n<li><a href=\"https://blog.csdn.net/wzk456/article/details/39055215\" target=\"_blank\" rel=\"noopener\">对ADC（DAC）的线性度（INL和DNL）的一点理解</a></li>\n<li><a href=\"https://wenku.baidu.com/view/456923f4eff9aef8951e0655.html\" target=\"_blank\" rel=\"noopener\">ADC参数解释和关键指标</a></li>\n</ul>"},{"title":"cm_backtrace学习笔记","date":"2019-05-24T07:31:52.000Z","_content":"\n\n[龙神](https://github.com/armink/CmBacktrace)的debug组件学习笔记。\n<!-- more --> \n\n\n前言\n===\n最近了解cortexM的hardfault回溯，记得之前有前辈写过一个组件，趁这次机会拜读一下，并且记录下学习过程。\n\n# cmb_fault.s汇编文件\n\n组件支持IAR/KEIL/GNU，因为最近用到KEIL，所以就直接看KEIL的汇编文件了，下面摘取了一部分的代码。之前对这块没有好好的总结过，所以这次简单总结一下。\n\n        AREA |.text|, CODE, READONLY, ALIGN=2\n        THUMB\n        REQUIRE8\n        PRESERVE8\n\n    ; NOTE: If use this file's HardFault_Handler, please comments the HardFault_Handler code on other file.\n        IMPORT cm_backtrace_fault\n        EXPORT HardFault_Handler\n\n    HardFault_Handler    PROC\n        MOV     r0, lr                  ; get lr\n        MOV     r1, sp                  ; get stack pointer (current is MSP)\n        BL      cm_backtrace_fault\n\n    Fault_Loop\n        BL      Fault_Loop              ;while(1)\n        ENDP\n\n        END\n\n源码实现的功能：\n\n1. 当hardfault发生时，将lr和sp作为参数传递给cm_backtrace_fault；\n2. cm_backtrace_fault处理完之后，进入死循环。\n\n## QA：\n\n**Q：AREA |.text|, CODE, READONLY, ALIGN=2的意义？**\n\n- AREA：asm指令，参考DUI0379G_02_mdk_armasm_user_guide文档\n- |.text|：|.text| is used for code sections produced by\nthe C compiler, or for code sections otherwise associated with the C library.\n- CODE：Contains machine instructions. READONLY is the default\n- READONLY：Indicates that this section must not be written to. This is the default for Code areas.\n- ALIGN=2：By default, ELF sections are aligned on a four-byte boundary. expression can have\nany integer value from 0 to 31. The section is aligned on a 2expression-byte boundary. For\nexample, if expression is 10, the section is aligned on a 1KB boundary.\nThis is not the same as the way that the ALIGN directive is specified.\n\n> Q：为什么需要4字节对齐？我也不知道\n\n\n\n\n**Q：THUMB的意义？**\n\n参考《DUI0379G_02_mdk_armasm_user_guide》有还怎么一些话\n\n>The THUMB directive instructs the assembler to interpret subsequent instructions as Thumb instructions,using the UAL syntax. In files that contain code using different instruction sets, THUMB must precede Thumb code written in\nUAL syntax.\n\n《The Definitive Guide to theARM Cortex-M0》有这么一段话：\n\n>Be careful with legacy Thumb programs that use the CODE16 directive. When the CODE16\ndirective is used, the instructions are interpreted as traditional Thumb syntax. For example,\ndata processing op-codes without S suffixes are converted to instructions that update\nAPSR when the CODE16 directive is used. However, you can reuse assembly files with the\nCODE16 directive because it is still supported by existing ARM development tools. For\nnew assembly code, the THUMB directive is recommended, which indicates to the assembly\nthat the Unified Assembly Language (UAL) is used. With UAL syntax, data processing\ninstructions updating the APSR require the S suffix.\n\n\n**Q：REQUIRE8和PRESERVE8的意义？**\n\n《The Definitive Guide to theARM Cortex-M0》有这么一段话：\n\n>In ARM/Keil development tools, the assembler provides the REQUIRE8 directive to indicate if\nthe function requires double-word-stack alignment and the PRESERVE8 directive to indicate\nthat a function preserves the double-word alignment. This directive can help the assembler\nto analyze your code and generate warnings if a function that requires a double-word-aligned\nstack frame is called by another function that does not guarantee double-word-stack alignment.\nDepending on your application, these directives might not be required, especially for projects\nbuilt entirely with assembly code.\n\n# 栈帧回溯功能分析\n\n```c\n/**\n * backtrace function call stack\n *\n * @param buffer call stack buffer\n * @param size buffer size\n * @param sp stack pointer\n *\n * @return depth\n */\nsize_t cm_backtrace_call_stack(uint32_t *buffer, size_t size, uint32_t sp) {\n    \n    ...\n\n    /* copy called function address */\n    for (; sp < stack_start_addr + stack_size; sp += sizeof(size_t)) {\n        /* the *sp value may be LR, so need decrease a word to PC */\n        /* \n         *   假设用户调用了这么一段断言代码：\n         * \n         *  void usr_assert(uin8_t zoo)\n         *  {\n         *       uint32_t sp = cmb_get_msp();\n         *       cm_backtrace_assert(sp);\n         *       foo(zoo);\n         *   }\n         * \n         *   那么在进入cm_backtrace_assert的时候，会将foo的地址写进LR，然后将\n         *   LR进栈，所以SP指向LR，LR-4刚好就是cm_backtrace_assert的地址 \n         *   (因为BL跳转指令刚好占4个字节）。\n         *   然后从该地址开始轮询已经入栈的数据，看看被压栈里的地址哪个是在代码区\n         *   间内的，找到就将他们保存进buffer。\n         * \n         *   这里的回溯原理：找到调用栈中在代码区间内的地址\n         *   需要注意：code_start_addr和code_size是否定义正确，决定了是否能正\n         *   确找到调用的函数地址，这个和分散加载（链接脚本）有密切关系。\n         */\n        pc = *((uint32_t *) sp) - sizeof(size_t);\n        /* the Cortex-M using thumb instruction, so the pc must be an odd number */\n        if (pc % 2 == 0) {\n            continue;\n        }\n        if ((pc >= code_start_addr) && (pc <= code_start_addr + code_size) && (depth < CMB_CALL_STACK_MAX_DEPTH)\n                && (depth < size)) {\n            /* the second depth function may be already saved, so need ignore repeat */\n            if ((depth == 2) && regs_saved_lr_is_valid && (pc == buffer[1])) {\n                continue;\n            }\n            buffer[depth++] = pc;\n        }\n    }\n\n    return depth;\n}\n```\n\n\n\n\n\n\n# 参考资料\n- 《The Definitive Guide to theARM Cortex-M0》\n- 《DUI0379G_02_mdk_armasm_user_guide》\n- 《DUI0497A_cortex_m0_r0p0_generic_ug》\n- 《DDI0419C_arm_architecture_v6m_reference_manual》","source":"_posts/cm-backtrace学习笔记.md","raw":"---\ntitle: cm_backtrace学习笔记\ndate: 2019-05-24 15:31:52\n\ntags:\n- hardfault\n- cortex\n- debug\n- 栈帧回溯\n\ncategories:\n- 术业专攻\n\n---\n\n\n[龙神](https://github.com/armink/CmBacktrace)的debug组件学习笔记。\n<!-- more --> \n\n\n前言\n===\n最近了解cortexM的hardfault回溯，记得之前有前辈写过一个组件，趁这次机会拜读一下，并且记录下学习过程。\n\n# cmb_fault.s汇编文件\n\n组件支持IAR/KEIL/GNU，因为最近用到KEIL，所以就直接看KEIL的汇编文件了，下面摘取了一部分的代码。之前对这块没有好好的总结过，所以这次简单总结一下。\n\n        AREA |.text|, CODE, READONLY, ALIGN=2\n        THUMB\n        REQUIRE8\n        PRESERVE8\n\n    ; NOTE: If use this file's HardFault_Handler, please comments the HardFault_Handler code on other file.\n        IMPORT cm_backtrace_fault\n        EXPORT HardFault_Handler\n\n    HardFault_Handler    PROC\n        MOV     r0, lr                  ; get lr\n        MOV     r1, sp                  ; get stack pointer (current is MSP)\n        BL      cm_backtrace_fault\n\n    Fault_Loop\n        BL      Fault_Loop              ;while(1)\n        ENDP\n\n        END\n\n源码实现的功能：\n\n1. 当hardfault发生时，将lr和sp作为参数传递给cm_backtrace_fault；\n2. cm_backtrace_fault处理完之后，进入死循环。\n\n## QA：\n\n**Q：AREA |.text|, CODE, READONLY, ALIGN=2的意义？**\n\n- AREA：asm指令，参考DUI0379G_02_mdk_armasm_user_guide文档\n- |.text|：|.text| is used for code sections produced by\nthe C compiler, or for code sections otherwise associated with the C library.\n- CODE：Contains machine instructions. READONLY is the default\n- READONLY：Indicates that this section must not be written to. This is the default for Code areas.\n- ALIGN=2：By default, ELF sections are aligned on a four-byte boundary. expression can have\nany integer value from 0 to 31. The section is aligned on a 2expression-byte boundary. For\nexample, if expression is 10, the section is aligned on a 1KB boundary.\nThis is not the same as the way that the ALIGN directive is specified.\n\n> Q：为什么需要4字节对齐？我也不知道\n\n\n\n\n**Q：THUMB的意义？**\n\n参考《DUI0379G_02_mdk_armasm_user_guide》有还怎么一些话\n\n>The THUMB directive instructs the assembler to interpret subsequent instructions as Thumb instructions,using the UAL syntax. In files that contain code using different instruction sets, THUMB must precede Thumb code written in\nUAL syntax.\n\n《The Definitive Guide to theARM Cortex-M0》有这么一段话：\n\n>Be careful with legacy Thumb programs that use the CODE16 directive. When the CODE16\ndirective is used, the instructions are interpreted as traditional Thumb syntax. For example,\ndata processing op-codes without S suffixes are converted to instructions that update\nAPSR when the CODE16 directive is used. However, you can reuse assembly files with the\nCODE16 directive because it is still supported by existing ARM development tools. For\nnew assembly code, the THUMB directive is recommended, which indicates to the assembly\nthat the Unified Assembly Language (UAL) is used. With UAL syntax, data processing\ninstructions updating the APSR require the S suffix.\n\n\n**Q：REQUIRE8和PRESERVE8的意义？**\n\n《The Definitive Guide to theARM Cortex-M0》有这么一段话：\n\n>In ARM/Keil development tools, the assembler provides the REQUIRE8 directive to indicate if\nthe function requires double-word-stack alignment and the PRESERVE8 directive to indicate\nthat a function preserves the double-word alignment. This directive can help the assembler\nto analyze your code and generate warnings if a function that requires a double-word-aligned\nstack frame is called by another function that does not guarantee double-word-stack alignment.\nDepending on your application, these directives might not be required, especially for projects\nbuilt entirely with assembly code.\n\n# 栈帧回溯功能分析\n\n```c\n/**\n * backtrace function call stack\n *\n * @param buffer call stack buffer\n * @param size buffer size\n * @param sp stack pointer\n *\n * @return depth\n */\nsize_t cm_backtrace_call_stack(uint32_t *buffer, size_t size, uint32_t sp) {\n    \n    ...\n\n    /* copy called function address */\n    for (; sp < stack_start_addr + stack_size; sp += sizeof(size_t)) {\n        /* the *sp value may be LR, so need decrease a word to PC */\n        /* \n         *   假设用户调用了这么一段断言代码：\n         * \n         *  void usr_assert(uin8_t zoo)\n         *  {\n         *       uint32_t sp = cmb_get_msp();\n         *       cm_backtrace_assert(sp);\n         *       foo(zoo);\n         *   }\n         * \n         *   那么在进入cm_backtrace_assert的时候，会将foo的地址写进LR，然后将\n         *   LR进栈，所以SP指向LR，LR-4刚好就是cm_backtrace_assert的地址 \n         *   (因为BL跳转指令刚好占4个字节）。\n         *   然后从该地址开始轮询已经入栈的数据，看看被压栈里的地址哪个是在代码区\n         *   间内的，找到就将他们保存进buffer。\n         * \n         *   这里的回溯原理：找到调用栈中在代码区间内的地址\n         *   需要注意：code_start_addr和code_size是否定义正确，决定了是否能正\n         *   确找到调用的函数地址，这个和分散加载（链接脚本）有密切关系。\n         */\n        pc = *((uint32_t *) sp) - sizeof(size_t);\n        /* the Cortex-M using thumb instruction, so the pc must be an odd number */\n        if (pc % 2 == 0) {\n            continue;\n        }\n        if ((pc >= code_start_addr) && (pc <= code_start_addr + code_size) && (depth < CMB_CALL_STACK_MAX_DEPTH)\n                && (depth < size)) {\n            /* the second depth function may be already saved, so need ignore repeat */\n            if ((depth == 2) && regs_saved_lr_is_valid && (pc == buffer[1])) {\n                continue;\n            }\n            buffer[depth++] = pc;\n        }\n    }\n\n    return depth;\n}\n```\n\n\n\n\n\n\n# 参考资料\n- 《The Definitive Guide to theARM Cortex-M0》\n- 《DUI0379G_02_mdk_armasm_user_guide》\n- 《DUI0497A_cortex_m0_r0p0_generic_ug》\n- 《DDI0419C_arm_architecture_v6m_reference_manual》","slug":"cm-backtrace学习笔记","published":1,"updated":"2019-05-30T08:13:00.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8q620002gcg8s2nc8jne","content":"<p><a href=\"https://github.com/armink/CmBacktrace\" target=\"_blank\" rel=\"noopener\">龙神</a>的debug组件学习笔记。<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近了解cortexM的hardfault回溯，记得之前有前辈写过一个组件，趁这次机会拜读一下，并且记录下学习过程。</p>\n<h1 id=\"cmb-fault-s汇编文件\"><a href=\"#cmb-fault-s汇编文件\" class=\"headerlink\" title=\"cmb_fault.s汇编文件\"></a>cmb_fault.s汇编文件</h1><p>组件支持IAR/KEIL/GNU，因为最近用到KEIL，所以就直接看KEIL的汇编文件了，下面摘取了一部分的代码。之前对这块没有好好的总结过，所以这次简单总结一下。</p>\n<pre><code>    AREA |.text|, CODE, READONLY, ALIGN=2\n    THUMB\n    REQUIRE8\n    PRESERVE8\n\n; NOTE: If use this file&apos;s HardFault_Handler, please comments the HardFault_Handler code on other file.\n    IMPORT cm_backtrace_fault\n    EXPORT HardFault_Handler\n\nHardFault_Handler    PROC\n    MOV     r0, lr                  ; get lr\n    MOV     r1, sp                  ; get stack pointer (current is MSP)\n    BL      cm_backtrace_fault\n\nFault_Loop\n    BL      Fault_Loop              ;while(1)\n    ENDP\n\n    END\n</code></pre><p>源码实现的功能：</p>\n<ol>\n<li>当hardfault发生时，将lr和sp作为参数传递给cm_backtrace_fault；</li>\n<li>cm_backtrace_fault处理完之后，进入死循环。</li>\n</ol>\n<h2 id=\"QA：\"><a href=\"#QA：\" class=\"headerlink\" title=\"QA：\"></a>QA：</h2><p><strong>Q：AREA |.text|, CODE, READONLY, ALIGN=2的意义？</strong></p>\n<ul>\n<li>AREA：asm指令，参考DUI0379G_02_mdk_armasm_user_guide文档</li>\n<li>|.text|：|.text| is used for code sections produced by<br>the C compiler, or for code sections otherwise associated with the C library.</li>\n<li>CODE：Contains machine instructions. READONLY is the default</li>\n<li>READONLY：Indicates that this section must not be written to. This is the default for Code areas.</li>\n<li>ALIGN=2：By default, ELF sections are aligned on a four-byte boundary. expression can have<br>any integer value from 0 to 31. The section is aligned on a 2expression-byte boundary. For<br>example, if expression is 10, the section is aligned on a 1KB boundary.<br>This is not the same as the way that the ALIGN directive is specified.</li>\n</ul>\n<blockquote>\n<p>Q：为什么需要4字节对齐？我也不知道</p>\n</blockquote>\n<p><strong>Q：THUMB的意义？</strong></p>\n<p>参考《DUI0379G_02_mdk_armasm_user_guide》有还怎么一些话</p>\n<blockquote>\n<p>The THUMB directive instructs the assembler to interpret subsequent instructions as Thumb instructions,using the UAL syntax. In files that contain code using different instruction sets, THUMB must precede Thumb code written in<br>UAL syntax.</p>\n</blockquote>\n<p>《The Definitive Guide to theARM Cortex-M0》有这么一段话：</p>\n<blockquote>\n<p>Be careful with legacy Thumb programs that use the CODE16 directive. When the CODE16<br>directive is used, the instructions are interpreted as traditional Thumb syntax. For example,<br>data processing op-codes without S suffixes are converted to instructions that update<br>APSR when the CODE16 directive is used. However, you can reuse assembly files with the<br>CODE16 directive because it is still supported by existing ARM development tools. For<br>new assembly code, the THUMB directive is recommended, which indicates to the assembly<br>that the Unified Assembly Language (UAL) is used. With UAL syntax, data processing<br>instructions updating the APSR require the S suffix.</p>\n</blockquote>\n<p><strong>Q：REQUIRE8和PRESERVE8的意义？</strong></p>\n<p>《The Definitive Guide to theARM Cortex-M0》有这么一段话：</p>\n<blockquote>\n<p>In ARM/Keil development tools, the assembler provides the REQUIRE8 directive to indicate if<br>the function requires double-word-stack alignment and the PRESERVE8 directive to indicate<br>that a function preserves the double-word alignment. This directive can help the assembler<br>to analyze your code and generate warnings if a function that requires a double-word-aligned<br>stack frame is called by another function that does not guarantee double-word-stack alignment.<br>Depending on your application, these directives might not be required, especially for projects<br>built entirely with assembly code.</p>\n</blockquote>\n<h1 id=\"栈帧回溯功能分析\"><a href=\"#栈帧回溯功能分析\" class=\"headerlink\" title=\"栈帧回溯功能分析\"></a>栈帧回溯功能分析</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * backtrace function call stack</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param buffer call stack buffer</span></span><br><span class=\"line\"><span class=\"comment\"> * @param size buffer size</span></span><br><span class=\"line\"><span class=\"comment\"> * @param sp stack pointer</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @return depth</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> cm_backtrace_call_stack(<span class=\"keyword\">uint32_t</span> *buffer, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">uint32_t</span> sp) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* copy called function address */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; sp &lt; stack_start_addr + stack_size; sp += <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">size_t</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* the *sp value may be LR, so need decrease a word to PC */</span></span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         *   假设用户调用了这么一段断言代码：</span></span><br><span class=\"line\"><span class=\"comment\">         * </span></span><br><span class=\"line\"><span class=\"comment\">         *  void usr_assert(uin8_t zoo)</span></span><br><span class=\"line\"><span class=\"comment\">         *  &#123;</span></span><br><span class=\"line\"><span class=\"comment\">         *       uint32_t sp = cmb_get_msp();</span></span><br><span class=\"line\"><span class=\"comment\">         *       cm_backtrace_assert(sp);</span></span><br><span class=\"line\"><span class=\"comment\">         *       foo(zoo);</span></span><br><span class=\"line\"><span class=\"comment\">         *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">         * </span></span><br><span class=\"line\"><span class=\"comment\">         *   那么在进入cm_backtrace_assert的时候，会将foo的地址写进LR，然后将</span></span><br><span class=\"line\"><span class=\"comment\">         *   LR进栈，所以SP指向LR，LR-4刚好就是cm_backtrace_assert的地址 </span></span><br><span class=\"line\"><span class=\"comment\">         *   (因为BL跳转指令刚好占4个字节）。</span></span><br><span class=\"line\"><span class=\"comment\">         *   然后从该地址开始轮询已经入栈的数据，看看被压栈里的地址哪个是在代码区</span></span><br><span class=\"line\"><span class=\"comment\">         *   间内的，找到就将他们保存进buffer。</span></span><br><span class=\"line\"><span class=\"comment\">         * </span></span><br><span class=\"line\"><span class=\"comment\">         *   这里的回溯原理：找到调用栈中在代码区间内的地址</span></span><br><span class=\"line\"><span class=\"comment\">         *   需要注意：code_start_addr和code_size是否定义正确，决定了是否能正</span></span><br><span class=\"line\"><span class=\"comment\">         *   确找到调用的函数地址，这个和分散加载（链接脚本）有密切关系。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        pc = *((<span class=\"keyword\">uint32_t</span> *) sp) - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">size_t</span>);</span><br><span class=\"line\">        <span class=\"comment\">/* the Cortex-M using thumb instruction, so the pc must be an odd number */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pc % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pc &gt;= code_start_addr) &amp;&amp; (pc &lt;= code_start_addr + code_size) &amp;&amp; (depth &lt; CMB_CALL_STACK_MAX_DEPTH)</span><br><span class=\"line\">                &amp;&amp; (depth &lt; size)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* the second depth function may be already saved, so need ignore repeat */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((depth == <span class=\"number\">2</span>) &amp;&amp; regs_saved_lr_is_valid &amp;&amp; (pc == buffer[<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            buffer[depth++] = pc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>《The Definitive Guide to theARM Cortex-M0》</li>\n<li>《DUI0379G_02_mdk_armasm_user_guide》</li>\n<li>《DUI0497A_cortex_m0_r0p0_generic_ug》</li>\n<li>《DDI0419C_arm_architecture_v6m_reference_manual》</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/armink/CmBacktrace\" target=\"_blank\" rel=\"noopener\">龙神</a>的debug组件学习笔记。<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近了解cortexM的hardfault回溯，记得之前有前辈写过一个组件，趁这次机会拜读一下，并且记录下学习过程。</p>\n<h1 id=\"cmb-fault-s汇编文件\"><a href=\"#cmb-fault-s汇编文件\" class=\"headerlink\" title=\"cmb_fault.s汇编文件\"></a>cmb_fault.s汇编文件</h1><p>组件支持IAR/KEIL/GNU，因为最近用到KEIL，所以就直接看KEIL的汇编文件了，下面摘取了一部分的代码。之前对这块没有好好的总结过，所以这次简单总结一下。</p>\n<pre><code>    AREA |.text|, CODE, READONLY, ALIGN=2\n    THUMB\n    REQUIRE8\n    PRESERVE8\n\n; NOTE: If use this file&apos;s HardFault_Handler, please comments the HardFault_Handler code on other file.\n    IMPORT cm_backtrace_fault\n    EXPORT HardFault_Handler\n\nHardFault_Handler    PROC\n    MOV     r0, lr                  ; get lr\n    MOV     r1, sp                  ; get stack pointer (current is MSP)\n    BL      cm_backtrace_fault\n\nFault_Loop\n    BL      Fault_Loop              ;while(1)\n    ENDP\n\n    END\n</code></pre><p>源码实现的功能：</p>\n<ol>\n<li>当hardfault发生时，将lr和sp作为参数传递给cm_backtrace_fault；</li>\n<li>cm_backtrace_fault处理完之后，进入死循环。</li>\n</ol>\n<h2 id=\"QA：\"><a href=\"#QA：\" class=\"headerlink\" title=\"QA：\"></a>QA：</h2><p><strong>Q：AREA |.text|, CODE, READONLY, ALIGN=2的意义？</strong></p>\n<ul>\n<li>AREA：asm指令，参考DUI0379G_02_mdk_armasm_user_guide文档</li>\n<li>|.text|：|.text| is used for code sections produced by<br>the C compiler, or for code sections otherwise associated with the C library.</li>\n<li>CODE：Contains machine instructions. READONLY is the default</li>\n<li>READONLY：Indicates that this section must not be written to. This is the default for Code areas.</li>\n<li>ALIGN=2：By default, ELF sections are aligned on a four-byte boundary. expression can have<br>any integer value from 0 to 31. The section is aligned on a 2expression-byte boundary. For<br>example, if expression is 10, the section is aligned on a 1KB boundary.<br>This is not the same as the way that the ALIGN directive is specified.</li>\n</ul>\n<blockquote>\n<p>Q：为什么需要4字节对齐？我也不知道</p>\n</blockquote>\n<p><strong>Q：THUMB的意义？</strong></p>\n<p>参考《DUI0379G_02_mdk_armasm_user_guide》有还怎么一些话</p>\n<blockquote>\n<p>The THUMB directive instructs the assembler to interpret subsequent instructions as Thumb instructions,using the UAL syntax. In files that contain code using different instruction sets, THUMB must precede Thumb code written in<br>UAL syntax.</p>\n</blockquote>\n<p>《The Definitive Guide to theARM Cortex-M0》有这么一段话：</p>\n<blockquote>\n<p>Be careful with legacy Thumb programs that use the CODE16 directive. When the CODE16<br>directive is used, the instructions are interpreted as traditional Thumb syntax. For example,<br>data processing op-codes without S suffixes are converted to instructions that update<br>APSR when the CODE16 directive is used. However, you can reuse assembly files with the<br>CODE16 directive because it is still supported by existing ARM development tools. For<br>new assembly code, the THUMB directive is recommended, which indicates to the assembly<br>that the Unified Assembly Language (UAL) is used. With UAL syntax, data processing<br>instructions updating the APSR require the S suffix.</p>\n</blockquote>\n<p><strong>Q：REQUIRE8和PRESERVE8的意义？</strong></p>\n<p>《The Definitive Guide to theARM Cortex-M0》有这么一段话：</p>\n<blockquote>\n<p>In ARM/Keil development tools, the assembler provides the REQUIRE8 directive to indicate if<br>the function requires double-word-stack alignment and the PRESERVE8 directive to indicate<br>that a function preserves the double-word alignment. This directive can help the assembler<br>to analyze your code and generate warnings if a function that requires a double-word-aligned<br>stack frame is called by another function that does not guarantee double-word-stack alignment.<br>Depending on your application, these directives might not be required, especially for projects<br>built entirely with assembly code.</p>\n</blockquote>\n<h1 id=\"栈帧回溯功能分析\"><a href=\"#栈帧回溯功能分析\" class=\"headerlink\" title=\"栈帧回溯功能分析\"></a>栈帧回溯功能分析</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * backtrace function call stack</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param buffer call stack buffer</span></span><br><span class=\"line\"><span class=\"comment\"> * @param size buffer size</span></span><br><span class=\"line\"><span class=\"comment\"> * @param sp stack pointer</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @return depth</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> cm_backtrace_call_stack(<span class=\"keyword\">uint32_t</span> *buffer, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">uint32_t</span> sp) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* copy called function address */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; sp &lt; stack_start_addr + stack_size; sp += <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">size_t</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* the *sp value may be LR, so need decrease a word to PC */</span></span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         *   假设用户调用了这么一段断言代码：</span></span><br><span class=\"line\"><span class=\"comment\">         * </span></span><br><span class=\"line\"><span class=\"comment\">         *  void usr_assert(uin8_t zoo)</span></span><br><span class=\"line\"><span class=\"comment\">         *  &#123;</span></span><br><span class=\"line\"><span class=\"comment\">         *       uint32_t sp = cmb_get_msp();</span></span><br><span class=\"line\"><span class=\"comment\">         *       cm_backtrace_assert(sp);</span></span><br><span class=\"line\"><span class=\"comment\">         *       foo(zoo);</span></span><br><span class=\"line\"><span class=\"comment\">         *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">         * </span></span><br><span class=\"line\"><span class=\"comment\">         *   那么在进入cm_backtrace_assert的时候，会将foo的地址写进LR，然后将</span></span><br><span class=\"line\"><span class=\"comment\">         *   LR进栈，所以SP指向LR，LR-4刚好就是cm_backtrace_assert的地址 </span></span><br><span class=\"line\"><span class=\"comment\">         *   (因为BL跳转指令刚好占4个字节）。</span></span><br><span class=\"line\"><span class=\"comment\">         *   然后从该地址开始轮询已经入栈的数据，看看被压栈里的地址哪个是在代码区</span></span><br><span class=\"line\"><span class=\"comment\">         *   间内的，找到就将他们保存进buffer。</span></span><br><span class=\"line\"><span class=\"comment\">         * </span></span><br><span class=\"line\"><span class=\"comment\">         *   这里的回溯原理：找到调用栈中在代码区间内的地址</span></span><br><span class=\"line\"><span class=\"comment\">         *   需要注意：code_start_addr和code_size是否定义正确，决定了是否能正</span></span><br><span class=\"line\"><span class=\"comment\">         *   确找到调用的函数地址，这个和分散加载（链接脚本）有密切关系。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        pc = *((<span class=\"keyword\">uint32_t</span> *) sp) - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">size_t</span>);</span><br><span class=\"line\">        <span class=\"comment\">/* the Cortex-M using thumb instruction, so the pc must be an odd number */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pc % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pc &gt;= code_start_addr) &amp;&amp; (pc &lt;= code_start_addr + code_size) &amp;&amp; (depth &lt; CMB_CALL_STACK_MAX_DEPTH)</span><br><span class=\"line\">                &amp;&amp; (depth &lt; size)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* the second depth function may be already saved, so need ignore repeat */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((depth == <span class=\"number\">2</span>) &amp;&amp; regs_saved_lr_is_valid &amp;&amp; (pc == buffer[<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            buffer[depth++] = pc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>《The Definitive Guide to theARM Cortex-M0》</li>\n<li>《DUI0379G_02_mdk_armasm_user_guide》</li>\n<li>《DUI0497A_cortex_m0_r0p0_generic_ug》</li>\n<li>《DDI0419C_arm_architecture_v6m_reference_manual》</li>\n</ul>"},{"title":"rtt+nimble揭秘系列——预备知识（1）","date":"2019-09-24T17:12:17.000Z","_content":"\n\n磨刀不误砍柴工，前期多做点理论积累，后期才能少掉坑。\n<!-- more --> \n\n前言\n===\n\n[rt-thread简介](https://www.rt-thread.org/document/site/tutorial/quick-start/introduction/introduction/)\n\n[nimble简介](http://mynewt.apache.org/latest/network/docs/index.html#)\n\n目录\n===\n<!-- TOC -->\n\n- [1. 导读](#1-导读)\n- [2. 系统](#2-系统)\n- [3. 蓝牙](#3-蓝牙)\n- [4. 硬件](#4-硬件)\n- [5. 软件](#5-软件)\n\n<!-- /TOC -->\n\n# 1. 导读\n\n知识点根据需要认知的程度分为：`了解`、`理解`、`专业`，对于知识点不建议强行记忆，建议多看、多想和多做，所谓读书百遍其意自现。\n\n| **例子** | **程度**  | **备注** |\n| :-- | :--: | :-- |\n| 信号量 | 了解 | 两个函数之间的共享变量，像全局变量标志位 | \n|         | 理解 | 工作机制、API使用方法，无须深究源码 |\n|         | 专业 | 略 \n\n一般从网上搜一篇文章就可以达到`了解`的程度，`理解`则需要多看几篇。\n\n刚接触一个复杂的软件的时候，不建议深究源码，我个人的习惯是按照：\n\n1. 软件可以运行\n2. 理解裁剪\n3. 软件刚刚好可以运行\n4. 研究细节\n\n就是想说学习方法很重要，不要钻牛角尖。\n\n# 2. 系统\n\n关于rt-thread的入门资料，[rt-thread文档中心](https://www.rt-thread.org/document/site/)这部分做的很cool，其中“内核”、“Env工具”、“设备和驱动”、“代码贡献-软件包开发”章节，建议至少看一遍。\n\n- 知识点1（理解）：内核整个章节\n- 知识点2（了解）：env的安装（只是为了运行scons和menuconfig）\n- 知识点3（了解）：menuconfig的使用\n    - Kconfig（该文件决定rt_config.h包含哪些宏定义，rt_config.h会被nimble协议栈include）\n- 知识点4（了解）：scons的使用\n    - `scons --target=mdk5`（keil编译和仿真）\n    - SConscript（修改该脚本，配合`scons --target=mdk5`来理解协议栈）\n- 知识点5（理解）：设备和驱动\n    - 移植芯片驱动（尽量理解，后面移植章节介绍）\n- 知识点6（了解）：软件包\n    - Kconfig文件\n\n这里除了`知识点3`和`知识点5`，其他知识点rt-thread官网已提供足够资料学习。\n\n\n# 3. 蓝牙\n\n[**蓝牙核心规范下载地址**](https://www.bluetooth.com/specifications/bluetooth-core-specification/)\n\n蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。\n\n不同厂家根据自家芯片的特性，用代码去实现这份文档的内容，这些代码称为蓝牙协议栈。\n\n基于蓝牙协议栈二次开发的工作，称为蓝牙应用开发。\n\n学习蓝牙软件门槛不高，但是会有瓶颈：\n- 它不难理解，不像人工智能需要有数学底蕴；它只是稍微复杂一点，花时间都能看懂，所以说门槛不高。\n- 因为协议栈不开源，看不到底层实现，所以会遇到瓶颈。\n\nnimble低功耗蓝牙协议栈，层层划分清晰，便于我们理解复杂的实现，而全开源解决了学习蓝牙软件的瓶颈问题，是学习蓝牙规范的一个好工具。\n\n但要是商用就要斟酌一番，毕竟开源不收钱，出现bug只能自力更生。\n\n- 知识点1：（理解）学习蓝牙软件不难，商用nimble需谨慎。\n- 知识点2：（了解）蓝牙应用开发可通过博客/Q群/论坛等途径学习\n\n> 推荐红旭论坛：http://bbs.wireless-tech.cn\n\n# 4. 硬件\n\n只需要掌握一个硬件平台的知识点即可。\n\n- 硬件：红旭 | HX-DK夏开发板\n\n    - 知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO\n    - 知识点2（了解）：从官方资料了解串口TX和RX引脚编号、LED灯引脚编号以及外围电路  \n\n- 硬件：nordic | nrf52 dk开发板\n\n    - 知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO\n    - 知识点2（了解）：从开发板背面了解串口TX和RX引脚编号、LED灯引脚编号及外围电路\n\n# 5. 软件\n\n- [rt-thread源码下载地址（后面文章使用v4.0.0版本）](https://www.rt-thread.org/page/download.html)\n- [nimble源码下载地址（后面文章使用v1.2.0版本）](http://mynewt.apache.org/download/)\n- [mynewt源码下载地址](http://mynewt.apache.org/download/)\n- [nrf52_sdk包下载地址（后面文章使用nRF5_SDK_15.3.0_59ac345版本）](https://www.nordicsemi.com/Software-and-Tools/Software/nRF5-SDK)\n- [nrf的Device_Family_Pack下载地址（后面文章使用8.24.1版本）](http://www.keil.com/dd2/Pack/#/third-party-download-dialog)\n- [rt-thread官方移植nimble源码下载地址](https://github.com/Zero-Free/nrf52832-nimble)\n","source":"_posts/rtt-nimble揭秘系列——预备知识（1）.md","raw":"---\ntitle: rtt+nimble揭秘系列——预备知识（1）\ndate: 2019-09-25 01:12:17\ntags:\n- rtthread\n- nimble\n\ncategories:\n- 一得之见\n---\n\n\n磨刀不误砍柴工，前期多做点理论积累，后期才能少掉坑。\n<!-- more --> \n\n前言\n===\n\n[rt-thread简介](https://www.rt-thread.org/document/site/tutorial/quick-start/introduction/introduction/)\n\n[nimble简介](http://mynewt.apache.org/latest/network/docs/index.html#)\n\n目录\n===\n<!-- TOC -->\n\n- [1. 导读](#1-导读)\n- [2. 系统](#2-系统)\n- [3. 蓝牙](#3-蓝牙)\n- [4. 硬件](#4-硬件)\n- [5. 软件](#5-软件)\n\n<!-- /TOC -->\n\n# 1. 导读\n\n知识点根据需要认知的程度分为：`了解`、`理解`、`专业`，对于知识点不建议强行记忆，建议多看、多想和多做，所谓读书百遍其意自现。\n\n| **例子** | **程度**  | **备注** |\n| :-- | :--: | :-- |\n| 信号量 | 了解 | 两个函数之间的共享变量，像全局变量标志位 | \n|         | 理解 | 工作机制、API使用方法，无须深究源码 |\n|         | 专业 | 略 \n\n一般从网上搜一篇文章就可以达到`了解`的程度，`理解`则需要多看几篇。\n\n刚接触一个复杂的软件的时候，不建议深究源码，我个人的习惯是按照：\n\n1. 软件可以运行\n2. 理解裁剪\n3. 软件刚刚好可以运行\n4. 研究细节\n\n就是想说学习方法很重要，不要钻牛角尖。\n\n# 2. 系统\n\n关于rt-thread的入门资料，[rt-thread文档中心](https://www.rt-thread.org/document/site/)这部分做的很cool，其中“内核”、“Env工具”、“设备和驱动”、“代码贡献-软件包开发”章节，建议至少看一遍。\n\n- 知识点1（理解）：内核整个章节\n- 知识点2（了解）：env的安装（只是为了运行scons和menuconfig）\n- 知识点3（了解）：menuconfig的使用\n    - Kconfig（该文件决定rt_config.h包含哪些宏定义，rt_config.h会被nimble协议栈include）\n- 知识点4（了解）：scons的使用\n    - `scons --target=mdk5`（keil编译和仿真）\n    - SConscript（修改该脚本，配合`scons --target=mdk5`来理解协议栈）\n- 知识点5（理解）：设备和驱动\n    - 移植芯片驱动（尽量理解，后面移植章节介绍）\n- 知识点6（了解）：软件包\n    - Kconfig文件\n\n这里除了`知识点3`和`知识点5`，其他知识点rt-thread官网已提供足够资料学习。\n\n\n# 3. 蓝牙\n\n[**蓝牙核心规范下载地址**](https://www.bluetooth.com/specifications/bluetooth-core-specification/)\n\n蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。\n\n不同厂家根据自家芯片的特性，用代码去实现这份文档的内容，这些代码称为蓝牙协议栈。\n\n基于蓝牙协议栈二次开发的工作，称为蓝牙应用开发。\n\n学习蓝牙软件门槛不高，但是会有瓶颈：\n- 它不难理解，不像人工智能需要有数学底蕴；它只是稍微复杂一点，花时间都能看懂，所以说门槛不高。\n- 因为协议栈不开源，看不到底层实现，所以会遇到瓶颈。\n\nnimble低功耗蓝牙协议栈，层层划分清晰，便于我们理解复杂的实现，而全开源解决了学习蓝牙软件的瓶颈问题，是学习蓝牙规范的一个好工具。\n\n但要是商用就要斟酌一番，毕竟开源不收钱，出现bug只能自力更生。\n\n- 知识点1：（理解）学习蓝牙软件不难，商用nimble需谨慎。\n- 知识点2：（了解）蓝牙应用开发可通过博客/Q群/论坛等途径学习\n\n> 推荐红旭论坛：http://bbs.wireless-tech.cn\n\n# 4. 硬件\n\n只需要掌握一个硬件平台的知识点即可。\n\n- 硬件：红旭 | HX-DK夏开发板\n\n    - 知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO\n    - 知识点2（了解）：从官方资料了解串口TX和RX引脚编号、LED灯引脚编号以及外围电路  \n\n- 硬件：nordic | nrf52 dk开发板\n\n    - 知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO\n    - 知识点2（了解）：从开发板背面了解串口TX和RX引脚编号、LED灯引脚编号及外围电路\n\n# 5. 软件\n\n- [rt-thread源码下载地址（后面文章使用v4.0.0版本）](https://www.rt-thread.org/page/download.html)\n- [nimble源码下载地址（后面文章使用v1.2.0版本）](http://mynewt.apache.org/download/)\n- [mynewt源码下载地址](http://mynewt.apache.org/download/)\n- [nrf52_sdk包下载地址（后面文章使用nRF5_SDK_15.3.0_59ac345版本）](https://www.nordicsemi.com/Software-and-Tools/Software/nRF5-SDK)\n- [nrf的Device_Family_Pack下载地址（后面文章使用8.24.1版本）](http://www.keil.com/dd2/Pack/#/third-party-download-dialog)\n- [rt-thread官方移植nimble源码下载地址](https://github.com/Zero-Free/nrf52832-nimble)\n","slug":"rtt-nimble揭秘系列——预备知识（1）","published":1,"updated":"2019-10-23T05:10:56.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8q660006gcg8ceycd20z","content":"<p>磨刀不误砍柴工，前期多做点理论积累，后期才能少掉坑。<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><a href=\"https://www.rt-thread.org/document/site/tutorial/quick-start/introduction/introduction/\" target=\"_blank\" rel=\"noopener\">rt-thread简介</a></p>\n<p><a href=\"http://mynewt.apache.org/latest/network/docs/index.html#\" target=\"_blank\" rel=\"noopener\">nimble简介</a></p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-导读\">1. 导读</a></li>\n<li><a href=\"#2-系统\">2. 系统</a></li>\n<li><a href=\"#3-蓝牙\">3. 蓝牙</a></li>\n<li><a href=\"#4-硬件\">4. 硬件</a></li>\n<li><a href=\"#5-软件\">5. 软件</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-导读\"><a href=\"#1-导读\" class=\"headerlink\" title=\"1. 导读\"></a>1. 导读</h1><p>知识点根据需要认知的程度分为：<code>了解</code>、<code>理解</code>、<code>专业</code>，对于知识点不建议强行记忆，建议多看、多想和多做，所谓读书百遍其意自现。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>例子</strong></th>\n<th style=\"text-align:center\"><strong>程度</strong></th>\n<th style=\"text-align:left\"><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">信号量</td>\n<td style=\"text-align:center\">了解</td>\n<td style=\"text-align:left\">两个函数之间的共享变量，像全局变量标志位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">理解</td>\n<td style=\"text-align:left\">工作机制、API使用方法，无须深究源码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">专业</td>\n<td style=\"text-align:left\">略 </td>\n</tr>\n</tbody>\n</table>\n<p>一般从网上搜一篇文章就可以达到<code>了解</code>的程度，<code>理解</code>则需要多看几篇。</p>\n<p>刚接触一个复杂的软件的时候，不建议深究源码，我个人的习惯是按照：</p>\n<ol>\n<li>软件可以运行</li>\n<li>理解裁剪</li>\n<li>软件刚刚好可以运行</li>\n<li>研究细节</li>\n</ol>\n<p>就是想说学习方法很重要，不要钻牛角尖。</p>\n<h1 id=\"2-系统\"><a href=\"#2-系统\" class=\"headerlink\" title=\"2. 系统\"></a>2. 系统</h1><p>关于rt-thread的入门资料，<a href=\"https://www.rt-thread.org/document/site/\" target=\"_blank\" rel=\"noopener\">rt-thread文档中心</a>这部分做的很cool，其中“内核”、“Env工具”、“设备和驱动”、“代码贡献-软件包开发”章节，建议至少看一遍。</p>\n<ul>\n<li>知识点1（理解）：内核整个章节</li>\n<li>知识点2（了解）：env的安装（只是为了运行scons和menuconfig）</li>\n<li>知识点3（了解）：menuconfig的使用<ul>\n<li>Kconfig（该文件决定rt_config.h包含哪些宏定义，rt_config.h会被nimble协议栈include）</li>\n</ul>\n</li>\n<li>知识点4（了解）：scons的使用<ul>\n<li><code>scons --target=mdk5</code>（keil编译和仿真）</li>\n<li>SConscript（修改该脚本，配合<code>scons --target=mdk5</code>来理解协议栈）</li>\n</ul>\n</li>\n<li>知识点5（理解）：设备和驱动<ul>\n<li>移植芯片驱动（尽量理解，后面移植章节介绍）</li>\n</ul>\n</li>\n<li>知识点6（了解）：软件包<ul>\n<li>Kconfig文件</li>\n</ul>\n</li>\n</ul>\n<p>这里除了<code>知识点3</code>和<code>知识点5</code>，其他知识点rt-thread官网已提供足够资料学习。</p>\n<h1 id=\"3-蓝牙\"><a href=\"#3-蓝牙\" class=\"headerlink\" title=\"3. 蓝牙\"></a>3. 蓝牙</h1><p><a href=\"https://www.bluetooth.com/specifications/bluetooth-core-specification/\" target=\"_blank\" rel=\"noopener\"><strong>蓝牙核心规范下载地址</strong></a></p>\n<p>蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。</p>\n<p>不同厂家根据自家芯片的特性，用代码去实现这份文档的内容，这些代码称为蓝牙协议栈。</p>\n<p>基于蓝牙协议栈二次开发的工作，称为蓝牙应用开发。</p>\n<p>学习蓝牙软件门槛不高，但是会有瓶颈：</p>\n<ul>\n<li>它不难理解，不像人工智能需要有数学底蕴；它只是稍微复杂一点，花时间都能看懂，所以说门槛不高。</li>\n<li>因为协议栈不开源，看不到底层实现，所以会遇到瓶颈。</li>\n</ul>\n<p>nimble低功耗蓝牙协议栈，层层划分清晰，便于我们理解复杂的实现，而全开源解决了学习蓝牙软件的瓶颈问题，是学习蓝牙规范的一个好工具。</p>\n<p>但要是商用就要斟酌一番，毕竟开源不收钱，出现bug只能自力更生。</p>\n<ul>\n<li>知识点1：（理解）学习蓝牙软件不难，商用nimble需谨慎。</li>\n<li>知识点2：（了解）蓝牙应用开发可通过博客/Q群/论坛等途径学习</li>\n</ul>\n<blockquote>\n<p>推荐红旭论坛：<a href=\"http://bbs.wireless-tech.cn\" target=\"_blank\" rel=\"noopener\">http://bbs.wireless-tech.cn</a></p>\n</blockquote>\n<h1 id=\"4-硬件\"><a href=\"#4-硬件\" class=\"headerlink\" title=\"4. 硬件\"></a>4. 硬件</h1><p>只需要掌握一个硬件平台的知识点即可。</p>\n<ul>\n<li><p>硬件：红旭 | HX-DK夏开发板</p>\n<ul>\n<li>知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO</li>\n<li>知识点2（了解）：从官方资料了解串口TX和RX引脚编号、LED灯引脚编号以及外围电路  </li>\n</ul>\n</li>\n<li><p>硬件：nordic | nrf52 dk开发板</p>\n<ul>\n<li>知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO</li>\n<li>知识点2（了解）：从开发板背面了解串口TX和RX引脚编号、LED灯引脚编号及外围电路</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"5-软件\"><a href=\"#5-软件\" class=\"headerlink\" title=\"5. 软件\"></a>5. 软件</h1><ul>\n<li><a href=\"https://www.rt-thread.org/page/download.html\" target=\"_blank\" rel=\"noopener\">rt-thread源码下载地址（后面文章使用v4.0.0版本）</a></li>\n<li><a href=\"http://mynewt.apache.org/download/\" target=\"_blank\" rel=\"noopener\">nimble源码下载地址（后面文章使用v1.2.0版本）</a></li>\n<li><a href=\"http://mynewt.apache.org/download/\" target=\"_blank\" rel=\"noopener\">mynewt源码下载地址</a></li>\n<li><a href=\"https://www.nordicsemi.com/Software-and-Tools/Software/nRF5-SDK\" target=\"_blank\" rel=\"noopener\">nrf52_sdk包下载地址（后面文章使用nRF5_SDK_15.3.0_59ac345版本）</a></li>\n<li><a href=\"http://www.keil.com/dd2/Pack/#/third-party-download-dialog\" target=\"_blank\" rel=\"noopener\">nrf的Device_Family_Pack下载地址（后面文章使用8.24.1版本）</a></li>\n<li><a href=\"https://github.com/Zero-Free/nrf52832-nimble\" target=\"_blank\" rel=\"noopener\">rt-thread官方移植nimble源码下载地址</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>磨刀不误砍柴工，前期多做点理论积累，后期才能少掉坑。<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><a href=\"https://www.rt-thread.org/document/site/tutorial/quick-start/introduction/introduction/\" target=\"_blank\" rel=\"noopener\">rt-thread简介</a></p>\n<p><a href=\"http://mynewt.apache.org/latest/network/docs/index.html#\" target=\"_blank\" rel=\"noopener\">nimble简介</a></p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-导读\">1. 导读</a></li>\n<li><a href=\"#2-系统\">2. 系统</a></li>\n<li><a href=\"#3-蓝牙\">3. 蓝牙</a></li>\n<li><a href=\"#4-硬件\">4. 硬件</a></li>\n<li><a href=\"#5-软件\">5. 软件</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-导读\"><a href=\"#1-导读\" class=\"headerlink\" title=\"1. 导读\"></a>1. 导读</h1><p>知识点根据需要认知的程度分为：<code>了解</code>、<code>理解</code>、<code>专业</code>，对于知识点不建议强行记忆，建议多看、多想和多做，所谓读书百遍其意自现。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>例子</strong></th>\n<th style=\"text-align:center\"><strong>程度</strong></th>\n<th style=\"text-align:left\"><strong>备注</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">信号量</td>\n<td style=\"text-align:center\">了解</td>\n<td style=\"text-align:left\">两个函数之间的共享变量，像全局变量标志位</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">理解</td>\n<td style=\"text-align:left\">工作机制、API使用方法，无须深究源码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">专业</td>\n<td style=\"text-align:left\">略 </td>\n</tr>\n</tbody>\n</table>\n<p>一般从网上搜一篇文章就可以达到<code>了解</code>的程度，<code>理解</code>则需要多看几篇。</p>\n<p>刚接触一个复杂的软件的时候，不建议深究源码，我个人的习惯是按照：</p>\n<ol>\n<li>软件可以运行</li>\n<li>理解裁剪</li>\n<li>软件刚刚好可以运行</li>\n<li>研究细节</li>\n</ol>\n<p>就是想说学习方法很重要，不要钻牛角尖。</p>\n<h1 id=\"2-系统\"><a href=\"#2-系统\" class=\"headerlink\" title=\"2. 系统\"></a>2. 系统</h1><p>关于rt-thread的入门资料，<a href=\"https://www.rt-thread.org/document/site/\" target=\"_blank\" rel=\"noopener\">rt-thread文档中心</a>这部分做的很cool，其中“内核”、“Env工具”、“设备和驱动”、“代码贡献-软件包开发”章节，建议至少看一遍。</p>\n<ul>\n<li>知识点1（理解）：内核整个章节</li>\n<li>知识点2（了解）：env的安装（只是为了运行scons和menuconfig）</li>\n<li>知识点3（了解）：menuconfig的使用<ul>\n<li>Kconfig（该文件决定rt_config.h包含哪些宏定义，rt_config.h会被nimble协议栈include）</li>\n</ul>\n</li>\n<li>知识点4（了解）：scons的使用<ul>\n<li><code>scons --target=mdk5</code>（keil编译和仿真）</li>\n<li>SConscript（修改该脚本，配合<code>scons --target=mdk5</code>来理解协议栈）</li>\n</ul>\n</li>\n<li>知识点5（理解）：设备和驱动<ul>\n<li>移植芯片驱动（尽量理解，后面移植章节介绍）</li>\n</ul>\n</li>\n<li>知识点6（了解）：软件包<ul>\n<li>Kconfig文件</li>\n</ul>\n</li>\n</ul>\n<p>这里除了<code>知识点3</code>和<code>知识点5</code>，其他知识点rt-thread官网已提供足够资料学习。</p>\n<h1 id=\"3-蓝牙\"><a href=\"#3-蓝牙\" class=\"headerlink\" title=\"3. 蓝牙\"></a>3. 蓝牙</h1><p><a href=\"https://www.bluetooth.com/specifications/bluetooth-core-specification/\" target=\"_blank\" rel=\"noopener\"><strong>蓝牙核心规范下载地址</strong></a></p>\n<p>蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。</p>\n<p>不同厂家根据自家芯片的特性，用代码去实现这份文档的内容，这些代码称为蓝牙协议栈。</p>\n<p>基于蓝牙协议栈二次开发的工作，称为蓝牙应用开发。</p>\n<p>学习蓝牙软件门槛不高，但是会有瓶颈：</p>\n<ul>\n<li>它不难理解，不像人工智能需要有数学底蕴；它只是稍微复杂一点，花时间都能看懂，所以说门槛不高。</li>\n<li>因为协议栈不开源，看不到底层实现，所以会遇到瓶颈。</li>\n</ul>\n<p>nimble低功耗蓝牙协议栈，层层划分清晰，便于我们理解复杂的实现，而全开源解决了学习蓝牙软件的瓶颈问题，是学习蓝牙规范的一个好工具。</p>\n<p>但要是商用就要斟酌一番，毕竟开源不收钱，出现bug只能自力更生。</p>\n<ul>\n<li>知识点1：（理解）学习蓝牙软件不难，商用nimble需谨慎。</li>\n<li>知识点2：（了解）蓝牙应用开发可通过博客/Q群/论坛等途径学习</li>\n</ul>\n<blockquote>\n<p>推荐红旭论坛：<a href=\"http://bbs.wireless-tech.cn\" target=\"_blank\" rel=\"noopener\">http://bbs.wireless-tech.cn</a></p>\n</blockquote>\n<h1 id=\"4-硬件\"><a href=\"#4-硬件\" class=\"headerlink\" title=\"4. 硬件\"></a>4. 硬件</h1><p>只需要掌握一个硬件平台的知识点即可。</p>\n<ul>\n<li><p>硬件：红旭 | HX-DK夏开发板</p>\n<ul>\n<li>知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO</li>\n<li>知识点2（了解）：从官方资料了解串口TX和RX引脚编号、LED灯引脚编号以及外围电路  </li>\n</ul>\n</li>\n<li><p>硬件：nordic | nrf52 dk开发板</p>\n<ul>\n<li>知识点1（了解）：学习ble用到的外设GPIO/RTC/UART/PPI/TIMER/RADIO</li>\n<li>知识点2（了解）：从开发板背面了解串口TX和RX引脚编号、LED灯引脚编号及外围电路</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"5-软件\"><a href=\"#5-软件\" class=\"headerlink\" title=\"5. 软件\"></a>5. 软件</h1><ul>\n<li><a href=\"https://www.rt-thread.org/page/download.html\" target=\"_blank\" rel=\"noopener\">rt-thread源码下载地址（后面文章使用v4.0.0版本）</a></li>\n<li><a href=\"http://mynewt.apache.org/download/\" target=\"_blank\" rel=\"noopener\">nimble源码下载地址（后面文章使用v1.2.0版本）</a></li>\n<li><a href=\"http://mynewt.apache.org/download/\" target=\"_blank\" rel=\"noopener\">mynewt源码下载地址</a></li>\n<li><a href=\"https://www.nordicsemi.com/Software-and-Tools/Software/nRF5-SDK\" target=\"_blank\" rel=\"noopener\">nrf52_sdk包下载地址（后面文章使用nRF5_SDK_15.3.0_59ac345版本）</a></li>\n<li><a href=\"http://www.keil.com/dd2/Pack/#/third-party-download-dialog\" target=\"_blank\" rel=\"noopener\">nrf的Device_Family_Pack下载地址（后面文章使用8.24.1版本）</a></li>\n<li><a href=\"https://github.com/Zero-Free/nrf52832-nimble\" target=\"_blank\" rel=\"noopener\">rt-thread官方移植nimble源码下载地址</a></li>\n</ul>"},{"title":"rtt+nimble揭秘系列——题外话（0）","date":"2019-09-24T16:40:17.000Z","_content":"\n-\n<!-- more --> \n\n前言\n===\n\n这章与技术无关，是博主的一得之见，欢迎交流，求同存异。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 为什么选rt-thread和nimble](#1-为什么选rt-thread和nimble)\n    - [1.1. 关于物联网](#11-关于物联网)\n    - [1.2. 关于rt-thread](#12-关于rt-thread)\n    - [1.3. 关于嵌入式软件](#13-关于嵌入式软件)\n    - [1.4. 关于ble协议栈](#14-关于ble协议栈)\n    - [1.5. 关于时间投入](#15-关于时间投入)\n\n<!-- /TOC -->\n\n# 1. 为什么选rt-thread和nimble\n \n\n## 1.1. 关于物联网\n\n物联网的概念近几年开始重新翻炒起来，在5G技术的加持下，明眼人都能看出来这个万亿级市场钱途一片光明。\n\n从现在各大厂在这一块布局来看，思路都是搭建从`端`到`云`的基础设施，开放平台接入，形成自己的生态圈，等到时机成熟再花式割韭菜，现在正处于一个攻城略地的白热化阶段。\n\n大佬们在悄咪咪的抓住先机占领市场，建立生态。同样的，作为码农就应该有笨鸟先飞，抱紧大腿，学习新知识的觉悟。\n\n依我愚见，各大厂的物联网操作系统（iot os）是一个不错的方向。\n\n## 1.2. 关于rt-thread\n\n各家iot os技术指标，比如：上下文切换时间，快那么几个us等，对绝大部分应用场景来说，意义不大，所以这里不展开，趣度之。\n\n我之所以选择rt-thread有以下考虑：\n- C面向对象设计\n- 集成nimble\n- 上手门槛低\n- 对国产老牌嵌入式os劲旅的支持\n\n## 1.3. 关于嵌入式软件\n\n不少从事嵌入式行业的软件工作者，在上学期间没有接触过软件工程知识，博主就是之一。\n\n工作一段时间后，写软件会有“套路章法”，有的来自公司祖传代码，有的是加班时一刹灵光，其中涉及的“道理”，问就是不知道，反正这样做就对了。\n\n再到后来了解到：面向对象思想、SOLID设计原则、设计模式、uml等等，原来代码应该这样写，业务逻辑可以这样画出来。\n\n嵌入式离不开底层，越是底层，代码设计越是精简，若是在精简中仍保持巧妙的设计思想，在我看来就是一份值得钻研的高质量代码。\n\nrt-thread官方介绍系统采用C面向对象设计，这就很棒。在看了`rtdef.h`文件之后，很舒服，故决定拜读一下，要是能在其中领悟到一丝精髓也不错。\n\n## 1.4. 关于ble协议栈\n\n市场上所有BLE芯片原厂都不会完全公开自己的协议栈，没有例外。如果想要研究完整协议栈（host + controller）的实现，要么到原厂去工作，要么目前就只能找全网仅有的以下两个开源协议栈。\n\n- zephyr\n\n该项目有linux基金会背书，各大原厂形成社区一起维护，实力毋庸置疑。虽开发工具高效但学习成本高，不适合初学者，适合对开源项目有一定经验的人。\n\n- nimble\n\n产自apache基金会（制订apache2 license的那个组织）。代码风格干净，与os耦合程度低，注释多，功能比zephyr少，适合学习。\n\n## 1.5. 关于时间投入\n\n年轻人的时间是十分宝贵的。\n\n我觉得年轻人不应该有“反正年轻，大把试错机会，先让子弹飞一会”的观念来麻痹自己，用战术上的勤奋来掩盖战略上的懒惰，选择比努力更重要。\n\n研究协议栈已经算是术业专攻，如果不是工作刚需和兴趣，要注意时间投入回报问题。\n\n\n\n","source":"_posts/rtt-nimble揭秘系列——题外话（0）.md","raw":"---\ntitle: rtt+nimble揭秘系列——题外话（0）\ndate: 2019-09-25 00:40:17\ntags:\n- rtthread\n- nimble\n\ncategories:\n- 一得之见\n\n---\n\n-\n<!-- more --> \n\n前言\n===\n\n这章与技术无关，是博主的一得之见，欢迎交流，求同存异。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 为什么选rt-thread和nimble](#1-为什么选rt-thread和nimble)\n    - [1.1. 关于物联网](#11-关于物联网)\n    - [1.2. 关于rt-thread](#12-关于rt-thread)\n    - [1.3. 关于嵌入式软件](#13-关于嵌入式软件)\n    - [1.4. 关于ble协议栈](#14-关于ble协议栈)\n    - [1.5. 关于时间投入](#15-关于时间投入)\n\n<!-- /TOC -->\n\n# 1. 为什么选rt-thread和nimble\n \n\n## 1.1. 关于物联网\n\n物联网的概念近几年开始重新翻炒起来，在5G技术的加持下，明眼人都能看出来这个万亿级市场钱途一片光明。\n\n从现在各大厂在这一块布局来看，思路都是搭建从`端`到`云`的基础设施，开放平台接入，形成自己的生态圈，等到时机成熟再花式割韭菜，现在正处于一个攻城略地的白热化阶段。\n\n大佬们在悄咪咪的抓住先机占领市场，建立生态。同样的，作为码农就应该有笨鸟先飞，抱紧大腿，学习新知识的觉悟。\n\n依我愚见，各大厂的物联网操作系统（iot os）是一个不错的方向。\n\n## 1.2. 关于rt-thread\n\n各家iot os技术指标，比如：上下文切换时间，快那么几个us等，对绝大部分应用场景来说，意义不大，所以这里不展开，趣度之。\n\n我之所以选择rt-thread有以下考虑：\n- C面向对象设计\n- 集成nimble\n- 上手门槛低\n- 对国产老牌嵌入式os劲旅的支持\n\n## 1.3. 关于嵌入式软件\n\n不少从事嵌入式行业的软件工作者，在上学期间没有接触过软件工程知识，博主就是之一。\n\n工作一段时间后，写软件会有“套路章法”，有的来自公司祖传代码，有的是加班时一刹灵光，其中涉及的“道理”，问就是不知道，反正这样做就对了。\n\n再到后来了解到：面向对象思想、SOLID设计原则、设计模式、uml等等，原来代码应该这样写，业务逻辑可以这样画出来。\n\n嵌入式离不开底层，越是底层，代码设计越是精简，若是在精简中仍保持巧妙的设计思想，在我看来就是一份值得钻研的高质量代码。\n\nrt-thread官方介绍系统采用C面向对象设计，这就很棒。在看了`rtdef.h`文件之后，很舒服，故决定拜读一下，要是能在其中领悟到一丝精髓也不错。\n\n## 1.4. 关于ble协议栈\n\n市场上所有BLE芯片原厂都不会完全公开自己的协议栈，没有例外。如果想要研究完整协议栈（host + controller）的实现，要么到原厂去工作，要么目前就只能找全网仅有的以下两个开源协议栈。\n\n- zephyr\n\n该项目有linux基金会背书，各大原厂形成社区一起维护，实力毋庸置疑。虽开发工具高效但学习成本高，不适合初学者，适合对开源项目有一定经验的人。\n\n- nimble\n\n产自apache基金会（制订apache2 license的那个组织）。代码风格干净，与os耦合程度低，注释多，功能比zephyr少，适合学习。\n\n## 1.5. 关于时间投入\n\n年轻人的时间是十分宝贵的。\n\n我觉得年轻人不应该有“反正年轻，大把试错机会，先让子弹飞一会”的观念来麻痹自己，用战术上的勤奋来掩盖战略上的懒惰，选择比努力更重要。\n\n研究协议栈已经算是术业专攻，如果不是工作刚需和兴趣，要注意时间投入回报问题。\n\n\n\n","slug":"rtt-nimble揭秘系列——题外话（0）","published":1,"updated":"2019-10-07T05:41:22.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8q680007gcg8k0tph1f7","content":"<p>-<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这章与技术无关，是博主的一得之见，欢迎交流，求同存异。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-为什么选rt-thread和nimble\">1. 为什么选rt-thread和nimble</a><ul>\n<li><a href=\"#11-关于物联网\">1.1. 关于物联网</a></li>\n<li><a href=\"#12-关于rt-thread\">1.2. 关于rt-thread</a></li>\n<li><a href=\"#13-关于嵌入式软件\">1.3. 关于嵌入式软件</a></li>\n<li><a href=\"#14-关于ble协议栈\">1.4. 关于ble协议栈</a></li>\n<li><a href=\"#15-关于时间投入\">1.5. 关于时间投入</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-为什么选rt-thread和nimble\"><a href=\"#1-为什么选rt-thread和nimble\" class=\"headerlink\" title=\"1. 为什么选rt-thread和nimble\"></a>1. 为什么选rt-thread和nimble</h1><h2 id=\"1-1-关于物联网\"><a href=\"#1-1-关于物联网\" class=\"headerlink\" title=\"1.1. 关于物联网\"></a>1.1. 关于物联网</h2><p>物联网的概念近几年开始重新翻炒起来，在5G技术的加持下，明眼人都能看出来这个万亿级市场钱途一片光明。</p>\n<p>从现在各大厂在这一块布局来看，思路都是搭建从<code>端</code>到<code>云</code>的基础设施，开放平台接入，形成自己的生态圈，等到时机成熟再花式割韭菜，现在正处于一个攻城略地的白热化阶段。</p>\n<p>大佬们在悄咪咪的抓住先机占领市场，建立生态。同样的，作为码农就应该有笨鸟先飞，抱紧大腿，学习新知识的觉悟。</p>\n<p>依我愚见，各大厂的物联网操作系统（iot os）是一个不错的方向。</p>\n<h2 id=\"1-2-关于rt-thread\"><a href=\"#1-2-关于rt-thread\" class=\"headerlink\" title=\"1.2. 关于rt-thread\"></a>1.2. 关于rt-thread</h2><p>各家iot os技术指标，比如：上下文切换时间，快那么几个us等，对绝大部分应用场景来说，意义不大，所以这里不展开，趣度之。</p>\n<p>我之所以选择rt-thread有以下考虑：</p>\n<ul>\n<li>C面向对象设计</li>\n<li>集成nimble</li>\n<li>上手门槛低</li>\n<li>对国产老牌嵌入式os劲旅的支持</li>\n</ul>\n<h2 id=\"1-3-关于嵌入式软件\"><a href=\"#1-3-关于嵌入式软件\" class=\"headerlink\" title=\"1.3. 关于嵌入式软件\"></a>1.3. 关于嵌入式软件</h2><p>不少从事嵌入式行业的软件工作者，在上学期间没有接触过软件工程知识，博主就是之一。</p>\n<p>工作一段时间后，写软件会有“套路章法”，有的来自公司祖传代码，有的是加班时一刹灵光，其中涉及的“道理”，问就是不知道，反正这样做就对了。</p>\n<p>再到后来了解到：面向对象思想、SOLID设计原则、设计模式、uml等等，原来代码应该这样写，业务逻辑可以这样画出来。</p>\n<p>嵌入式离不开底层，越是底层，代码设计越是精简，若是在精简中仍保持巧妙的设计思想，在我看来就是一份值得钻研的高质量代码。</p>\n<p>rt-thread官方介绍系统采用C面向对象设计，这就很棒。在看了<code>rtdef.h</code>文件之后，很舒服，故决定拜读一下，要是能在其中领悟到一丝精髓也不错。</p>\n<h2 id=\"1-4-关于ble协议栈\"><a href=\"#1-4-关于ble协议栈\" class=\"headerlink\" title=\"1.4. 关于ble协议栈\"></a>1.4. 关于ble协议栈</h2><p>市场上所有BLE芯片原厂都不会完全公开自己的协议栈，没有例外。如果想要研究完整协议栈（host + controller）的实现，要么到原厂去工作，要么目前就只能找全网仅有的以下两个开源协议栈。</p>\n<ul>\n<li>zephyr</li>\n</ul>\n<p>该项目有linux基金会背书，各大原厂形成社区一起维护，实力毋庸置疑。虽开发工具高效但学习成本高，不适合初学者，适合对开源项目有一定经验的人。</p>\n<ul>\n<li>nimble</li>\n</ul>\n<p>产自apache基金会（制订apache2 license的那个组织）。代码风格干净，与os耦合程度低，注释多，功能比zephyr少，适合学习。</p>\n<h2 id=\"1-5-关于时间投入\"><a href=\"#1-5-关于时间投入\" class=\"headerlink\" title=\"1.5. 关于时间投入\"></a>1.5. 关于时间投入</h2><p>年轻人的时间是十分宝贵的。</p>\n<p>我觉得年轻人不应该有“反正年轻，大把试错机会，先让子弹飞一会”的观念来麻痹自己，用战术上的勤奋来掩盖战略上的懒惰，选择比努力更重要。</p>\n<p>研究协议栈已经算是术业专攻，如果不是工作刚需和兴趣，要注意时间投入回报问题。</p>\n","site":{"data":{}},"excerpt":"<p>-<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这章与技术无关，是博主的一得之见，欢迎交流，求同存异。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-为什么选rt-thread和nimble\">1. 为什么选rt-thread和nimble</a><ul>\n<li><a href=\"#11-关于物联网\">1.1. 关于物联网</a></li>\n<li><a href=\"#12-关于rt-thread\">1.2. 关于rt-thread</a></li>\n<li><a href=\"#13-关于嵌入式软件\">1.3. 关于嵌入式软件</a></li>\n<li><a href=\"#14-关于ble协议栈\">1.4. 关于ble协议栈</a></li>\n<li><a href=\"#15-关于时间投入\">1.5. 关于时间投入</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-为什么选rt-thread和nimble\"><a href=\"#1-为什么选rt-thread和nimble\" class=\"headerlink\" title=\"1. 为什么选rt-thread和nimble\"></a>1. 为什么选rt-thread和nimble</h1><h2 id=\"1-1-关于物联网\"><a href=\"#1-1-关于物联网\" class=\"headerlink\" title=\"1.1. 关于物联网\"></a>1.1. 关于物联网</h2><p>物联网的概念近几年开始重新翻炒起来，在5G技术的加持下，明眼人都能看出来这个万亿级市场钱途一片光明。</p>\n<p>从现在各大厂在这一块布局来看，思路都是搭建从<code>端</code>到<code>云</code>的基础设施，开放平台接入，形成自己的生态圈，等到时机成熟再花式割韭菜，现在正处于一个攻城略地的白热化阶段。</p>\n<p>大佬们在悄咪咪的抓住先机占领市场，建立生态。同样的，作为码农就应该有笨鸟先飞，抱紧大腿，学习新知识的觉悟。</p>\n<p>依我愚见，各大厂的物联网操作系统（iot os）是一个不错的方向。</p>\n<h2 id=\"1-2-关于rt-thread\"><a href=\"#1-2-关于rt-thread\" class=\"headerlink\" title=\"1.2. 关于rt-thread\"></a>1.2. 关于rt-thread</h2><p>各家iot os技术指标，比如：上下文切换时间，快那么几个us等，对绝大部分应用场景来说，意义不大，所以这里不展开，趣度之。</p>\n<p>我之所以选择rt-thread有以下考虑：</p>\n<ul>\n<li>C面向对象设计</li>\n<li>集成nimble</li>\n<li>上手门槛低</li>\n<li>对国产老牌嵌入式os劲旅的支持</li>\n</ul>\n<h2 id=\"1-3-关于嵌入式软件\"><a href=\"#1-3-关于嵌入式软件\" class=\"headerlink\" title=\"1.3. 关于嵌入式软件\"></a>1.3. 关于嵌入式软件</h2><p>不少从事嵌入式行业的软件工作者，在上学期间没有接触过软件工程知识，博主就是之一。</p>\n<p>工作一段时间后，写软件会有“套路章法”，有的来自公司祖传代码，有的是加班时一刹灵光，其中涉及的“道理”，问就是不知道，反正这样做就对了。</p>\n<p>再到后来了解到：面向对象思想、SOLID设计原则、设计模式、uml等等，原来代码应该这样写，业务逻辑可以这样画出来。</p>\n<p>嵌入式离不开底层，越是底层，代码设计越是精简，若是在精简中仍保持巧妙的设计思想，在我看来就是一份值得钻研的高质量代码。</p>\n<p>rt-thread官方介绍系统采用C面向对象设计，这就很棒。在看了<code>rtdef.h</code>文件之后，很舒服，故决定拜读一下，要是能在其中领悟到一丝精髓也不错。</p>\n<h2 id=\"1-4-关于ble协议栈\"><a href=\"#1-4-关于ble协议栈\" class=\"headerlink\" title=\"1.4. 关于ble协议栈\"></a>1.4. 关于ble协议栈</h2><p>市场上所有BLE芯片原厂都不会完全公开自己的协议栈，没有例外。如果想要研究完整协议栈（host + controller）的实现，要么到原厂去工作，要么目前就只能找全网仅有的以下两个开源协议栈。</p>\n<ul>\n<li>zephyr</li>\n</ul>\n<p>该项目有linux基金会背书，各大原厂形成社区一起维护，实力毋庸置疑。虽开发工具高效但学习成本高，不适合初学者，适合对开源项目有一定经验的人。</p>\n<ul>\n<li>nimble</li>\n</ul>\n<p>产自apache基金会（制订apache2 license的那个组织）。代码风格干净，与os耦合程度低，注释多，功能比zephyr少，适合学习。</p>\n<h2 id=\"1-5-关于时间投入\"><a href=\"#1-5-关于时间投入\" class=\"headerlink\" title=\"1.5. 关于时间投入\"></a>1.5. 关于时间投入</h2><p>年轻人的时间是十分宝贵的。</p>\n<p>我觉得年轻人不应该有“反正年轻，大把试错机会，先让子弹飞一会”的观念来麻痹自己，用战术上的勤奋来掩盖战略上的懒惰，选择比努力更重要。</p>\n<p>研究协议栈已经算是术业专攻，如果不是工作刚需和兴趣，要注意时间投入回报问题。</p>"},{"title":"浅谈BLE核心架构和数据帧","date":"2019-10-09T11:15:15.000Z","_content":"\n\n谈谈大家平常少接触的蓝牙核心规范中关于ble有趣的部分，点到即止。\n<!-- more --> \n\n前言\n===\n\n蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. ble核心规范简介](#1-ble核心规范简介)\n    - [1.1. ble核心系统架构](#11-ble核心系统架构)\n        - [1.1.1. host](#111-host)\n        - [1.1.2. controller](#112-controller)\n        - [1.1.3. hci](#113-hci)\n    - [1.2. ble传输载体](#12-ble传输载体)\n        - [1.2.1. le link layer到LE-C的signaling数据帧](#121-le-link-layer到le-c的signaling数据帧)\n        - [1.2.2. le link layer到ADVB-C的signaling数据帧](#122-le-link-layer到advb-c的signaling数据帧)\n        - [1.2.3. l2cap manager的signaling数据帧](#123-l2cap-manager的signaling数据帧)\n        - [1.2.4. 更高层协议的signaling数据帧](#124-更高层协议的signaling数据帧)\n        - [1.2.5. 可靠的异步用户数据帧](#125-可靠的异步用户数据帧)\n        - [1.2.6. 不可靠的异步用户数据](#126-不可靠的异步用户数据)\n        - [1.2.7. 举例](#127-举例)\n\n<!-- /TOC -->\n\n\n# 1. ble核心规范简介\n\n下面从两个角度来总览ble协议，一个是从`协议层级划分`角度，即下文ble核心系统架构章节，另一个是`协议数据流向`角度，即下文ble传输载体章节。\n\n> NOTE：运输载体英文原文是traffic bearers，有种小船之于水流的感觉，我不知道如何翻译才贴切，欢迎各位提建议。\n\n## 1.1. ble核心系统架构\n\n下图为ble核心系统架构（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），ble核心架构可划分为两部分，分别是host和controller。\n\n![](ble_core_architecture.png)\n\n### 1.1.1. host\n- gatt\n- att\n- gap\n- smp\n- l2cap\n\n### 1.1.2. controller\n- device manager\n- link manager\n- baseband resource manager\n- link controller\n- phy\n\n### 1.1.3. hci\nhost和controller可通过hci（host-controller-interface）接口互相通信。具体表现为：\n- host通过hci向controller发送command\n- controller通过hci向host发送event\n- host和controller通过hci互传acl data\n\n## 1.2. ble传输载体\n\n下图为ble传输载体示意图（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），左边`Application`表示host中除l2cap以外部分的集合，`Bluetootch core`表示l2cap和整个controller。\n\n![](ble_core_traffic_bearers.png)\n\n\n结合上图，ble协议中流动的所有数据帧如下，即使分包也是由以下部分帧拆分而来：\n\n### 1.2.1. le link layer到LE-C的signaling数据帧\n- 如ll control pdu的LL_FEATURE_REQ\n\n### 1.2.2. le link layer到ADVB-C的signaling数据帧\n- 如scanning pdu的SCAN_REQ\n- 如initiating pdu的CONNECT_IND\n\n### 1.2.3. l2cap manager的signaling数据帧\n- 如l2cap的connection parameter update request\n\n### 1.2.4. 更高层协议的signaling数据帧\n- 如smp的pairing request\n\n### 1.2.5. 可靠的异步用户数据帧\n- 如gatt的write without response，其中att_payload包含用户数据\n    \n### 1.2.6. 不可靠的异步用户数据\n- 如advertising的ADV_IND，其中adv_payload包含ad type格式的用户数据\n\n### 1.2.7. 举例\n针对上述帧举一个例子详细说明，目的是**理清关系**。\n\n例子中有两个角色，一个是嵌入式蓝牙设备，称为device，另一个是手机，称为app。  \n\n如图所示从左到右为角色的每一层，从上到下为时间线。图中的交互行为并不完整，如：缺少响应包，但是这不影响我们的阅读。\n\n![](ble_communicate.svg)\n\n- 双方处于未连接状态\n\n    1. 某个时刻device's gap通过hci发送command，让device's controller开始发送ADV_IND，即开始广播，其中ADV_IND中包含device的设备名。\n    2. 某个时刻app's gap通过hci发送command，让app's controller开始发送SCAN_REQ，即开始扫描周边蓝牙设备。\n    3. app's controller发现了正在广播的device，随后通知app's gap，紧接着app's gap通过hci发送command，让app's controller开始发送CONNECT_IND，即发起连接请求\n\n- 双方刚刚建立连接状态\n    \n    1. app's controller向device 's controller发送LL_FEATURE_REQ，希望知道刚刚连上的device支持哪些特性。\n\n- 双方已经连接了一段时间状态\n\n    1. 连接一段时间后，device觉得频繁与app通信影响功耗，所以device's l2cap manager将connection parameter update request封装成acl data，通过hci发送给device's controller，device's controller随即将数据发给app's l2cap manager，即连接参数更新请求，该请求要求加大连接间隔。\n    2. 某个时刻app向发送用户数据给device，app's gatt将write without response发送给l2cap，l2cap将write without response封装成acl data通过hci发送给app's controller，让app's controller开始发送write without respon给device's gatt。\n    3. 某个时刻app觉得传输明文用户数据太危险，即app's smp发起了pairing request给l2cap，l2cap将pairing request封装成acl data通过hci发送给app's controller，让app's controller开始发送pairing request给device's smp。\n\n\n","source":"_posts/浅谈BLE核心架构和数据帧.md","raw":"---\ntitle: 浅谈BLE核心架构和数据帧\ndate: 2019-10-09 19:15:15\ntags:\n- ble\n\ncategories:\n- 术业专攻\n---\n\n\n谈谈大家平常少接触的蓝牙核心规范中关于ble有趣的部分，点到即止。\n<!-- more --> \n\n前言\n===\n\n蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. ble核心规范简介](#1-ble核心规范简介)\n    - [1.1. ble核心系统架构](#11-ble核心系统架构)\n        - [1.1.1. host](#111-host)\n        - [1.1.2. controller](#112-controller)\n        - [1.1.3. hci](#113-hci)\n    - [1.2. ble传输载体](#12-ble传输载体)\n        - [1.2.1. le link layer到LE-C的signaling数据帧](#121-le-link-layer到le-c的signaling数据帧)\n        - [1.2.2. le link layer到ADVB-C的signaling数据帧](#122-le-link-layer到advb-c的signaling数据帧)\n        - [1.2.3. l2cap manager的signaling数据帧](#123-l2cap-manager的signaling数据帧)\n        - [1.2.4. 更高层协议的signaling数据帧](#124-更高层协议的signaling数据帧)\n        - [1.2.5. 可靠的异步用户数据帧](#125-可靠的异步用户数据帧)\n        - [1.2.6. 不可靠的异步用户数据](#126-不可靠的异步用户数据)\n        - [1.2.7. 举例](#127-举例)\n\n<!-- /TOC -->\n\n\n# 1. ble核心规范简介\n\n下面从两个角度来总览ble协议，一个是从`协议层级划分`角度，即下文ble核心系统架构章节，另一个是`协议数据流向`角度，即下文ble传输载体章节。\n\n> NOTE：运输载体英文原文是traffic bearers，有种小船之于水流的感觉，我不知道如何翻译才贴切，欢迎各位提建议。\n\n## 1.1. ble核心系统架构\n\n下图为ble核心系统架构（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），ble核心架构可划分为两部分，分别是host和controller。\n\n![](ble_core_architecture.png)\n\n### 1.1.1. host\n- gatt\n- att\n- gap\n- smp\n- l2cap\n\n### 1.1.2. controller\n- device manager\n- link manager\n- baseband resource manager\n- link controller\n- phy\n\n### 1.1.3. hci\nhost和controller可通过hci（host-controller-interface）接口互相通信。具体表现为：\n- host通过hci向controller发送command\n- controller通过hci向host发送event\n- host和controller通过hci互传acl data\n\n## 1.2. ble传输载体\n\n下图为ble传输载体示意图（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），左边`Application`表示host中除l2cap以外部分的集合，`Bluetootch core`表示l2cap和整个controller。\n\n![](ble_core_traffic_bearers.png)\n\n\n结合上图，ble协议中流动的所有数据帧如下，即使分包也是由以下部分帧拆分而来：\n\n### 1.2.1. le link layer到LE-C的signaling数据帧\n- 如ll control pdu的LL_FEATURE_REQ\n\n### 1.2.2. le link layer到ADVB-C的signaling数据帧\n- 如scanning pdu的SCAN_REQ\n- 如initiating pdu的CONNECT_IND\n\n### 1.2.3. l2cap manager的signaling数据帧\n- 如l2cap的connection parameter update request\n\n### 1.2.4. 更高层协议的signaling数据帧\n- 如smp的pairing request\n\n### 1.2.5. 可靠的异步用户数据帧\n- 如gatt的write without response，其中att_payload包含用户数据\n    \n### 1.2.6. 不可靠的异步用户数据\n- 如advertising的ADV_IND，其中adv_payload包含ad type格式的用户数据\n\n### 1.2.7. 举例\n针对上述帧举一个例子详细说明，目的是**理清关系**。\n\n例子中有两个角色，一个是嵌入式蓝牙设备，称为device，另一个是手机，称为app。  \n\n如图所示从左到右为角色的每一层，从上到下为时间线。图中的交互行为并不完整，如：缺少响应包，但是这不影响我们的阅读。\n\n![](ble_communicate.svg)\n\n- 双方处于未连接状态\n\n    1. 某个时刻device's gap通过hci发送command，让device's controller开始发送ADV_IND，即开始广播，其中ADV_IND中包含device的设备名。\n    2. 某个时刻app's gap通过hci发送command，让app's controller开始发送SCAN_REQ，即开始扫描周边蓝牙设备。\n    3. app's controller发现了正在广播的device，随后通知app's gap，紧接着app's gap通过hci发送command，让app's controller开始发送CONNECT_IND，即发起连接请求\n\n- 双方刚刚建立连接状态\n    \n    1. app's controller向device 's controller发送LL_FEATURE_REQ，希望知道刚刚连上的device支持哪些特性。\n\n- 双方已经连接了一段时间状态\n\n    1. 连接一段时间后，device觉得频繁与app通信影响功耗，所以device's l2cap manager将connection parameter update request封装成acl data，通过hci发送给device's controller，device's controller随即将数据发给app's l2cap manager，即连接参数更新请求，该请求要求加大连接间隔。\n    2. 某个时刻app向发送用户数据给device，app's gatt将write without response发送给l2cap，l2cap将write without response封装成acl data通过hci发送给app's controller，让app's controller开始发送write without respon给device's gatt。\n    3. 某个时刻app觉得传输明文用户数据太危险，即app's smp发起了pairing request给l2cap，l2cap将pairing request封装成acl data通过hci发送给app's controller，让app's controller开始发送pairing request给device's smp。\n\n\n","slug":"浅谈BLE核心架构和数据帧","published":1,"updated":"2019-10-23T05:10:56.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8q690008gcg84iaxzygv","content":"<p>谈谈大家平常少接触的蓝牙核心规范中关于ble有趣的部分，点到即止。<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-ble核心规范简介\">1. ble核心规范简介</a><ul>\n<li><a href=\"#11-ble核心系统架构\">1.1. ble核心系统架构</a><ul>\n<li><a href=\"#111-host\">1.1.1. host</a></li>\n<li><a href=\"#112-controller\">1.1.2. controller</a></li>\n<li><a href=\"#113-hci\">1.1.3. hci</a></li>\n</ul>\n</li>\n<li><a href=\"#12-ble传输载体\">1.2. ble传输载体</a><ul>\n<li><a href=\"#121-le-link-layer到le-c的signaling数据帧\">1.2.1. le link layer到LE-C的signaling数据帧</a></li>\n<li><a href=\"#122-le-link-layer到advb-c的signaling数据帧\">1.2.2. le link layer到ADVB-C的signaling数据帧</a></li>\n<li><a href=\"#123-l2cap-manager的signaling数据帧\">1.2.3. l2cap manager的signaling数据帧</a></li>\n<li><a href=\"#124-更高层协议的signaling数据帧\">1.2.4. 更高层协议的signaling数据帧</a></li>\n<li><a href=\"#125-可靠的异步用户数据帧\">1.2.5. 可靠的异步用户数据帧</a></li>\n<li><a href=\"#126-不可靠的异步用户数据\">1.2.6. 不可靠的异步用户数据</a></li>\n<li><a href=\"#127-举例\">1.2.7. 举例</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-ble核心规范简介\"><a href=\"#1-ble核心规范简介\" class=\"headerlink\" title=\"1. ble核心规范简介\"></a>1. ble核心规范简介</h1><p>下面从两个角度来总览ble协议，一个是从<code>协议层级划分</code>角度，即下文ble核心系统架构章节，另一个是<code>协议数据流向</code>角度，即下文ble传输载体章节。</p>\n<blockquote>\n<p>NOTE：运输载体英文原文是traffic bearers，有种小船之于水流的感觉，我不知道如何翻译才贴切，欢迎各位提建议。</p>\n</blockquote>\n<h2 id=\"1-1-ble核心系统架构\"><a href=\"#1-1-ble核心系统架构\" class=\"headerlink\" title=\"1.1. ble核心系统架构\"></a>1.1. ble核心系统架构</h2><p>下图为ble核心系统架构（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），ble核心架构可划分为两部分，分别是host和controller。</p>\n<p><img src=\"ble_core_architecture.png\" alt></p>\n<h3 id=\"1-1-1-host\"><a href=\"#1-1-1-host\" class=\"headerlink\" title=\"1.1.1. host\"></a>1.1.1. host</h3><ul>\n<li>gatt</li>\n<li>att</li>\n<li>gap</li>\n<li>smp</li>\n<li>l2cap</li>\n</ul>\n<h3 id=\"1-1-2-controller\"><a href=\"#1-1-2-controller\" class=\"headerlink\" title=\"1.1.2. controller\"></a>1.1.2. controller</h3><ul>\n<li>device manager</li>\n<li>link manager</li>\n<li>baseband resource manager</li>\n<li>link controller</li>\n<li>phy</li>\n</ul>\n<h3 id=\"1-1-3-hci\"><a href=\"#1-1-3-hci\" class=\"headerlink\" title=\"1.1.3. hci\"></a>1.1.3. hci</h3><p>host和controller可通过hci（host-controller-interface）接口互相通信。具体表现为：</p>\n<ul>\n<li>host通过hci向controller发送command</li>\n<li>controller通过hci向host发送event</li>\n<li>host和controller通过hci互传acl data</li>\n</ul>\n<h2 id=\"1-2-ble传输载体\"><a href=\"#1-2-ble传输载体\" class=\"headerlink\" title=\"1.2. ble传输载体\"></a>1.2. ble传输载体</h2><p>下图为ble传输载体示意图（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），左边<code>Application</code>表示host中除l2cap以外部分的集合，<code>Bluetootch core</code>表示l2cap和整个controller。</p>\n<p><img src=\"ble_core_traffic_bearers.png\" alt></p>\n<p>结合上图，ble协议中流动的所有数据帧如下，即使分包也是由以下部分帧拆分而来：</p>\n<h3 id=\"1-2-1-le-link-layer到LE-C的signaling数据帧\"><a href=\"#1-2-1-le-link-layer到LE-C的signaling数据帧\" class=\"headerlink\" title=\"1.2.1. le link layer到LE-C的signaling数据帧\"></a>1.2.1. le link layer到LE-C的signaling数据帧</h3><ul>\n<li>如ll control pdu的LL_FEATURE_REQ</li>\n</ul>\n<h3 id=\"1-2-2-le-link-layer到ADVB-C的signaling数据帧\"><a href=\"#1-2-2-le-link-layer到ADVB-C的signaling数据帧\" class=\"headerlink\" title=\"1.2.2. le link layer到ADVB-C的signaling数据帧\"></a>1.2.2. le link layer到ADVB-C的signaling数据帧</h3><ul>\n<li>如scanning pdu的SCAN_REQ</li>\n<li>如initiating pdu的CONNECT_IND</li>\n</ul>\n<h3 id=\"1-2-3-l2cap-manager的signaling数据帧\"><a href=\"#1-2-3-l2cap-manager的signaling数据帧\" class=\"headerlink\" title=\"1.2.3. l2cap manager的signaling数据帧\"></a>1.2.3. l2cap manager的signaling数据帧</h3><ul>\n<li>如l2cap的connection parameter update request</li>\n</ul>\n<h3 id=\"1-2-4-更高层协议的signaling数据帧\"><a href=\"#1-2-4-更高层协议的signaling数据帧\" class=\"headerlink\" title=\"1.2.4. 更高层协议的signaling数据帧\"></a>1.2.4. 更高层协议的signaling数据帧</h3><ul>\n<li>如smp的pairing request</li>\n</ul>\n<h3 id=\"1-2-5-可靠的异步用户数据帧\"><a href=\"#1-2-5-可靠的异步用户数据帧\" class=\"headerlink\" title=\"1.2.5. 可靠的异步用户数据帧\"></a>1.2.5. 可靠的异步用户数据帧</h3><ul>\n<li>如gatt的write without response，其中att_payload包含用户数据</li>\n</ul>\n<h3 id=\"1-2-6-不可靠的异步用户数据\"><a href=\"#1-2-6-不可靠的异步用户数据\" class=\"headerlink\" title=\"1.2.6. 不可靠的异步用户数据\"></a>1.2.6. 不可靠的异步用户数据</h3><ul>\n<li>如advertising的ADV_IND，其中adv_payload包含ad type格式的用户数据</li>\n</ul>\n<h3 id=\"1-2-7-举例\"><a href=\"#1-2-7-举例\" class=\"headerlink\" title=\"1.2.7. 举例\"></a>1.2.7. 举例</h3><p>针对上述帧举一个例子详细说明，目的是<strong>理清关系</strong>。</p>\n<p>例子中有两个角色，一个是嵌入式蓝牙设备，称为device，另一个是手机，称为app。  </p>\n<p>如图所示从左到右为角色的每一层，从上到下为时间线。图中的交互行为并不完整，如：缺少响应包，但是这不影响我们的阅读。</p>\n<p><img src=\"ble_communicate.svg\" alt></p>\n<ul>\n<li><p>双方处于未连接状态</p>\n<ol>\n<li>某个时刻device’s gap通过hci发送command，让device’s controller开始发送ADV_IND，即开始广播，其中ADV_IND中包含device的设备名。</li>\n<li>某个时刻app’s gap通过hci发送command，让app’s controller开始发送SCAN_REQ，即开始扫描周边蓝牙设备。</li>\n<li>app’s controller发现了正在广播的device，随后通知app’s gap，紧接着app’s gap通过hci发送command，让app’s controller开始发送CONNECT_IND，即发起连接请求</li>\n</ol>\n</li>\n<li><p>双方刚刚建立连接状态</p>\n<ol>\n<li>app’s controller向device ‘s controller发送LL_FEATURE_REQ，希望知道刚刚连上的device支持哪些特性。</li>\n</ol>\n</li>\n<li><p>双方已经连接了一段时间状态</p>\n<ol>\n<li>连接一段时间后，device觉得频繁与app通信影响功耗，所以device’s l2cap manager将connection parameter update request封装成acl data，通过hci发送给device’s controller，device’s controller随即将数据发给app’s l2cap manager，即连接参数更新请求，该请求要求加大连接间隔。</li>\n<li>某个时刻app向发送用户数据给device，app’s gatt将write without response发送给l2cap，l2cap将write without response封装成acl data通过hci发送给app’s controller，让app’s controller开始发送write without respon给device’s gatt。</li>\n<li>某个时刻app觉得传输明文用户数据太危险，即app’s smp发起了pairing request给l2cap，l2cap将pairing request封装成acl data通过hci发送给app’s controller，让app’s controller开始发送pairing request给device’s smp。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>谈谈大家平常少接触的蓝牙核心规范中关于ble有趣的部分，点到即止。<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>蓝牙核心规范（bluetooth-core-specification），也常称为蓝牙协议，是一份公开的文档。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-ble核心规范简介\">1. ble核心规范简介</a><ul>\n<li><a href=\"#11-ble核心系统架构\">1.1. ble核心系统架构</a><ul>\n<li><a href=\"#111-host\">1.1.1. host</a></li>\n<li><a href=\"#112-controller\">1.1.2. controller</a></li>\n<li><a href=\"#113-hci\">1.1.3. hci</a></li>\n</ul>\n</li>\n<li><a href=\"#12-ble传输载体\">1.2. ble传输载体</a><ul>\n<li><a href=\"#121-le-link-layer到le-c的signaling数据帧\">1.2.1. le link layer到LE-C的signaling数据帧</a></li>\n<li><a href=\"#122-le-link-layer到advb-c的signaling数据帧\">1.2.2. le link layer到ADVB-C的signaling数据帧</a></li>\n<li><a href=\"#123-l2cap-manager的signaling数据帧\">1.2.3. l2cap manager的signaling数据帧</a></li>\n<li><a href=\"#124-更高层协议的signaling数据帧\">1.2.4. 更高层协议的signaling数据帧</a></li>\n<li><a href=\"#125-可靠的异步用户数据帧\">1.2.5. 可靠的异步用户数据帧</a></li>\n<li><a href=\"#126-不可靠的异步用户数据\">1.2.6. 不可靠的异步用户数据</a></li>\n<li><a href=\"#127-举例\">1.2.7. 举例</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-ble核心规范简介\"><a href=\"#1-ble核心规范简介\" class=\"headerlink\" title=\"1. ble核心规范简介\"></a>1. ble核心规范简介</h1><p>下面从两个角度来总览ble协议，一个是从<code>协议层级划分</code>角度，即下文ble核心系统架构章节，另一个是<code>协议数据流向</code>角度，即下文ble传输载体章节。</p>\n<blockquote>\n<p>NOTE：运输载体英文原文是traffic bearers，有种小船之于水流的感觉，我不知道如何翻译才贴切，欢迎各位提建议。</p>\n</blockquote>\n<h2 id=\"1-1-ble核心系统架构\"><a href=\"#1-1-ble核心系统架构\" class=\"headerlink\" title=\"1.1. ble核心系统架构\"></a>1.1. ble核心系统架构</h2><p>下图为ble核心系统架构（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），ble核心架构可划分为两部分，分别是host和controller。</p>\n<p><img src=\"ble_core_architecture.png\" alt></p>\n<h3 id=\"1-1-1-host\"><a href=\"#1-1-1-host\" class=\"headerlink\" title=\"1.1.1. host\"></a>1.1.1. host</h3><ul>\n<li>gatt</li>\n<li>att</li>\n<li>gap</li>\n<li>smp</li>\n<li>l2cap</li>\n</ul>\n<h3 id=\"1-1-2-controller\"><a href=\"#1-1-2-controller\" class=\"headerlink\" title=\"1.1.2. controller\"></a>1.1.2. controller</h3><ul>\n<li>device manager</li>\n<li>link manager</li>\n<li>baseband resource manager</li>\n<li>link controller</li>\n<li>phy</li>\n</ul>\n<h3 id=\"1-1-3-hci\"><a href=\"#1-1-3-hci\" class=\"headerlink\" title=\"1.1.3. hci\"></a>1.1.3. hci</h3><p>host和controller可通过hci（host-controller-interface）接口互相通信。具体表现为：</p>\n<ul>\n<li>host通过hci向controller发送command</li>\n<li>controller通过hci向host发送event</li>\n<li>host和controller通过hci互传acl data</li>\n</ul>\n<h2 id=\"1-2-ble传输载体\"><a href=\"#1-2-ble传输载体\" class=\"headerlink\" title=\"1.2. ble传输载体\"></a>1.2. ble传输载体</h2><p>下图为ble传输载体示意图（截取自蓝牙核心规范，将低功耗蓝牙部分PS了出来），左边<code>Application</code>表示host中除l2cap以外部分的集合，<code>Bluetootch core</code>表示l2cap和整个controller。</p>\n<p><img src=\"ble_core_traffic_bearers.png\" alt></p>\n<p>结合上图，ble协议中流动的所有数据帧如下，即使分包也是由以下部分帧拆分而来：</p>\n<h3 id=\"1-2-1-le-link-layer到LE-C的signaling数据帧\"><a href=\"#1-2-1-le-link-layer到LE-C的signaling数据帧\" class=\"headerlink\" title=\"1.2.1. le link layer到LE-C的signaling数据帧\"></a>1.2.1. le link layer到LE-C的signaling数据帧</h3><ul>\n<li>如ll control pdu的LL_FEATURE_REQ</li>\n</ul>\n<h3 id=\"1-2-2-le-link-layer到ADVB-C的signaling数据帧\"><a href=\"#1-2-2-le-link-layer到ADVB-C的signaling数据帧\" class=\"headerlink\" title=\"1.2.2. le link layer到ADVB-C的signaling数据帧\"></a>1.2.2. le link layer到ADVB-C的signaling数据帧</h3><ul>\n<li>如scanning pdu的SCAN_REQ</li>\n<li>如initiating pdu的CONNECT_IND</li>\n</ul>\n<h3 id=\"1-2-3-l2cap-manager的signaling数据帧\"><a href=\"#1-2-3-l2cap-manager的signaling数据帧\" class=\"headerlink\" title=\"1.2.3. l2cap manager的signaling数据帧\"></a>1.2.3. l2cap manager的signaling数据帧</h3><ul>\n<li>如l2cap的connection parameter update request</li>\n</ul>\n<h3 id=\"1-2-4-更高层协议的signaling数据帧\"><a href=\"#1-2-4-更高层协议的signaling数据帧\" class=\"headerlink\" title=\"1.2.4. 更高层协议的signaling数据帧\"></a>1.2.4. 更高层协议的signaling数据帧</h3><ul>\n<li>如smp的pairing request</li>\n</ul>\n<h3 id=\"1-2-5-可靠的异步用户数据帧\"><a href=\"#1-2-5-可靠的异步用户数据帧\" class=\"headerlink\" title=\"1.2.5. 可靠的异步用户数据帧\"></a>1.2.5. 可靠的异步用户数据帧</h3><ul>\n<li>如gatt的write without response，其中att_payload包含用户数据</li>\n</ul>\n<h3 id=\"1-2-6-不可靠的异步用户数据\"><a href=\"#1-2-6-不可靠的异步用户数据\" class=\"headerlink\" title=\"1.2.6. 不可靠的异步用户数据\"></a>1.2.6. 不可靠的异步用户数据</h3><ul>\n<li>如advertising的ADV_IND，其中adv_payload包含ad type格式的用户数据</li>\n</ul>\n<h3 id=\"1-2-7-举例\"><a href=\"#1-2-7-举例\" class=\"headerlink\" title=\"1.2.7. 举例\"></a>1.2.7. 举例</h3><p>针对上述帧举一个例子详细说明，目的是<strong>理清关系</strong>。</p>\n<p>例子中有两个角色，一个是嵌入式蓝牙设备，称为device，另一个是手机，称为app。  </p>\n<p>如图所示从左到右为角色的每一层，从上到下为时间线。图中的交互行为并不完整，如：缺少响应包，但是这不影响我们的阅读。</p>\n<p><img src=\"ble_communicate.svg\" alt></p>\n<ul>\n<li><p>双方处于未连接状态</p>\n<ol>\n<li>某个时刻device’s gap通过hci发送command，让device’s controller开始发送ADV_IND，即开始广播，其中ADV_IND中包含device的设备名。</li>\n<li>某个时刻app’s gap通过hci发送command，让app’s controller开始发送SCAN_REQ，即开始扫描周边蓝牙设备。</li>\n<li>app’s controller发现了正在广播的device，随后通知app’s gap，紧接着app’s gap通过hci发送command，让app’s controller开始发送CONNECT_IND，即发起连接请求</li>\n</ol>\n</li>\n<li><p>双方刚刚建立连接状态</p>\n<ol>\n<li>app’s controller向device ‘s controller发送LL_FEATURE_REQ，希望知道刚刚连上的device支持哪些特性。</li>\n</ol>\n</li>\n<li><p>双方已经连接了一段时间状态</p>\n<ol>\n<li>连接一段时间后，device觉得频繁与app通信影响功耗，所以device’s l2cap manager将connection parameter update request封装成acl data，通过hci发送给device’s controller，device’s controller随即将数据发给app’s l2cap manager，即连接参数更新请求，该请求要求加大连接间隔。</li>\n<li>某个时刻app向发送用户数据给device，app’s gatt将write without response发送给l2cap，l2cap将write without response封装成acl data通过hci发送给app’s controller，让app’s controller开始发送write without respon给device’s gatt。</li>\n<li>某个时刻app觉得传输明文用户数据太危险，即app’s smp发起了pairing request给l2cap，l2cap将pairing request封装成acl data通过hci发送给app’s controller，让app’s controller开始发送pairing request给device’s smp。</li>\n</ol>\n</li>\n</ul>"},{"title":"rtt+nimble揭秘系列——移植bsp（2）","date":"2019-10-08T16:24:28.000Z","_content":"\n为你的bsp建立一个干净的项目框架。\n<!-- more --> \n\n前言\n===\n\n博主不喜欢从零开始造轮子，但是有“不试一下鬼知道做了什么”强迫症，因此钟爱搬运移植文件，用一些土方法来理清软件之间的关系以及换一个平台怎么办的思路。\n\n移植目标：移植rt-thread到开发板上，并通过串口打印hello world。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 建立项目框架](#1-建立项目框架)\n    - [1.1. 认识nrfx](#11-认识nrfx)\n    - [1.2. rt-thread构建环境](#12-rt-thread构建环境)\n        - [1.2.1. 创建bsp文件夹](#121-创建bsp文件夹)\n        - [1.2.2. 添加bsp的模板工程](#122-添加bsp的模板工程)\n        - [1.2.3. 添加bsp的Kconfig](#123-添加bsp的kconfig)\n        - [1.2.4. 添加bsp的rtconfig.py](#124-添加bsp的rtconfigpy)\n        - [1.2.5. 添加bsp的SConscript/SConstruct](#125-添加bsp的sconscriptsconstruct)\n        - [1.2.6. 添加nrfx](#126-添加nrfx)\n        - [1.2.7. 添加设备驱动实现](#127-添加设备驱动实现)\n        - [1.2.8. 添加应用层代码](#128-添加应用层代码)\n    - [1.3. 验证环境构建结果](#13-验证环境构建结果)\n\n<!-- /TOC -->\n\n# 1. 建立项目框架\n\n## 1.1. 认识nrfx\n\n文件夹路径：nRF5_SDK_15.3.0_59ac345\\modules\\nrfx\n\nnrfx由nordic提供的一系列外设驱动组成，无需集成厚重的标准SDK就能把芯片跑起来，是一个轻量级的驱动库。\n\n移植只需要关注以下内容：\n- 芯片类型宏定义\n- nrfx_config.h\n- nrfx_glue.h\n- nrfx_log.h\n- CMSIS/include\n\n**芯片类型宏定义**：  \n在编译阶段必须加入一款芯片类型宏定义，否则编译会报错，后面会在SConscript中加入芯片类型宏定义。\n\n```C\n/* Device selection for device includes. */\n#if defined (NRF51)\n    #include \"nrf51.h\"\n    #include \"nrf51_bitfields.h\"\n    #include \"nrf51_deprecated.h\"\n#elif defined (NRF52810_XXAA)\n    #include \"nrf52810.h\"\n    #include \"nrf52810_bitfields.h\"\n    #include \"nrf51_to_nrf52810.h\"\n    #include \"nrf52_to_nrf52810.h\"\n#elif defined (NRF52811_XXAA)\n    #include \"nrf52811.h\"\n    #include \"nrf52811_bitfields.h\"  \n    #include \"nrf51_to_nrf52810.h\"\n    #include \"nrf52_to_nrf52810.h\"\n    #include \"nrf52810_to_nrf52811.h\" \n#elif defined (NRF52832_XXAA) || defined (NRF52832_XXAB)\n    #include \"nrf52.h\"\n    #include \"nrf52_bitfields.h\"\n    #include \"nrf51_to_nrf52.h\"\n    #include \"nrf52_name_change.h\"\n#elif defined (NRF52840_XXAA)\n    #include \"nrf52840.h\"\n    #include \"nrf52840_bitfields.h\"\n    #include \"nrf51_to_nrf52840.h\"\n    #include \"nrf52_to_nrf52840.h\"\n    \n#elif defined (NRF9160_XXAA)\n    #include \"nrf9160.h\"\n    #include \"nrf9160_bitfields.h\"\n    \n#else\n    #error \"Device must be defined. See nrf.h.\"\n#endif /* NRF51, NRF52810_XXAA, NRF52811_XXAA, NRF52832_XXAA, NRF52832_XXAB, NRF52840_XXAA, NRF9160_XXAA */\n```\n\n**nrfx_config.h**:  \n该文件可以配置nrfx驱动，可以在keil在界面配置，如下图所示。\n\n![](nrfx_config.png)\n\n**nrfx_glue.h**  \n该文件由`未实现的宏定义`组成，`未实现宏定义`可以看成`钩子函数`，nrfx驱动代码会调用这些`钩子函数`，如果需要用到该钩子函数，则实现，若不需要则留空。\n\n如需要用到临界区，防止嵌套中断发生，nrfx_glue.h文件如下：\n\n```C\n/**\n * @brief Macro for entering into a critical section.\n */\n#define NRFX_CRITICAL_SECTION_ENTER() {unsigned int ctx; ctx = nrfx_enter_critical();\n\n/**\n * @brief Macro for exiting from a critical section.\n */\n#define NRFX_CRITICAL_SECTION_EXIT() nrfx_exit_critical(ctx);}\n```\n\n如不需要用到临界区，不考虑嵌套中断发生的情况，nrfx_glue.h文件如下：\n\n```C\n/**\n * @brief Macro for entering into a critical section.\n */\n#define NRFX_CRITICAL_SECTION_ENTER() \n\n/**\n * @brief Macro for exiting from a critical section.\n */\n#define NRFX_CRITICAL_SECTION_EXIT() \n```\n\n\n**nrfx_log.h**  \n同上\n\n**CMSIS/include**  \n\n根据nrfx根目录README提示，可用doxygen生成文档，生成的文档中有下图红框要求。直接[下载](https://github.com/ARM-software/CMSIS/tree/master/CMSIS/Include)该文件夹即可，不需要修改。\n\n![](cmsis_include.png)\n\n## 1.2. rt-thread构建环境\n\n了解nrfx后，接下来就要将其与rt-thread的构建环境关联起来。\n\n### 1.2.1. 创建bsp文件夹\n\n在bsp目录下创建文件夹myboard，即`rt-thread\\bsp\\myboard`。\n\n\n### 1.2.2. 添加bsp的模板工程\n\n> [rt-thread官方NOTE](https://www.rt-thread.org/document/site/programming-manual/scons/scons/)：要生成 MDK 或者 IAR 的工程文件，前提条件是 BSP 目录存在一个工程模版文件，然后 scons 才会根据这份模版文件加入相关的源码，头文件搜索路径，编译参数，链接参数等。而至于这个工程是针对哪颗芯片的，则直接由这份工程模版文件指定。所以大多数情况下，这个模版文件是一份空的工程文件，用于辅助 SCons 生成 project.uvprojx 或者 project.eww。\n\n在调用`scons --target=mdk5`前，需在`rt-thread\\bsp\\myboard`先提供一个mdk模板工程：\n\n下面简单演示模板工程创建过程。\n\n![](create_template_mdk.gif)\n\n### 1.2.3. 添加bsp的Kconfig\n\n将`rt-thread\\bsp\\stm32f10x\\Kconfig`搬运到myboard目录下，删除Kconfig文件中不需要部分。\n\n```\nconfig SOC_STM32F1\nbool\nselect ARCH_ARM_CORTEX_M3\ndefault y\nsource \"$BSP_DIR/drivers/Kconfig\"\n```\n\n若在myboard目录下执行menuconfig，则menuconfig会根据`rt-thread\\bsp\\myboard\\Kconfig`中的语句生成`rt-thread\\bsp\\myboard\\rtconfig.h`，该头文件包含各种宏定义。\n\n`rt-thread\\bsp\\myboard\\Kconfig`文件可通过source语句引用其他目录下的Kconfig文件，协助其生成所需的宏定义，如以下例子：\n\n\n- Kconfig文件的目录路径：\n\n```\n rt-thread\n ├──Kconfig             # root Kconfig \n ├──src\n │   └──Kconfig         # kernal src Kconfig\n └──bsp         \n     └──myboard\n           └──Kconfig   # bsp Kconfig\n```\n\n- `rt-thread\\bsp\\myboard\\Kconfig`引用`rt-thread\\Kconfig`语句：\n\n```\nconfig RTT_DIR\n    string\n    option env=\"RTT_ROOT\"\n    default \"../..\"\n\nsource \"$RTT_DIR/Kconfig\"  \n```\n\n- `rt-thread\\Kconfig`引用`rt-thread\\src\\Kconfig`语句：\n\n```\nsource \"$RTT_DIR/src/Kconfig\"\n```\n\n- `rt-thread\\src\\Kconfig`协助生成宏定义内容：\n\n```\nconfig RT_TICK_PER_SECOND\n    int \"Tick frequency, Hz\"\n    range 10 1000\n    default 100\n    help\n        System's tick frequency, Hz.\n```\n\n- 在myboard目录下执行menuconfig配置后，会在`rt-thread\\bsp\\myboard\\rtconfig.h`生成如下宏定义：\n\n```C\n#ifndef RT_CONFIG_H__\n#define RT_CONFIG_H__\n\n#define RT_TICK_PER_SECOND 100\n\n#endif\n```\n\n- 最后其他`.c`文件可引用该头文件，并使用`RT_TICK_PER_SECOND`宏定义。实现在`rt-thread\\bsp\\myboard`用menuconfig就可以配置整个工程的静态设置，如：\n\n```C\n#include <rtconfig.h>\n\nvoid SystemClock_Config(void)\n{\n    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n    NVIC_SetPriority(SysTick_IRQn, 0);\n}\n```\n\n### 1.2.4. 添加bsp的rtconfig.py\n\n将`rt-thread\\bsp\\nrf52832\\rtconfig.py`搬运到myboard目录下。\n\n当调用`sconsc --target=mdk5`生成mdk工程时候，脚本会根据`rt-thread\\bsp\\myboard\\rtconfig.py`文件中的变量`CPU='cortex-m4'`选择对应的文件添加进工程，如下图针对性添加了m4内核的上下文切换文件。\n\n![](rtconfig_keil.png)\n\n### 1.2.5. 添加bsp的SConscript/SConstruct\n\n将`rt-thread\\bsp\\nrf52832\\SConscript`和`rt-thread\\bsp\\nrf52832\\SConstruct`搬运到myboard目录下。\n\n删除SConscript文件中不需要部分。\n\n```\nobjs = objs + SConscript(os.path.join(cwd, 'nRF5_SDK_13.0.0_04a0bfd/components/SConscript'))\n```\n\n### 1.2.6. 添加nrfx\n\n参考官方的[做法](https://github.com/Zero-Free/nrf52832-nimble/tree/master/nordic)创建一个nordic文件夹，并在`myboard\\nordic`目录下添加以下内容：\n1. `CMSIS/include`文件夹\n2. `nrfx`文件夹\n3. SConscript文件\n\n### 1.2.7. 添加设备驱动实现\n\n参考官方的[做法](https://github.com/Zero-Free/nrf52832-nimble/tree/master/drivers)创建一个drivers文件夹，并在`myboard\\drivers`目录下添加以下内容：\n1. board.c和board.h\n2. drv_gpio.c和drv_gpio.h\n3. drv_uart.c和drv_uart.h\n4. SConscript文件\n\n### 1.2.8. 添加应用层代码\n\n参考官方的[做法](https://github.com/Zero-Free/nrf52832-nimble/tree/master/applications)创建一个applications文件夹，并在`myboard\\applications`目录下添加以下内容：\n1. application.c\n2. SConscript文件\n\n其中application.c文件的main函数中包含打印hello world的代码，至于是如何从上电运行到main函数的，可参考[启动流程](https://www.rt-thread.org/document/site/programming-manual/basic/basic/#rt-thread_1)。\n\n## 1.3. 验证环境构建结果\n\n[myboard文件夹下载地址](https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_without_nimble)\n\n至此，最简洁的功能移植已经完成，后面验证是否移植成功，若成功串口助手将打印hello world。\n\n进入`rt-thread\\bsp\\myboard`路径下，右键打开env。\n\n1. 用usb线将板子与PC连接\n2. 验证menuconfig功能，同时配置console名字\n3. 验证scons --target=mdk5\n4. 编译，烧录，观察串口打印信息\n\n![](port_done.gif)\n\n> NOTE：rt_kprintf依赖rt_console_set_device函数  \n1、若用rt_kprintf函数打印信息，则需要一个标记为`console设备`的通信接口设备。  \n2、rt_console_set_device(console_name)函数从众多已注册通信接口设备中找到与参数console_name相同名字的设备，并将该设备标记为`console设备`。  \n3、rt_hw_serial_register(uart0)函数注册一个名字为`uart0`的通信接口设备。  \n所以生成mdk工程前，需要用menuconfig配置console_name为`uart0`，否则rt_kprintf就会由于找不到通信接口设备，导致无法打印信息。\n\n\n","source":"_posts/rtt-nimble揭秘系列——移植bsp（2）.md","raw":"---\ntitle: rtt+nimble揭秘系列——移植bsp（2）\ndate: 2019-10-09 00:24:28\ntags:\n- rtthread\n- nimble\n\ncategories:\n- 一得之见\n---\n\n为你的bsp建立一个干净的项目框架。\n<!-- more --> \n\n前言\n===\n\n博主不喜欢从零开始造轮子，但是有“不试一下鬼知道做了什么”强迫症，因此钟爱搬运移植文件，用一些土方法来理清软件之间的关系以及换一个平台怎么办的思路。\n\n移植目标：移植rt-thread到开发板上，并通过串口打印hello world。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 建立项目框架](#1-建立项目框架)\n    - [1.1. 认识nrfx](#11-认识nrfx)\n    - [1.2. rt-thread构建环境](#12-rt-thread构建环境)\n        - [1.2.1. 创建bsp文件夹](#121-创建bsp文件夹)\n        - [1.2.2. 添加bsp的模板工程](#122-添加bsp的模板工程)\n        - [1.2.3. 添加bsp的Kconfig](#123-添加bsp的kconfig)\n        - [1.2.4. 添加bsp的rtconfig.py](#124-添加bsp的rtconfigpy)\n        - [1.2.5. 添加bsp的SConscript/SConstruct](#125-添加bsp的sconscriptsconstruct)\n        - [1.2.6. 添加nrfx](#126-添加nrfx)\n        - [1.2.7. 添加设备驱动实现](#127-添加设备驱动实现)\n        - [1.2.8. 添加应用层代码](#128-添加应用层代码)\n    - [1.3. 验证环境构建结果](#13-验证环境构建结果)\n\n<!-- /TOC -->\n\n# 1. 建立项目框架\n\n## 1.1. 认识nrfx\n\n文件夹路径：nRF5_SDK_15.3.0_59ac345\\modules\\nrfx\n\nnrfx由nordic提供的一系列外设驱动组成，无需集成厚重的标准SDK就能把芯片跑起来，是一个轻量级的驱动库。\n\n移植只需要关注以下内容：\n- 芯片类型宏定义\n- nrfx_config.h\n- nrfx_glue.h\n- nrfx_log.h\n- CMSIS/include\n\n**芯片类型宏定义**：  \n在编译阶段必须加入一款芯片类型宏定义，否则编译会报错，后面会在SConscript中加入芯片类型宏定义。\n\n```C\n/* Device selection for device includes. */\n#if defined (NRF51)\n    #include \"nrf51.h\"\n    #include \"nrf51_bitfields.h\"\n    #include \"nrf51_deprecated.h\"\n#elif defined (NRF52810_XXAA)\n    #include \"nrf52810.h\"\n    #include \"nrf52810_bitfields.h\"\n    #include \"nrf51_to_nrf52810.h\"\n    #include \"nrf52_to_nrf52810.h\"\n#elif defined (NRF52811_XXAA)\n    #include \"nrf52811.h\"\n    #include \"nrf52811_bitfields.h\"  \n    #include \"nrf51_to_nrf52810.h\"\n    #include \"nrf52_to_nrf52810.h\"\n    #include \"nrf52810_to_nrf52811.h\" \n#elif defined (NRF52832_XXAA) || defined (NRF52832_XXAB)\n    #include \"nrf52.h\"\n    #include \"nrf52_bitfields.h\"\n    #include \"nrf51_to_nrf52.h\"\n    #include \"nrf52_name_change.h\"\n#elif defined (NRF52840_XXAA)\n    #include \"nrf52840.h\"\n    #include \"nrf52840_bitfields.h\"\n    #include \"nrf51_to_nrf52840.h\"\n    #include \"nrf52_to_nrf52840.h\"\n    \n#elif defined (NRF9160_XXAA)\n    #include \"nrf9160.h\"\n    #include \"nrf9160_bitfields.h\"\n    \n#else\n    #error \"Device must be defined. See nrf.h.\"\n#endif /* NRF51, NRF52810_XXAA, NRF52811_XXAA, NRF52832_XXAA, NRF52832_XXAB, NRF52840_XXAA, NRF9160_XXAA */\n```\n\n**nrfx_config.h**:  \n该文件可以配置nrfx驱动，可以在keil在界面配置，如下图所示。\n\n![](nrfx_config.png)\n\n**nrfx_glue.h**  \n该文件由`未实现的宏定义`组成，`未实现宏定义`可以看成`钩子函数`，nrfx驱动代码会调用这些`钩子函数`，如果需要用到该钩子函数，则实现，若不需要则留空。\n\n如需要用到临界区，防止嵌套中断发生，nrfx_glue.h文件如下：\n\n```C\n/**\n * @brief Macro for entering into a critical section.\n */\n#define NRFX_CRITICAL_SECTION_ENTER() {unsigned int ctx; ctx = nrfx_enter_critical();\n\n/**\n * @brief Macro for exiting from a critical section.\n */\n#define NRFX_CRITICAL_SECTION_EXIT() nrfx_exit_critical(ctx);}\n```\n\n如不需要用到临界区，不考虑嵌套中断发生的情况，nrfx_glue.h文件如下：\n\n```C\n/**\n * @brief Macro for entering into a critical section.\n */\n#define NRFX_CRITICAL_SECTION_ENTER() \n\n/**\n * @brief Macro for exiting from a critical section.\n */\n#define NRFX_CRITICAL_SECTION_EXIT() \n```\n\n\n**nrfx_log.h**  \n同上\n\n**CMSIS/include**  \n\n根据nrfx根目录README提示，可用doxygen生成文档，生成的文档中有下图红框要求。直接[下载](https://github.com/ARM-software/CMSIS/tree/master/CMSIS/Include)该文件夹即可，不需要修改。\n\n![](cmsis_include.png)\n\n## 1.2. rt-thread构建环境\n\n了解nrfx后，接下来就要将其与rt-thread的构建环境关联起来。\n\n### 1.2.1. 创建bsp文件夹\n\n在bsp目录下创建文件夹myboard，即`rt-thread\\bsp\\myboard`。\n\n\n### 1.2.2. 添加bsp的模板工程\n\n> [rt-thread官方NOTE](https://www.rt-thread.org/document/site/programming-manual/scons/scons/)：要生成 MDK 或者 IAR 的工程文件，前提条件是 BSP 目录存在一个工程模版文件，然后 scons 才会根据这份模版文件加入相关的源码，头文件搜索路径，编译参数，链接参数等。而至于这个工程是针对哪颗芯片的，则直接由这份工程模版文件指定。所以大多数情况下，这个模版文件是一份空的工程文件，用于辅助 SCons 生成 project.uvprojx 或者 project.eww。\n\n在调用`scons --target=mdk5`前，需在`rt-thread\\bsp\\myboard`先提供一个mdk模板工程：\n\n下面简单演示模板工程创建过程。\n\n![](create_template_mdk.gif)\n\n### 1.2.3. 添加bsp的Kconfig\n\n将`rt-thread\\bsp\\stm32f10x\\Kconfig`搬运到myboard目录下，删除Kconfig文件中不需要部分。\n\n```\nconfig SOC_STM32F1\nbool\nselect ARCH_ARM_CORTEX_M3\ndefault y\nsource \"$BSP_DIR/drivers/Kconfig\"\n```\n\n若在myboard目录下执行menuconfig，则menuconfig会根据`rt-thread\\bsp\\myboard\\Kconfig`中的语句生成`rt-thread\\bsp\\myboard\\rtconfig.h`，该头文件包含各种宏定义。\n\n`rt-thread\\bsp\\myboard\\Kconfig`文件可通过source语句引用其他目录下的Kconfig文件，协助其生成所需的宏定义，如以下例子：\n\n\n- Kconfig文件的目录路径：\n\n```\n rt-thread\n ├──Kconfig             # root Kconfig \n ├──src\n │   └──Kconfig         # kernal src Kconfig\n └──bsp         \n     └──myboard\n           └──Kconfig   # bsp Kconfig\n```\n\n- `rt-thread\\bsp\\myboard\\Kconfig`引用`rt-thread\\Kconfig`语句：\n\n```\nconfig RTT_DIR\n    string\n    option env=\"RTT_ROOT\"\n    default \"../..\"\n\nsource \"$RTT_DIR/Kconfig\"  \n```\n\n- `rt-thread\\Kconfig`引用`rt-thread\\src\\Kconfig`语句：\n\n```\nsource \"$RTT_DIR/src/Kconfig\"\n```\n\n- `rt-thread\\src\\Kconfig`协助生成宏定义内容：\n\n```\nconfig RT_TICK_PER_SECOND\n    int \"Tick frequency, Hz\"\n    range 10 1000\n    default 100\n    help\n        System's tick frequency, Hz.\n```\n\n- 在myboard目录下执行menuconfig配置后，会在`rt-thread\\bsp\\myboard\\rtconfig.h`生成如下宏定义：\n\n```C\n#ifndef RT_CONFIG_H__\n#define RT_CONFIG_H__\n\n#define RT_TICK_PER_SECOND 100\n\n#endif\n```\n\n- 最后其他`.c`文件可引用该头文件，并使用`RT_TICK_PER_SECOND`宏定义。实现在`rt-thread\\bsp\\myboard`用menuconfig就可以配置整个工程的静态设置，如：\n\n```C\n#include <rtconfig.h>\n\nvoid SystemClock_Config(void)\n{\n    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n    NVIC_SetPriority(SysTick_IRQn, 0);\n}\n```\n\n### 1.2.4. 添加bsp的rtconfig.py\n\n将`rt-thread\\bsp\\nrf52832\\rtconfig.py`搬运到myboard目录下。\n\n当调用`sconsc --target=mdk5`生成mdk工程时候，脚本会根据`rt-thread\\bsp\\myboard\\rtconfig.py`文件中的变量`CPU='cortex-m4'`选择对应的文件添加进工程，如下图针对性添加了m4内核的上下文切换文件。\n\n![](rtconfig_keil.png)\n\n### 1.2.5. 添加bsp的SConscript/SConstruct\n\n将`rt-thread\\bsp\\nrf52832\\SConscript`和`rt-thread\\bsp\\nrf52832\\SConstruct`搬运到myboard目录下。\n\n删除SConscript文件中不需要部分。\n\n```\nobjs = objs + SConscript(os.path.join(cwd, 'nRF5_SDK_13.0.0_04a0bfd/components/SConscript'))\n```\n\n### 1.2.6. 添加nrfx\n\n参考官方的[做法](https://github.com/Zero-Free/nrf52832-nimble/tree/master/nordic)创建一个nordic文件夹，并在`myboard\\nordic`目录下添加以下内容：\n1. `CMSIS/include`文件夹\n2. `nrfx`文件夹\n3. SConscript文件\n\n### 1.2.7. 添加设备驱动实现\n\n参考官方的[做法](https://github.com/Zero-Free/nrf52832-nimble/tree/master/drivers)创建一个drivers文件夹，并在`myboard\\drivers`目录下添加以下内容：\n1. board.c和board.h\n2. drv_gpio.c和drv_gpio.h\n3. drv_uart.c和drv_uart.h\n4. SConscript文件\n\n### 1.2.8. 添加应用层代码\n\n参考官方的[做法](https://github.com/Zero-Free/nrf52832-nimble/tree/master/applications)创建一个applications文件夹，并在`myboard\\applications`目录下添加以下内容：\n1. application.c\n2. SConscript文件\n\n其中application.c文件的main函数中包含打印hello world的代码，至于是如何从上电运行到main函数的，可参考[启动流程](https://www.rt-thread.org/document/site/programming-manual/basic/basic/#rt-thread_1)。\n\n## 1.3. 验证环境构建结果\n\n[myboard文件夹下载地址](https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_without_nimble)\n\n至此，最简洁的功能移植已经完成，后面验证是否移植成功，若成功串口助手将打印hello world。\n\n进入`rt-thread\\bsp\\myboard`路径下，右键打开env。\n\n1. 用usb线将板子与PC连接\n2. 验证menuconfig功能，同时配置console名字\n3. 验证scons --target=mdk5\n4. 编译，烧录，观察串口打印信息\n\n![](port_done.gif)\n\n> NOTE：rt_kprintf依赖rt_console_set_device函数  \n1、若用rt_kprintf函数打印信息，则需要一个标记为`console设备`的通信接口设备。  \n2、rt_console_set_device(console_name)函数从众多已注册通信接口设备中找到与参数console_name相同名字的设备，并将该设备标记为`console设备`。  \n3、rt_hw_serial_register(uart0)函数注册一个名字为`uart0`的通信接口设备。  \n所以生成mdk工程前，需要用menuconfig配置console_name为`uart0`，否则rt_kprintf就会由于找不到通信接口设备，导致无法打印信息。\n\n\n","slug":"rtt-nimble揭秘系列——移植bsp（2）","published":1,"updated":"2019-10-23T05:10:56.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8q7n0010gcg80gh53b3j","content":"<p>为你的bsp建立一个干净的项目框架。<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>博主不喜欢从零开始造轮子，但是有“不试一下鬼知道做了什么”强迫症，因此钟爱搬运移植文件，用一些土方法来理清软件之间的关系以及换一个平台怎么办的思路。</p>\n<p>移植目标：移植rt-thread到开发板上，并通过串口打印hello world。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-建立项目框架\">1. 建立项目框架</a><ul>\n<li><a href=\"#11-认识nrfx\">1.1. 认识nrfx</a></li>\n<li><a href=\"#12-rt-thread构建环境\">1.2. rt-thread构建环境</a><ul>\n<li><a href=\"#121-创建bsp文件夹\">1.2.1. 创建bsp文件夹</a></li>\n<li><a href=\"#122-添加bsp的模板工程\">1.2.2. 添加bsp的模板工程</a></li>\n<li><a href=\"#123-添加bsp的kconfig\">1.2.3. 添加bsp的Kconfig</a></li>\n<li><a href=\"#124-添加bsp的rtconfigpy\">1.2.4. 添加bsp的rtconfig.py</a></li>\n<li><a href=\"#125-添加bsp的sconscriptsconstruct\">1.2.5. 添加bsp的SConscript/SConstruct</a></li>\n<li><a href=\"#126-添加nrfx\">1.2.6. 添加nrfx</a></li>\n<li><a href=\"#127-添加设备驱动实现\">1.2.7. 添加设备驱动实现</a></li>\n<li><a href=\"#128-添加应用层代码\">1.2.8. 添加应用层代码</a></li>\n</ul>\n</li>\n<li><a href=\"#13-验证环境构建结果\">1.3. 验证环境构建结果</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-建立项目框架\"><a href=\"#1-建立项目框架\" class=\"headerlink\" title=\"1. 建立项目框架\"></a>1. 建立项目框架</h1><h2 id=\"1-1-认识nrfx\"><a href=\"#1-1-认识nrfx\" class=\"headerlink\" title=\"1.1. 认识nrfx\"></a>1.1. 认识nrfx</h2><p>文件夹路径：nRF5_SDK_15.3.0_59ac345\\modules\\nrfx</p>\n<p>nrfx由nordic提供的一系列外设驱动组成，无需集成厚重的标准SDK就能把芯片跑起来，是一个轻量级的驱动库。</p>\n<p>移植只需要关注以下内容：</p>\n<ul>\n<li>芯片类型宏定义</li>\n<li>nrfx_config.h</li>\n<li>nrfx_glue.h</li>\n<li>nrfx_log.h</li>\n<li>CMSIS/include</li>\n</ul>\n<p><strong>芯片类型宏定义</strong>：<br>在编译阶段必须加入一款芯片类型宏定义，否则编译会报错，后面会在SConscript中加入芯片类型宏定义。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Device selection for device includes. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined (NRF51)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_bitfields.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_deprecated.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF52810_XXAA)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52810.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52810_bitfields.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_to_nrf52810.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_to_nrf52810.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF52811_XXAA)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52811.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52811_bitfields.h\"</span>  </span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_to_nrf52810.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_to_nrf52810.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52810_to_nrf52811.h\"</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF52832_XXAA) || defined (NRF52832_XXAB)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_bitfields.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_to_nrf52.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_name_change.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF52840_XXAA)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52840.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52840_bitfields.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_to_nrf52840.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_to_nrf52840.h\"</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF9160_XXAA)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf9160.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf9160_bitfields.h\"</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">error</span> <span class=\"meta-string\">\"Device must be defined. See nrf.h.\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* NRF51, NRF52810_XXAA, NRF52811_XXAA, NRF52832_XXAA, NRF52832_XXAB, NRF52840_XXAA, NRF9160_XXAA */</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>nrfx_config.h</strong>:<br>该文件可以配置nrfx驱动，可以在keil在界面配置，如下图所示。</p>\n<p><img src=\"nrfx_config.png\" alt></p>\n<p><strong>nrfx_glue.h</strong><br>该文件由<code>未实现的宏定义</code>组成，<code>未实现宏定义</code>可以看成<code>钩子函数</code>，nrfx驱动代码会调用这些<code>钩子函数</code>，如果需要用到该钩子函数，则实现，若不需要则留空。</p>\n<p>如需要用到临界区，防止嵌套中断发生，nrfx_glue.h文件如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Macro for entering into a critical section.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NRFX_CRITICAL_SECTION_ENTER() &#123;unsigned int ctx; ctx = nrfx_enter_critical();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Macro for exiting from a critical section.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NRFX_CRITICAL_SECTION_EXIT() nrfx_exit_critical(ctx);&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如不需要用到临界区，不考虑嵌套中断发生的情况，nrfx_glue.h文件如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Macro for entering into a critical section.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NRFX_CRITICAL_SECTION_ENTER() </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Macro for exiting from a critical section.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NRFX_CRITICAL_SECTION_EXIT()</span></span><br></pre></td></tr></table></figure>\n<p><strong>nrfx_log.h</strong><br>同上</p>\n<p><strong>CMSIS/include</strong>  </p>\n<p>根据nrfx根目录README提示，可用doxygen生成文档，生成的文档中有下图红框要求。直接<a href=\"https://github.com/ARM-software/CMSIS/tree/master/CMSIS/Include\" target=\"_blank\" rel=\"noopener\">下载</a>该文件夹即可，不需要修改。</p>\n<p><img src=\"cmsis_include.png\" alt></p>\n<h2 id=\"1-2-rt-thread构建环境\"><a href=\"#1-2-rt-thread构建环境\" class=\"headerlink\" title=\"1.2. rt-thread构建环境\"></a>1.2. rt-thread构建环境</h2><p>了解nrfx后，接下来就要将其与rt-thread的构建环境关联起来。</p>\n<h3 id=\"1-2-1-创建bsp文件夹\"><a href=\"#1-2-1-创建bsp文件夹\" class=\"headerlink\" title=\"1.2.1. 创建bsp文件夹\"></a>1.2.1. 创建bsp文件夹</h3><p>在bsp目录下创建文件夹myboard，即<code>rt-thread\\bsp\\myboard</code>。</p>\n<h3 id=\"1-2-2-添加bsp的模板工程\"><a href=\"#1-2-2-添加bsp的模板工程\" class=\"headerlink\" title=\"1.2.2. 添加bsp的模板工程\"></a>1.2.2. 添加bsp的模板工程</h3><blockquote>\n<p><a href=\"https://www.rt-thread.org/document/site/programming-manual/scons/scons/\" target=\"_blank\" rel=\"noopener\">rt-thread官方NOTE</a>：要生成 MDK 或者 IAR 的工程文件，前提条件是 BSP 目录存在一个工程模版文件，然后 scons 才会根据这份模版文件加入相关的源码，头文件搜索路径，编译参数，链接参数等。而至于这个工程是针对哪颗芯片的，则直接由这份工程模版文件指定。所以大多数情况下，这个模版文件是一份空的工程文件，用于辅助 SCons 生成 project.uvprojx 或者 project.eww。</p>\n</blockquote>\n<p>在调用<code>scons --target=mdk5</code>前，需在<code>rt-thread\\bsp\\myboard</code>先提供一个mdk模板工程：</p>\n<p>下面简单演示模板工程创建过程。</p>\n<p><img src=\"create_template_mdk.gif\" alt></p>\n<h3 id=\"1-2-3-添加bsp的Kconfig\"><a href=\"#1-2-3-添加bsp的Kconfig\" class=\"headerlink\" title=\"1.2.3. 添加bsp的Kconfig\"></a>1.2.3. 添加bsp的Kconfig</h3><p>将<code>rt-thread\\bsp\\stm32f10x\\Kconfig</code>搬运到myboard目录下，删除Kconfig文件中不需要部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config SOC_STM32F1</span><br><span class=\"line\">bool</span><br><span class=\"line\">select ARCH_ARM_CORTEX_M3</span><br><span class=\"line\">default y</span><br><span class=\"line\">source &quot;$BSP_DIR/drivers/Kconfig&quot;</span><br></pre></td></tr></table></figure>\n<p>若在myboard目录下执行menuconfig，则menuconfig会根据<code>rt-thread\\bsp\\myboard\\Kconfig</code>中的语句生成<code>rt-thread\\bsp\\myboard\\rtconfig.h</code>，该头文件包含各种宏定义。</p>\n<p><code>rt-thread\\bsp\\myboard\\Kconfig</code>文件可通过source语句引用其他目录下的Kconfig文件，协助其生成所需的宏定义，如以下例子：</p>\n<ul>\n<li>Kconfig文件的目录路径：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rt-thread</span><br><span class=\"line\">├──Kconfig             # root Kconfig </span><br><span class=\"line\">├──src</span><br><span class=\"line\">│   └──Kconfig         # kernal src Kconfig</span><br><span class=\"line\">└──bsp         </span><br><span class=\"line\">    └──myboard</span><br><span class=\"line\">          └──Kconfig   # bsp Kconfig</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>rt-thread\\bsp\\myboard\\Kconfig</code>引用<code>rt-thread\\Kconfig</code>语句：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config RTT_DIR</span><br><span class=\"line\">    string</span><br><span class=\"line\">    option env=&quot;RTT_ROOT&quot;</span><br><span class=\"line\">    default &quot;../..&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">source &quot;$RTT_DIR/Kconfig&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>rt-thread\\Kconfig</code>引用<code>rt-thread\\src\\Kconfig</code>语句：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &quot;$RTT_DIR/src/Kconfig&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>rt-thread\\src\\Kconfig</code>协助生成宏定义内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config RT_TICK_PER_SECOND</span><br><span class=\"line\">    int &quot;Tick frequency, Hz&quot;</span><br><span class=\"line\">    range 10 1000</span><br><span class=\"line\">    default 100</span><br><span class=\"line\">    help</span><br><span class=\"line\">        System&apos;s tick frequency, Hz.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在myboard目录下执行menuconfig配置后，会在<code>rt-thread\\bsp\\myboard\\rtconfig.h</code>生成如下宏定义：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> RT_CONFIG_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RT_CONFIG_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RT_TICK_PER_SECOND 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>最后其他<code>.c</code>文件可引用该头文件，并使用<code>RT_TICK_PER_SECOND</code>宏定义。实现在<code>rt-thread\\bsp\\myboard</code>用menuconfig就可以配置整个工程的静态设置，如：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;rtconfig.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SystemClock_Config</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);</span><br><span class=\"line\">    NVIC_SetPriority(SysTick_IRQn, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-4-添加bsp的rtconfig-py\"><a href=\"#1-2-4-添加bsp的rtconfig-py\" class=\"headerlink\" title=\"1.2.4. 添加bsp的rtconfig.py\"></a>1.2.4. 添加bsp的rtconfig.py</h3><p>将<code>rt-thread\\bsp\\nrf52832\\rtconfig.py</code>搬运到myboard目录下。</p>\n<p>当调用<code>sconsc --target=mdk5</code>生成mdk工程时候，脚本会根据<code>rt-thread\\bsp\\myboard\\rtconfig.py</code>文件中的变量<code>CPU=&#39;cortex-m4&#39;</code>选择对应的文件添加进工程，如下图针对性添加了m4内核的上下文切换文件。</p>\n<p><img src=\"rtconfig_keil.png\" alt></p>\n<h3 id=\"1-2-5-添加bsp的SConscript-SConstruct\"><a href=\"#1-2-5-添加bsp的SConscript-SConstruct\" class=\"headerlink\" title=\"1.2.5. 添加bsp的SConscript/SConstruct\"></a>1.2.5. 添加bsp的SConscript/SConstruct</h3><p>将<code>rt-thread\\bsp\\nrf52832\\SConscript</code>和<code>rt-thread\\bsp\\nrf52832\\SConstruct</code>搬运到myboard目录下。</p>\n<p>删除SConscript文件中不需要部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objs = objs + SConscript(os.path.join(cwd, &apos;nRF5_SDK_13.0.0_04a0bfd/components/SConscript&apos;))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-6-添加nrfx\"><a href=\"#1-2-6-添加nrfx\" class=\"headerlink\" title=\"1.2.6. 添加nrfx\"></a>1.2.6. 添加nrfx</h3><p>参考官方的<a href=\"https://github.com/Zero-Free/nrf52832-nimble/tree/master/nordic\" target=\"_blank\" rel=\"noopener\">做法</a>创建一个nordic文件夹，并在<code>myboard\\nordic</code>目录下添加以下内容：</p>\n<ol>\n<li><code>CMSIS/include</code>文件夹</li>\n<li><code>nrfx</code>文件夹</li>\n<li>SConscript文件</li>\n</ol>\n<h3 id=\"1-2-7-添加设备驱动实现\"><a href=\"#1-2-7-添加设备驱动实现\" class=\"headerlink\" title=\"1.2.7. 添加设备驱动实现\"></a>1.2.7. 添加设备驱动实现</h3><p>参考官方的<a href=\"https://github.com/Zero-Free/nrf52832-nimble/tree/master/drivers\" target=\"_blank\" rel=\"noopener\">做法</a>创建一个drivers文件夹，并在<code>myboard\\drivers</code>目录下添加以下内容：</p>\n<ol>\n<li>board.c和board.h</li>\n<li>drv_gpio.c和drv_gpio.h</li>\n<li>drv_uart.c和drv_uart.h</li>\n<li>SConscript文件</li>\n</ol>\n<h3 id=\"1-2-8-添加应用层代码\"><a href=\"#1-2-8-添加应用层代码\" class=\"headerlink\" title=\"1.2.8. 添加应用层代码\"></a>1.2.8. 添加应用层代码</h3><p>参考官方的<a href=\"https://github.com/Zero-Free/nrf52832-nimble/tree/master/applications\" target=\"_blank\" rel=\"noopener\">做法</a>创建一个applications文件夹，并在<code>myboard\\applications</code>目录下添加以下内容：</p>\n<ol>\n<li>application.c</li>\n<li>SConscript文件</li>\n</ol>\n<p>其中application.c文件的main函数中包含打印hello world的代码，至于是如何从上电运行到main函数的，可参考<a href=\"https://www.rt-thread.org/document/site/programming-manual/basic/basic/#rt-thread_1\" target=\"_blank\" rel=\"noopener\">启动流程</a>。</p>\n<h2 id=\"1-3-验证环境构建结果\"><a href=\"#1-3-验证环境构建结果\" class=\"headerlink\" title=\"1.3. 验证环境构建结果\"></a>1.3. 验证环境构建结果</h2><p><a href=\"https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_without_nimble\" target=\"_blank\" rel=\"noopener\">myboard文件夹下载地址</a></p>\n<p>至此，最简洁的功能移植已经完成，后面验证是否移植成功，若成功串口助手将打印hello world。</p>\n<p>进入<code>rt-thread\\bsp\\myboard</code>路径下，右键打开env。</p>\n<ol>\n<li>用usb线将板子与PC连接</li>\n<li>验证menuconfig功能，同时配置console名字</li>\n<li>验证scons –target=mdk5</li>\n<li>编译，烧录，观察串口打印信息</li>\n</ol>\n<p><img src=\"port_done.gif\" alt></p>\n<blockquote>\n<p>NOTE：rt_kprintf依赖rt_console_set_device函数<br>1、若用rt_kprintf函数打印信息，则需要一个标记为<code>console设备</code>的通信接口设备。<br>2、rt_console_set_device(console_name)函数从众多已注册通信接口设备中找到与参数console_name相同名字的设备，并将该设备标记为<code>console设备</code>。<br>3、rt_hw_serial_register(uart0)函数注册一个名字为<code>uart0</code>的通信接口设备。<br>所以生成mdk工程前，需要用menuconfig配置console_name为<code>uart0</code>，否则rt_kprintf就会由于找不到通信接口设备，导致无法打印信息。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>为你的bsp建立一个干净的项目框架。<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>博主不喜欢从零开始造轮子，但是有“不试一下鬼知道做了什么”强迫症，因此钟爱搬运移植文件，用一些土方法来理清软件之间的关系以及换一个平台怎么办的思路。</p>\n<p>移植目标：移植rt-thread到开发板上，并通过串口打印hello world。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-建立项目框架\">1. 建立项目框架</a><ul>\n<li><a href=\"#11-认识nrfx\">1.1. 认识nrfx</a></li>\n<li><a href=\"#12-rt-thread构建环境\">1.2. rt-thread构建环境</a><ul>\n<li><a href=\"#121-创建bsp文件夹\">1.2.1. 创建bsp文件夹</a></li>\n<li><a href=\"#122-添加bsp的模板工程\">1.2.2. 添加bsp的模板工程</a></li>\n<li><a href=\"#123-添加bsp的kconfig\">1.2.3. 添加bsp的Kconfig</a></li>\n<li><a href=\"#124-添加bsp的rtconfigpy\">1.2.4. 添加bsp的rtconfig.py</a></li>\n<li><a href=\"#125-添加bsp的sconscriptsconstruct\">1.2.5. 添加bsp的SConscript/SConstruct</a></li>\n<li><a href=\"#126-添加nrfx\">1.2.6. 添加nrfx</a></li>\n<li><a href=\"#127-添加设备驱动实现\">1.2.7. 添加设备驱动实现</a></li>\n<li><a href=\"#128-添加应用层代码\">1.2.8. 添加应用层代码</a></li>\n</ul>\n</li>\n<li><a href=\"#13-验证环境构建结果\">1.3. 验证环境构建结果</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-建立项目框架\"><a href=\"#1-建立项目框架\" class=\"headerlink\" title=\"1. 建立项目框架\"></a>1. 建立项目框架</h1><h2 id=\"1-1-认识nrfx\"><a href=\"#1-1-认识nrfx\" class=\"headerlink\" title=\"1.1. 认识nrfx\"></a>1.1. 认识nrfx</h2><p>文件夹路径：nRF5_SDK_15.3.0_59ac345\\modules\\nrfx</p>\n<p>nrfx由nordic提供的一系列外设驱动组成，无需集成厚重的标准SDK就能把芯片跑起来，是一个轻量级的驱动库。</p>\n<p>移植只需要关注以下内容：</p>\n<ul>\n<li>芯片类型宏定义</li>\n<li>nrfx_config.h</li>\n<li>nrfx_glue.h</li>\n<li>nrfx_log.h</li>\n<li>CMSIS/include</li>\n</ul>\n<p><strong>芯片类型宏定义</strong>：<br>在编译阶段必须加入一款芯片类型宏定义，否则编译会报错，后面会在SConscript中加入芯片类型宏定义。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Device selection for device includes. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined (NRF51)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_bitfields.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_deprecated.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF52810_XXAA)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52810.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52810_bitfields.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_to_nrf52810.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_to_nrf52810.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF52811_XXAA)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52811.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52811_bitfields.h\"</span>  </span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_to_nrf52810.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_to_nrf52810.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52810_to_nrf52811.h\"</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF52832_XXAA) || defined (NRF52832_XXAB)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_bitfields.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_to_nrf52.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_name_change.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF52840_XXAA)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52840.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52840_bitfields.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf51_to_nrf52840.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf52_to_nrf52840.h\"</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined (NRF9160_XXAA)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf9160.h\"</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"nrf9160_bitfields.h\"</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">error</span> <span class=\"meta-string\">\"Device must be defined. See nrf.h.\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* NRF51, NRF52810_XXAA, NRF52811_XXAA, NRF52832_XXAA, NRF52832_XXAB, NRF52840_XXAA, NRF9160_XXAA */</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>nrfx_config.h</strong>:<br>该文件可以配置nrfx驱动，可以在keil在界面配置，如下图所示。</p>\n<p><img src=\"nrfx_config.png\" alt></p>\n<p><strong>nrfx_glue.h</strong><br>该文件由<code>未实现的宏定义</code>组成，<code>未实现宏定义</code>可以看成<code>钩子函数</code>，nrfx驱动代码会调用这些<code>钩子函数</code>，如果需要用到该钩子函数，则实现，若不需要则留空。</p>\n<p>如需要用到临界区，防止嵌套中断发生，nrfx_glue.h文件如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Macro for entering into a critical section.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NRFX_CRITICAL_SECTION_ENTER() &#123;unsigned int ctx; ctx = nrfx_enter_critical();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Macro for exiting from a critical section.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NRFX_CRITICAL_SECTION_EXIT() nrfx_exit_critical(ctx);&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如不需要用到临界区，不考虑嵌套中断发生的情况，nrfx_glue.h文件如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Macro for entering into a critical section.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NRFX_CRITICAL_SECTION_ENTER() </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Macro for exiting from a critical section.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NRFX_CRITICAL_SECTION_EXIT()</span></span><br></pre></td></tr></table></figure>\n<p><strong>nrfx_log.h</strong><br>同上</p>\n<p><strong>CMSIS/include</strong>  </p>\n<p>根据nrfx根目录README提示，可用doxygen生成文档，生成的文档中有下图红框要求。直接<a href=\"https://github.com/ARM-software/CMSIS/tree/master/CMSIS/Include\" target=\"_blank\" rel=\"noopener\">下载</a>该文件夹即可，不需要修改。</p>\n<p><img src=\"cmsis_include.png\" alt></p>\n<h2 id=\"1-2-rt-thread构建环境\"><a href=\"#1-2-rt-thread构建环境\" class=\"headerlink\" title=\"1.2. rt-thread构建环境\"></a>1.2. rt-thread构建环境</h2><p>了解nrfx后，接下来就要将其与rt-thread的构建环境关联起来。</p>\n<h3 id=\"1-2-1-创建bsp文件夹\"><a href=\"#1-2-1-创建bsp文件夹\" class=\"headerlink\" title=\"1.2.1. 创建bsp文件夹\"></a>1.2.1. 创建bsp文件夹</h3><p>在bsp目录下创建文件夹myboard，即<code>rt-thread\\bsp\\myboard</code>。</p>\n<h3 id=\"1-2-2-添加bsp的模板工程\"><a href=\"#1-2-2-添加bsp的模板工程\" class=\"headerlink\" title=\"1.2.2. 添加bsp的模板工程\"></a>1.2.2. 添加bsp的模板工程</h3><blockquote>\n<p><a href=\"https://www.rt-thread.org/document/site/programming-manual/scons/scons/\" target=\"_blank\" rel=\"noopener\">rt-thread官方NOTE</a>：要生成 MDK 或者 IAR 的工程文件，前提条件是 BSP 目录存在一个工程模版文件，然后 scons 才会根据这份模版文件加入相关的源码，头文件搜索路径，编译参数，链接参数等。而至于这个工程是针对哪颗芯片的，则直接由这份工程模版文件指定。所以大多数情况下，这个模版文件是一份空的工程文件，用于辅助 SCons 生成 project.uvprojx 或者 project.eww。</p>\n</blockquote>\n<p>在调用<code>scons --target=mdk5</code>前，需在<code>rt-thread\\bsp\\myboard</code>先提供一个mdk模板工程：</p>\n<p>下面简单演示模板工程创建过程。</p>\n<p><img src=\"create_template_mdk.gif\" alt></p>\n<h3 id=\"1-2-3-添加bsp的Kconfig\"><a href=\"#1-2-3-添加bsp的Kconfig\" class=\"headerlink\" title=\"1.2.3. 添加bsp的Kconfig\"></a>1.2.3. 添加bsp的Kconfig</h3><p>将<code>rt-thread\\bsp\\stm32f10x\\Kconfig</code>搬运到myboard目录下，删除Kconfig文件中不需要部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config SOC_STM32F1</span><br><span class=\"line\">bool</span><br><span class=\"line\">select ARCH_ARM_CORTEX_M3</span><br><span class=\"line\">default y</span><br><span class=\"line\">source &quot;$BSP_DIR/drivers/Kconfig&quot;</span><br></pre></td></tr></table></figure>\n<p>若在myboard目录下执行menuconfig，则menuconfig会根据<code>rt-thread\\bsp\\myboard\\Kconfig</code>中的语句生成<code>rt-thread\\bsp\\myboard\\rtconfig.h</code>，该头文件包含各种宏定义。</p>\n<p><code>rt-thread\\bsp\\myboard\\Kconfig</code>文件可通过source语句引用其他目录下的Kconfig文件，协助其生成所需的宏定义，如以下例子：</p>\n<ul>\n<li>Kconfig文件的目录路径：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rt-thread</span><br><span class=\"line\">├──Kconfig             # root Kconfig </span><br><span class=\"line\">├──src</span><br><span class=\"line\">│   └──Kconfig         # kernal src Kconfig</span><br><span class=\"line\">└──bsp         </span><br><span class=\"line\">    └──myboard</span><br><span class=\"line\">          └──Kconfig   # bsp Kconfig</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>rt-thread\\bsp\\myboard\\Kconfig</code>引用<code>rt-thread\\Kconfig</code>语句：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config RTT_DIR</span><br><span class=\"line\">    string</span><br><span class=\"line\">    option env=&quot;RTT_ROOT&quot;</span><br><span class=\"line\">    default &quot;../..&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">source &quot;$RTT_DIR/Kconfig&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>rt-thread\\Kconfig</code>引用<code>rt-thread\\src\\Kconfig</code>语句：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &quot;$RTT_DIR/src/Kconfig&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>rt-thread\\src\\Kconfig</code>协助生成宏定义内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config RT_TICK_PER_SECOND</span><br><span class=\"line\">    int &quot;Tick frequency, Hz&quot;</span><br><span class=\"line\">    range 10 1000</span><br><span class=\"line\">    default 100</span><br><span class=\"line\">    help</span><br><span class=\"line\">        System&apos;s tick frequency, Hz.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在myboard目录下执行menuconfig配置后，会在<code>rt-thread\\bsp\\myboard\\rtconfig.h</code>生成如下宏定义：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> RT_CONFIG_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RT_CONFIG_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RT_TICK_PER_SECOND 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>最后其他<code>.c</code>文件可引用该头文件，并使用<code>RT_TICK_PER_SECOND</code>宏定义。实现在<code>rt-thread\\bsp\\myboard</code>用menuconfig就可以配置整个工程的静态设置，如：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;rtconfig.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SystemClock_Config</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);</span><br><span class=\"line\">    NVIC_SetPriority(SysTick_IRQn, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-4-添加bsp的rtconfig-py\"><a href=\"#1-2-4-添加bsp的rtconfig-py\" class=\"headerlink\" title=\"1.2.4. 添加bsp的rtconfig.py\"></a>1.2.4. 添加bsp的rtconfig.py</h3><p>将<code>rt-thread\\bsp\\nrf52832\\rtconfig.py</code>搬运到myboard目录下。</p>\n<p>当调用<code>sconsc --target=mdk5</code>生成mdk工程时候，脚本会根据<code>rt-thread\\bsp\\myboard\\rtconfig.py</code>文件中的变量<code>CPU=&#39;cortex-m4&#39;</code>选择对应的文件添加进工程，如下图针对性添加了m4内核的上下文切换文件。</p>\n<p><img src=\"rtconfig_keil.png\" alt></p>\n<h3 id=\"1-2-5-添加bsp的SConscript-SConstruct\"><a href=\"#1-2-5-添加bsp的SConscript-SConstruct\" class=\"headerlink\" title=\"1.2.5. 添加bsp的SConscript/SConstruct\"></a>1.2.5. 添加bsp的SConscript/SConstruct</h3><p>将<code>rt-thread\\bsp\\nrf52832\\SConscript</code>和<code>rt-thread\\bsp\\nrf52832\\SConstruct</code>搬运到myboard目录下。</p>\n<p>删除SConscript文件中不需要部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objs = objs + SConscript(os.path.join(cwd, &apos;nRF5_SDK_13.0.0_04a0bfd/components/SConscript&apos;))</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-6-添加nrfx\"><a href=\"#1-2-6-添加nrfx\" class=\"headerlink\" title=\"1.2.6. 添加nrfx\"></a>1.2.6. 添加nrfx</h3><p>参考官方的<a href=\"https://github.com/Zero-Free/nrf52832-nimble/tree/master/nordic\" target=\"_blank\" rel=\"noopener\">做法</a>创建一个nordic文件夹，并在<code>myboard\\nordic</code>目录下添加以下内容：</p>\n<ol>\n<li><code>CMSIS/include</code>文件夹</li>\n<li><code>nrfx</code>文件夹</li>\n<li>SConscript文件</li>\n</ol>\n<h3 id=\"1-2-7-添加设备驱动实现\"><a href=\"#1-2-7-添加设备驱动实现\" class=\"headerlink\" title=\"1.2.7. 添加设备驱动实现\"></a>1.2.7. 添加设备驱动实现</h3><p>参考官方的<a href=\"https://github.com/Zero-Free/nrf52832-nimble/tree/master/drivers\" target=\"_blank\" rel=\"noopener\">做法</a>创建一个drivers文件夹，并在<code>myboard\\drivers</code>目录下添加以下内容：</p>\n<ol>\n<li>board.c和board.h</li>\n<li>drv_gpio.c和drv_gpio.h</li>\n<li>drv_uart.c和drv_uart.h</li>\n<li>SConscript文件</li>\n</ol>\n<h3 id=\"1-2-8-添加应用层代码\"><a href=\"#1-2-8-添加应用层代码\" class=\"headerlink\" title=\"1.2.8. 添加应用层代码\"></a>1.2.8. 添加应用层代码</h3><p>参考官方的<a href=\"https://github.com/Zero-Free/nrf52832-nimble/tree/master/applications\" target=\"_blank\" rel=\"noopener\">做法</a>创建一个applications文件夹，并在<code>myboard\\applications</code>目录下添加以下内容：</p>\n<ol>\n<li>application.c</li>\n<li>SConscript文件</li>\n</ol>\n<p>其中application.c文件的main函数中包含打印hello world的代码，至于是如何从上电运行到main函数的，可参考<a href=\"https://www.rt-thread.org/document/site/programming-manual/basic/basic/#rt-thread_1\" target=\"_blank\" rel=\"noopener\">启动流程</a>。</p>\n<h2 id=\"1-3-验证环境构建结果\"><a href=\"#1-3-验证环境构建结果\" class=\"headerlink\" title=\"1.3. 验证环境构建结果\"></a>1.3. 验证环境构建结果</h2><p><a href=\"https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_without_nimble\" target=\"_blank\" rel=\"noopener\">myboard文件夹下载地址</a></p>\n<p>至此，最简洁的功能移植已经完成，后面验证是否移植成功，若成功串口助手将打印hello world。</p>\n<p>进入<code>rt-thread\\bsp\\myboard</code>路径下，右键打开env。</p>\n<ol>\n<li>用usb线将板子与PC连接</li>\n<li>验证menuconfig功能，同时配置console名字</li>\n<li>验证scons –target=mdk5</li>\n<li>编译，烧录，观察串口打印信息</li>\n</ol>\n<p><img src=\"port_done.gif\" alt></p>\n<blockquote>\n<p>NOTE：rt_kprintf依赖rt_console_set_device函数<br>1、若用rt_kprintf函数打印信息，则需要一个标记为<code>console设备</code>的通信接口设备。<br>2、rt_console_set_device(console_name)函数从众多已注册通信接口设备中找到与参数console_name相同名字的设备，并将该设备标记为<code>console设备</code>。<br>3、rt_hw_serial_register(uart0)函数注册一个名字为<code>uart0</code>的通信接口设备。<br>所以生成mdk工程前，需要用menuconfig配置console_name为<code>uart0</code>，否则rt_kprintf就会由于找不到通信接口设备，导致无法打印信息。</p>\n</blockquote>"},{"title":"博客搭建实战","date":"2019-05-10T02:00:00.000Z","top":false,"_content":"\nHexo 是一个快速、简洁且高效的博客框架，支持个性化的配置。这篇博文记录了搭建过程。\n<!-- more --> \n\n目录\n===\n<!-- TOC -->\n\n- [配置主题](#配置主题)\n- [配置风格](#配置风格)\n- [配置语言](#配置语言)\n- [配置描述](#配置描述)\n- [配置目录](#配置目录)\n- [配置头像](#配置头像)\n- [配置拉条](#配置拉条)\n- [配置社交](#配置社交)\n- [配置打赏](#配置打赏)\n- [配置菜单](#配置菜单)\n- [配置标签](#配置标签)\n- [配置分类](#配置分类)\n- [配置评论](#配置评论)\n- [配置分享](#配置分享)\n- [配置版权](#配置版权)\n- [配置脚注](#配置脚注)\n- [配置统计](#配置统计)\n- [配置搜索](#配置搜索)\n- [博文置顶](#博文置顶)\n- [博文插图](#博文插图)\n\n<!-- /TOC -->\n\n# 配置主题\n    \n修改博客工程根目录下的`_config.yml`文件\n\n    theme: hexo-theme-next\n    \n# 配置风格\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    scheme: Mist\n\n# 配置语言\n\n修改博客工程根目录下的`_config.yml`文件\n\n    language: zh-CN\n\n# 配置描述\n\n修改博客工程根目录下的`_config.yml`文件\n\n    description: \"Stay hungry, Stay foolish.\"\n\n# 配置目录\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    toc:\n      enable: true\n      number: false\n\n# 配置头像\n\n将头像图片文件`123.jpg`放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    avatar: \n      url: /images/123.jpg\n\n\n# 配置拉条\n\n    none\n\n# 配置社交\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    social:\n      GitHub: https://github.com/jaydenh215 || github\n\n# 配置打赏\n\n将打赏图片文件`wechatpay.jpg`放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    reward_settings:\n      enable: true\n      comment: “如果觉得还不错，请我喝杯咖啡吧~”\n\n    reward:\n      wechatpay: /images/wechatpay.jpg\n\n# 配置菜单\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    menu:\n      home: / || home\n      tags: /tags/ || tags\n      categories: /categories/ || th\n\n\n# 配置标签\n\n增加一个页面（page）用来汇总`标签`\n\n    hexo new page tags\n\n修改生成的页面文件内容（/source/tags/index.md）\n\n    ---\n    title: tags\n    date: 2019-05-10 13:49:39\n    type: \"tags\"\n    ---\n\n给文章添加`标签`属性\n\n    ---\n    title: 博客个性化配置\n    date: 2019-05-10 10:00:00\n    tags: \n    - 博客\n    - 搭建\n    - 环境\n    - 配置\n    ---\n\n# 配置分类\n\n增加一个页面（page）用来汇总`类别`\n\n    hexo new page categories\n\n修改生成的页面文件内容（/source/categories/index.md）\n\n    ---\n    title: categories\n    date: 2019-05-10 13:44:06\n    type: \"categories\" \n    ---\n\n给文章添加`类别`属性\n\n    ---\n    title: 博客个性化配置\n    date: 2019-05-10 10:00:00\n    categories:\n    - 社交\n    ---\n\n# 配置评论\n\nnext主题集成了许多第三方厂家的评论功能插件，选择比较精简的[Valine](https://theme-next.org/docs/third-party-services/comments-and-widgets)。\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件，主要是`app id`和`app key`。\n\n    valine:\n      enable: true \n      appid: xxxxxxxxxx\n      appkey: xxxxxxxxxx\n      guest_info: nick,mail\n      notify: true\n      placeholder: Comment here ...\n\n增加评论区之后，右下角会有`Power by Valine`，可以这样删掉：\n\n找到`/themes/hexo-theme-next/layout/_third-party/comments/valine.swig`文件并修改代码\n\n修改前：\n\n    <script>\n    var GUEST = ['nick', 'mail', 'link'];\n    var guest = '{{ theme.valine.guest_info }}';\n    guest = guest.split(',').filter(function(item) {\n        return GUEST.indexOf(item) > -1;\n    });\n    new Valine({\n        el: '#comments',\n        verify: {{ theme.valine.verify }},\n        notify: {{ theme.valine.notify }},\n        appId: '{{ theme.valine.appid }}',\n        appKey: '{{ theme.valine.appkey }}',\n        placeholder: '{{ theme.valine.placeholder }}',\n        avatar: '{{ theme.valine.avatar }}',\n        meta: guest,\n        pageSize: '{{ theme.valine.pageSize }}' || 10,\n        visitor: {{ theme.valine.visitor }},\n        lang: '{{ theme.valine.language }}' || 'zh-cn'\n    });\n    </script>\n\n修改后：\n\n    <script>\n    var GUEST = ['nick', 'mail', 'link'];\n    var guest = '{{ theme.valine.guest_info }}';\n    guest = guest.split(',').filter(function(item) {\n        return GUEST.indexOf(item) > -1;\n    });\n    new Valine({\n        el: '#comments',\n        verify: {{ theme.valine.verify }},\n        notify: {{ theme.valine.notify }},\n        appId: '{{ theme.valine.appid }}',\n        appKey: '{{ theme.valine.appkey }}',\n        placeholder: '{{ theme.valine.placeholder }}',\n        avatar: '{{ theme.valine.avatar }}',\n        meta: guest,\n        pageSize: '{{ theme.valine.pageSize }}' || 10,\n        visitor: {{ theme.valine.visitor }},\n        lang: '{{ theme.valine.language }}' || 'zh-cn'\n    });\n    //新增\n    var infoEle= document.querySelector('#comments .info');\n    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {\n        infoEle.childNodes.forEach(function(item) {\n        item.parentNode.removeChild(item);\n        });\n    }\n    </script>\n\n# 配置分享\n\n修改博客工程根目录下的`_config.yml`文件\n\n    baidushare: true\n        \n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    baidushare: \n      type: button\n\n\n\n按照[链接中的方法](https://github.com/hrwhisper/baiduShare)，将static放进`/themes/hexo-theme-next/source`目录下。\n\n修改`baidushare.swig`文件中的代码。\n\n修改前：\n    \n    .src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];\n\n修改后：\n\n    .src='/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)]; \n    \n\n# 配置版权\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    creative_commons:\n      post: true\n\n修改博客工程根目录下的`_config.yml`文件\n\n    url: https://jaydenh215.github.io/\n\n# 配置脚注\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    footer:\n      powered:\n        enable: false\n        \n      theme:\n        enable: false\n\n# 配置统计\n\nnext主题集成了许多第三方厂家的统计功能插件，选择[LeanCloud](https://theme-next.org/docs/third-party-services/statistics-and-analytics)。\n\n完成上述步骤之后，会发现`阅读次数`后面没有数字，那是因为`LeanCloud`和`next`主题还没有联系起来，\n需要按照[该博主的方法](https://blog.csdn.net/lijing742180/article/details/87928554)来实现。\n\n[部署云引擎以保证访客数量不被随意篡改](https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md)\n\n20190514：总是有问题，所以现在先把leancloud_visitors安全设置为false。\n\n# 配置搜索\n\n[next主题推荐使用Local Search](https://theme-next.org/docs/third-party-services/search-services)\n\n# 博文置顶\n\n[参考这里](http://wangwlj.com/2018/01/09/blog_pin_post/)\n\n# 博文插图\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    post_asset_folder: true\n\n这样每次hexo new XX，都会同时生成一个XX文件夹用来放图片。\n\n为了去掉插图的边框，找到`/themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl`文件并修改代码。\n\n    img {\n        box-sizing: border-box;\n        margin: auto;\n        padding: 0px;\n        border: 0px;\n    }\n\n\n","source":"_posts/博客搭建实战.md","raw":"---\ntitle: 博客搭建实战\ndate: 2019-05-10 10:00:00\ntags: \n- Hexo\n- 博客\n- 搭建\n- 配置\n- 工具\n\ncategories:\n- 工具\n\ntop: false\n\n---\n\nHexo 是一个快速、简洁且高效的博客框架，支持个性化的配置。这篇博文记录了搭建过程。\n<!-- more --> \n\n目录\n===\n<!-- TOC -->\n\n- [配置主题](#配置主题)\n- [配置风格](#配置风格)\n- [配置语言](#配置语言)\n- [配置描述](#配置描述)\n- [配置目录](#配置目录)\n- [配置头像](#配置头像)\n- [配置拉条](#配置拉条)\n- [配置社交](#配置社交)\n- [配置打赏](#配置打赏)\n- [配置菜单](#配置菜单)\n- [配置标签](#配置标签)\n- [配置分类](#配置分类)\n- [配置评论](#配置评论)\n- [配置分享](#配置分享)\n- [配置版权](#配置版权)\n- [配置脚注](#配置脚注)\n- [配置统计](#配置统计)\n- [配置搜索](#配置搜索)\n- [博文置顶](#博文置顶)\n- [博文插图](#博文插图)\n\n<!-- /TOC -->\n\n# 配置主题\n    \n修改博客工程根目录下的`_config.yml`文件\n\n    theme: hexo-theme-next\n    \n# 配置风格\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    scheme: Mist\n\n# 配置语言\n\n修改博客工程根目录下的`_config.yml`文件\n\n    language: zh-CN\n\n# 配置描述\n\n修改博客工程根目录下的`_config.yml`文件\n\n    description: \"Stay hungry, Stay foolish.\"\n\n# 配置目录\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    toc:\n      enable: true\n      number: false\n\n# 配置头像\n\n将头像图片文件`123.jpg`放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    avatar: \n      url: /images/123.jpg\n\n\n# 配置拉条\n\n    none\n\n# 配置社交\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    social:\n      GitHub: https://github.com/jaydenh215 || github\n\n# 配置打赏\n\n将打赏图片文件`wechatpay.jpg`放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    reward_settings:\n      enable: true\n      comment: “如果觉得还不错，请我喝杯咖啡吧~”\n\n    reward:\n      wechatpay: /images/wechatpay.jpg\n\n# 配置菜单\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    menu:\n      home: / || home\n      tags: /tags/ || tags\n      categories: /categories/ || th\n\n\n# 配置标签\n\n增加一个页面（page）用来汇总`标签`\n\n    hexo new page tags\n\n修改生成的页面文件内容（/source/tags/index.md）\n\n    ---\n    title: tags\n    date: 2019-05-10 13:49:39\n    type: \"tags\"\n    ---\n\n给文章添加`标签`属性\n\n    ---\n    title: 博客个性化配置\n    date: 2019-05-10 10:00:00\n    tags: \n    - 博客\n    - 搭建\n    - 环境\n    - 配置\n    ---\n\n# 配置分类\n\n增加一个页面（page）用来汇总`类别`\n\n    hexo new page categories\n\n修改生成的页面文件内容（/source/categories/index.md）\n\n    ---\n    title: categories\n    date: 2019-05-10 13:44:06\n    type: \"categories\" \n    ---\n\n给文章添加`类别`属性\n\n    ---\n    title: 博客个性化配置\n    date: 2019-05-10 10:00:00\n    categories:\n    - 社交\n    ---\n\n# 配置评论\n\nnext主题集成了许多第三方厂家的评论功能插件，选择比较精简的[Valine](https://theme-next.org/docs/third-party-services/comments-and-widgets)。\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件，主要是`app id`和`app key`。\n\n    valine:\n      enable: true \n      appid: xxxxxxxxxx\n      appkey: xxxxxxxxxx\n      guest_info: nick,mail\n      notify: true\n      placeholder: Comment here ...\n\n增加评论区之后，右下角会有`Power by Valine`，可以这样删掉：\n\n找到`/themes/hexo-theme-next/layout/_third-party/comments/valine.swig`文件并修改代码\n\n修改前：\n\n    <script>\n    var GUEST = ['nick', 'mail', 'link'];\n    var guest = '{{ theme.valine.guest_info }}';\n    guest = guest.split(',').filter(function(item) {\n        return GUEST.indexOf(item) > -1;\n    });\n    new Valine({\n        el: '#comments',\n        verify: {{ theme.valine.verify }},\n        notify: {{ theme.valine.notify }},\n        appId: '{{ theme.valine.appid }}',\n        appKey: '{{ theme.valine.appkey }}',\n        placeholder: '{{ theme.valine.placeholder }}',\n        avatar: '{{ theme.valine.avatar }}',\n        meta: guest,\n        pageSize: '{{ theme.valine.pageSize }}' || 10,\n        visitor: {{ theme.valine.visitor }},\n        lang: '{{ theme.valine.language }}' || 'zh-cn'\n    });\n    </script>\n\n修改后：\n\n    <script>\n    var GUEST = ['nick', 'mail', 'link'];\n    var guest = '{{ theme.valine.guest_info }}';\n    guest = guest.split(',').filter(function(item) {\n        return GUEST.indexOf(item) > -1;\n    });\n    new Valine({\n        el: '#comments',\n        verify: {{ theme.valine.verify }},\n        notify: {{ theme.valine.notify }},\n        appId: '{{ theme.valine.appid }}',\n        appKey: '{{ theme.valine.appkey }}',\n        placeholder: '{{ theme.valine.placeholder }}',\n        avatar: '{{ theme.valine.avatar }}',\n        meta: guest,\n        pageSize: '{{ theme.valine.pageSize }}' || 10,\n        visitor: {{ theme.valine.visitor }},\n        lang: '{{ theme.valine.language }}' || 'zh-cn'\n    });\n    //新增\n    var infoEle= document.querySelector('#comments .info');\n    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {\n        infoEle.childNodes.forEach(function(item) {\n        item.parentNode.removeChild(item);\n        });\n    }\n    </script>\n\n# 配置分享\n\n修改博客工程根目录下的`_config.yml`文件\n\n    baidushare: true\n        \n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    baidushare: \n      type: button\n\n\n\n按照[链接中的方法](https://github.com/hrwhisper/baiduShare)，将static放进`/themes/hexo-theme-next/source`目录下。\n\n修改`baidushare.swig`文件中的代码。\n\n修改前：\n    \n    .src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];\n\n修改后：\n\n    .src='/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)]; \n    \n\n# 配置版权\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    creative_commons:\n      post: true\n\n修改博客工程根目录下的`_config.yml`文件\n\n    url: https://jaydenh215.github.io/\n\n# 配置脚注\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    footer:\n      powered:\n        enable: false\n        \n      theme:\n        enable: false\n\n# 配置统计\n\nnext主题集成了许多第三方厂家的统计功能插件，选择[LeanCloud](https://theme-next.org/docs/third-party-services/statistics-and-analytics)。\n\n完成上述步骤之后，会发现`阅读次数`后面没有数字，那是因为`LeanCloud`和`next`主题还没有联系起来，\n需要按照[该博主的方法](https://blog.csdn.net/lijing742180/article/details/87928554)来实现。\n\n[部署云引擎以保证访客数量不被随意篡改](https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md)\n\n20190514：总是有问题，所以现在先把leancloud_visitors安全设置为false。\n\n# 配置搜索\n\n[next主题推荐使用Local Search](https://theme-next.org/docs/third-party-services/search-services)\n\n# 博文置顶\n\n[参考这里](http://wangwlj.com/2018/01/09/blog_pin_post/)\n\n# 博文插图\n\n修改主题目录（/themes/hexo-theme-next）下的`_config.yml`文件\n\n    post_asset_folder: true\n\n这样每次hexo new XX，都会同时生成一个XX文件夹用来放图片。\n\n为了去掉插图的边框，找到`/themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl`文件并修改代码。\n\n    img {\n        box-sizing: border-box;\n        margin: auto;\n        padding: 0px;\n        border: 0px;\n    }\n\n\n","slug":"博客搭建实战","published":1,"updated":"2019-05-24T07:22:53.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8q7o0011gcg8qgvewd9p","content":"<p>Hexo 是一个快速、简洁且高效的博客框架，支持个性化的配置。这篇博文记录了搭建过程。<br><a id=\"more\"></a> </p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#配置主题\">配置主题</a></li>\n<li><a href=\"#配置风格\">配置风格</a></li>\n<li><a href=\"#配置语言\">配置语言</a></li>\n<li><a href=\"#配置描述\">配置描述</a></li>\n<li><a href=\"#配置目录\">配置目录</a></li>\n<li><a href=\"#配置头像\">配置头像</a></li>\n<li><a href=\"#配置拉条\">配置拉条</a></li>\n<li><a href=\"#配置社交\">配置社交</a></li>\n<li><a href=\"#配置打赏\">配置打赏</a></li>\n<li><a href=\"#配置菜单\">配置菜单</a></li>\n<li><a href=\"#配置标签\">配置标签</a></li>\n<li><a href=\"#配置分类\">配置分类</a></li>\n<li><a href=\"#配置评论\">配置评论</a></li>\n<li><a href=\"#配置分享\">配置分享</a></li>\n<li><a href=\"#配置版权\">配置版权</a></li>\n<li><a href=\"#配置脚注\">配置脚注</a></li>\n<li><a href=\"#配置统计\">配置统计</a></li>\n<li><a href=\"#配置搜索\">配置搜索</a></li>\n<li><a href=\"#博文置顶\">博文置顶</a></li>\n<li><a href=\"#博文插图\">博文插图</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h1><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>theme: hexo-theme-next\n</code></pre><h1 id=\"配置风格\"><a href=\"#配置风格\" class=\"headerlink\" title=\"配置风格\"></a>配置风格</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>scheme: Mist\n</code></pre><h1 id=\"配置语言\"><a href=\"#配置语言\" class=\"headerlink\" title=\"配置语言\"></a>配置语言</h1><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>language: zh-CN\n</code></pre><h1 id=\"配置描述\"><a href=\"#配置描述\" class=\"headerlink\" title=\"配置描述\"></a>配置描述</h1><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>description: &quot;Stay hungry, Stay foolish.&quot;\n</code></pre><h1 id=\"配置目录\"><a href=\"#配置目录\" class=\"headerlink\" title=\"配置目录\"></a>配置目录</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>toc:\n  enable: true\n  number: false\n</code></pre><h1 id=\"配置头像\"><a href=\"#配置头像\" class=\"headerlink\" title=\"配置头像\"></a>配置头像</h1><p>将头像图片文件<code>123.jpg</code>放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>avatar: \n  url: /images/123.jpg\n</code></pre><h1 id=\"配置拉条\"><a href=\"#配置拉条\" class=\"headerlink\" title=\"配置拉条\"></a>配置拉条</h1><pre><code>none\n</code></pre><h1 id=\"配置社交\"><a href=\"#配置社交\" class=\"headerlink\" title=\"配置社交\"></a>配置社交</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>social:\n  GitHub: https://github.com/jaydenh215 || github\n</code></pre><h1 id=\"配置打赏\"><a href=\"#配置打赏\" class=\"headerlink\" title=\"配置打赏\"></a>配置打赏</h1><p>将打赏图片文件<code>wechatpay.jpg</code>放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>reward_settings:\n  enable: true\n  comment: “如果觉得还不错，请我喝杯咖啡吧~”\n\nreward:\n  wechatpay: /images/wechatpay.jpg\n</code></pre><h1 id=\"配置菜单\"><a href=\"#配置菜单\" class=\"headerlink\" title=\"配置菜单\"></a>配置菜单</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>menu:\n  home: / || home\n  tags: /tags/ || tags\n  categories: /categories/ || th\n</code></pre><h1 id=\"配置标签\"><a href=\"#配置标签\" class=\"headerlink\" title=\"配置标签\"></a>配置标签</h1><p>增加一个页面（page）用来汇总<code>标签</code></p>\n<pre><code>hexo new page tags\n</code></pre><p>修改生成的页面文件内容（/source/tags/index.md）</p>\n<pre><code>---\ntitle: tags\ndate: 2019-05-10 13:49:39\ntype: &quot;tags&quot;\n---\n</code></pre><p>给文章添加<code>标签</code>属性</p>\n<pre><code>---\ntitle: 博客个性化配置\ndate: 2019-05-10 10:00:00\ntags: \n- 博客\n- 搭建\n- 环境\n- 配置\n---\n</code></pre><h1 id=\"配置分类\"><a href=\"#配置分类\" class=\"headerlink\" title=\"配置分类\"></a>配置分类</h1><p>增加一个页面（page）用来汇总<code>类别</code></p>\n<pre><code>hexo new page categories\n</code></pre><p>修改生成的页面文件内容（/source/categories/index.md）</p>\n<pre><code>---\ntitle: categories\ndate: 2019-05-10 13:44:06\ntype: &quot;categories&quot; \n---\n</code></pre><p>给文章添加<code>类别</code>属性</p>\n<pre><code>---\ntitle: 博客个性化配置\ndate: 2019-05-10 10:00:00\ncategories:\n- 社交\n---\n</code></pre><h1 id=\"配置评论\"><a href=\"#配置评论\" class=\"headerlink\" title=\"配置评论\"></a>配置评论</h1><p>next主题集成了许多第三方厂家的评论功能插件，选择比较精简的<a href=\"https://theme-next.org/docs/third-party-services/comments-and-widgets\" target=\"_blank\" rel=\"noopener\">Valine</a>。</p>\n<p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件，主要是<code>app id</code>和<code>app key</code>。</p>\n<pre><code>valine:\n  enable: true \n  appid: xxxxxxxxxx\n  appkey: xxxxxxxxxx\n  guest_info: nick,mail\n  notify: true\n  placeholder: Comment here ...\n</code></pre><p>增加评论区之后，右下角会有<code>Power by Valine</code>，可以这样删掉：</p>\n<p>找到<code>/themes/hexo-theme-next/layout/_third-party/comments/valine.swig</code>文件并修改代码</p>\n<p>修改前：</p>\n<pre><code>&lt;script&gt;\nvar GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;];\nvar guest = &apos;{{ theme.valine.guest_info }}&apos;;\nguest = guest.split(&apos;,&apos;).filter(function(item) {\n    return GUEST.indexOf(item) &gt; -1;\n});\nnew Valine({\n    el: &apos;#comments&apos;,\n    verify: {{ theme.valine.verify }},\n    notify: {{ theme.valine.notify }},\n    appId: &apos;{{ theme.valine.appid }}&apos;,\n    appKey: &apos;{{ theme.valine.appkey }}&apos;,\n    placeholder: &apos;{{ theme.valine.placeholder }}&apos;,\n    avatar: &apos;{{ theme.valine.avatar }}&apos;,\n    meta: guest,\n    pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10,\n    visitor: {{ theme.valine.visitor }},\n    lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos;\n});\n&lt;/script&gt;\n</code></pre><p>修改后：</p>\n<pre><code>&lt;script&gt;\nvar GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;];\nvar guest = &apos;{{ theme.valine.guest_info }}&apos;;\nguest = guest.split(&apos;,&apos;).filter(function(item) {\n    return GUEST.indexOf(item) &gt; -1;\n});\nnew Valine({\n    el: &apos;#comments&apos;,\n    verify: {{ theme.valine.verify }},\n    notify: {{ theme.valine.notify }},\n    appId: &apos;{{ theme.valine.appid }}&apos;,\n    appKey: &apos;{{ theme.valine.appkey }}&apos;,\n    placeholder: &apos;{{ theme.valine.placeholder }}&apos;,\n    avatar: &apos;{{ theme.valine.avatar }}&apos;,\n    meta: guest,\n    pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10,\n    visitor: {{ theme.valine.visitor }},\n    lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos;\n});\n//新增\nvar infoEle= document.querySelector(&apos;#comments .info&apos;);\nif (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0) {\n    infoEle.childNodes.forEach(function(item) {\n    item.parentNode.removeChild(item);\n    });\n}\n&lt;/script&gt;\n</code></pre><h1 id=\"配置分享\"><a href=\"#配置分享\" class=\"headerlink\" title=\"配置分享\"></a>配置分享</h1><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>baidushare: true\n</code></pre><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>baidushare: \n  type: button\n</code></pre><p>按照<a href=\"https://github.com/hrwhisper/baiduShare\" target=\"_blank\" rel=\"noopener\">链接中的方法</a>，将static放进<code>/themes/hexo-theme-next/source</code>目录下。</p>\n<p>修改<code>baidushare.swig</code>文件中的代码。</p>\n<p>修改前：</p>\n<pre><code>.src=&apos;//bdimg.share.baidu.com/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)];\n</code></pre><p>修改后：</p>\n<pre><code>.src=&apos;/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)]; \n</code></pre><h1 id=\"配置版权\"><a href=\"#配置版权\" class=\"headerlink\" title=\"配置版权\"></a>配置版权</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>creative_commons:\n  post: true\n</code></pre><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>url: https://jaydenh215.github.io/\n</code></pre><h1 id=\"配置脚注\"><a href=\"#配置脚注\" class=\"headerlink\" title=\"配置脚注\"></a>配置脚注</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>footer:\n  powered:\n    enable: false\n\n  theme:\n    enable: false\n</code></pre><h1 id=\"配置统计\"><a href=\"#配置统计\" class=\"headerlink\" title=\"配置统计\"></a>配置统计</h1><p>next主题集成了许多第三方厂家的统计功能插件，选择<a href=\"https://theme-next.org/docs/third-party-services/statistics-and-analytics\" target=\"_blank\" rel=\"noopener\">LeanCloud</a>。</p>\n<p>完成上述步骤之后，会发现<code>阅读次数</code>后面没有数字，那是因为<code>LeanCloud</code>和<code>next</code>主题还没有联系起来，<br>需要按照<a href=\"https://blog.csdn.net/lijing742180/article/details/87928554\" target=\"_blank\" rel=\"noopener\">该博主的方法</a>来实现。</p>\n<p><a href=\"https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md\" target=\"_blank\" rel=\"noopener\">部署云引擎以保证访客数量不被随意篡改</a></p>\n<p>20190514：总是有问题，所以现在先把leancloud_visitors安全设置为false。</p>\n<h1 id=\"配置搜索\"><a href=\"#配置搜索\" class=\"headerlink\" title=\"配置搜索\"></a>配置搜索</h1><p><a href=\"https://theme-next.org/docs/third-party-services/search-services\" target=\"_blank\" rel=\"noopener\">next主题推荐使用Local Search</a></p>\n<h1 id=\"博文置顶\"><a href=\"#博文置顶\" class=\"headerlink\" title=\"博文置顶\"></a>博文置顶</h1><p><a href=\"http://wangwlj.com/2018/01/09/blog_pin_post/\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<h1 id=\"博文插图\"><a href=\"#博文插图\" class=\"headerlink\" title=\"博文插图\"></a>博文插图</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>post_asset_folder: true\n</code></pre><p>这样每次hexo new XX，都会同时生成一个XX文件夹用来放图片。</p>\n<p>为了去掉插图的边框，找到<code>/themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl</code>文件并修改代码。</p>\n<pre><code>img {\n    box-sizing: border-box;\n    margin: auto;\n    padding: 0px;\n    border: 0px;\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>Hexo 是一个快速、简洁且高效的博客框架，支持个性化的配置。这篇博文记录了搭建过程。<br>","more":"</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#配置主题\">配置主题</a></li>\n<li><a href=\"#配置风格\">配置风格</a></li>\n<li><a href=\"#配置语言\">配置语言</a></li>\n<li><a href=\"#配置描述\">配置描述</a></li>\n<li><a href=\"#配置目录\">配置目录</a></li>\n<li><a href=\"#配置头像\">配置头像</a></li>\n<li><a href=\"#配置拉条\">配置拉条</a></li>\n<li><a href=\"#配置社交\">配置社交</a></li>\n<li><a href=\"#配置打赏\">配置打赏</a></li>\n<li><a href=\"#配置菜单\">配置菜单</a></li>\n<li><a href=\"#配置标签\">配置标签</a></li>\n<li><a href=\"#配置分类\">配置分类</a></li>\n<li><a href=\"#配置评论\">配置评论</a></li>\n<li><a href=\"#配置分享\">配置分享</a></li>\n<li><a href=\"#配置版权\">配置版权</a></li>\n<li><a href=\"#配置脚注\">配置脚注</a></li>\n<li><a href=\"#配置统计\">配置统计</a></li>\n<li><a href=\"#配置搜索\">配置搜索</a></li>\n<li><a href=\"#博文置顶\">博文置顶</a></li>\n<li><a href=\"#博文插图\">博文插图</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h1><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>theme: hexo-theme-next\n</code></pre><h1 id=\"配置风格\"><a href=\"#配置风格\" class=\"headerlink\" title=\"配置风格\"></a>配置风格</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>scheme: Mist\n</code></pre><h1 id=\"配置语言\"><a href=\"#配置语言\" class=\"headerlink\" title=\"配置语言\"></a>配置语言</h1><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>language: zh-CN\n</code></pre><h1 id=\"配置描述\"><a href=\"#配置描述\" class=\"headerlink\" title=\"配置描述\"></a>配置描述</h1><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>description: &quot;Stay hungry, Stay foolish.&quot;\n</code></pre><h1 id=\"配置目录\"><a href=\"#配置目录\" class=\"headerlink\" title=\"配置目录\"></a>配置目录</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>toc:\n  enable: true\n  number: false\n</code></pre><h1 id=\"配置头像\"><a href=\"#配置头像\" class=\"headerlink\" title=\"配置头像\"></a>配置头像</h1><p>将头像图片文件<code>123.jpg</code>放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>avatar: \n  url: /images/123.jpg\n</code></pre><h1 id=\"配置拉条\"><a href=\"#配置拉条\" class=\"headerlink\" title=\"配置拉条\"></a>配置拉条</h1><pre><code>none\n</code></pre><h1 id=\"配置社交\"><a href=\"#配置社交\" class=\"headerlink\" title=\"配置社交\"></a>配置社交</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>social:\n  GitHub: https://github.com/jaydenh215 || github\n</code></pre><h1 id=\"配置打赏\"><a href=\"#配置打赏\" class=\"headerlink\" title=\"配置打赏\"></a>配置打赏</h1><p>将打赏图片文件<code>wechatpay.jpg</code>放进/source/images中，修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>reward_settings:\n  enable: true\n  comment: “如果觉得还不错，请我喝杯咖啡吧~”\n\nreward:\n  wechatpay: /images/wechatpay.jpg\n</code></pre><h1 id=\"配置菜单\"><a href=\"#配置菜单\" class=\"headerlink\" title=\"配置菜单\"></a>配置菜单</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>menu:\n  home: / || home\n  tags: /tags/ || tags\n  categories: /categories/ || th\n</code></pre><h1 id=\"配置标签\"><a href=\"#配置标签\" class=\"headerlink\" title=\"配置标签\"></a>配置标签</h1><p>增加一个页面（page）用来汇总<code>标签</code></p>\n<pre><code>hexo new page tags\n</code></pre><p>修改生成的页面文件内容（/source/tags/index.md）</p>\n<pre><code>---\ntitle: tags\ndate: 2019-05-10 13:49:39\ntype: &quot;tags&quot;\n---\n</code></pre><p>给文章添加<code>标签</code>属性</p>\n<pre><code>---\ntitle: 博客个性化配置\ndate: 2019-05-10 10:00:00\ntags: \n- 博客\n- 搭建\n- 环境\n- 配置\n---\n</code></pre><h1 id=\"配置分类\"><a href=\"#配置分类\" class=\"headerlink\" title=\"配置分类\"></a>配置分类</h1><p>增加一个页面（page）用来汇总<code>类别</code></p>\n<pre><code>hexo new page categories\n</code></pre><p>修改生成的页面文件内容（/source/categories/index.md）</p>\n<pre><code>---\ntitle: categories\ndate: 2019-05-10 13:44:06\ntype: &quot;categories&quot; \n---\n</code></pre><p>给文章添加<code>类别</code>属性</p>\n<pre><code>---\ntitle: 博客个性化配置\ndate: 2019-05-10 10:00:00\ncategories:\n- 社交\n---\n</code></pre><h1 id=\"配置评论\"><a href=\"#配置评论\" class=\"headerlink\" title=\"配置评论\"></a>配置评论</h1><p>next主题集成了许多第三方厂家的评论功能插件，选择比较精简的<a href=\"https://theme-next.org/docs/third-party-services/comments-and-widgets\" target=\"_blank\" rel=\"noopener\">Valine</a>。</p>\n<p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件，主要是<code>app id</code>和<code>app key</code>。</p>\n<pre><code>valine:\n  enable: true \n  appid: xxxxxxxxxx\n  appkey: xxxxxxxxxx\n  guest_info: nick,mail\n  notify: true\n  placeholder: Comment here ...\n</code></pre><p>增加评论区之后，右下角会有<code>Power by Valine</code>，可以这样删掉：</p>\n<p>找到<code>/themes/hexo-theme-next/layout/_third-party/comments/valine.swig</code>文件并修改代码</p>\n<p>修改前：</p>\n<pre><code>&lt;script&gt;\nvar GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;];\nvar guest = &apos;{{ theme.valine.guest_info }}&apos;;\nguest = guest.split(&apos;,&apos;).filter(function(item) {\n    return GUEST.indexOf(item) &gt; -1;\n});\nnew Valine({\n    el: &apos;#comments&apos;,\n    verify: {{ theme.valine.verify }},\n    notify: {{ theme.valine.notify }},\n    appId: &apos;{{ theme.valine.appid }}&apos;,\n    appKey: &apos;{{ theme.valine.appkey }}&apos;,\n    placeholder: &apos;{{ theme.valine.placeholder }}&apos;,\n    avatar: &apos;{{ theme.valine.avatar }}&apos;,\n    meta: guest,\n    pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10,\n    visitor: {{ theme.valine.visitor }},\n    lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos;\n});\n&lt;/script&gt;\n</code></pre><p>修改后：</p>\n<pre><code>&lt;script&gt;\nvar GUEST = [&apos;nick&apos;, &apos;mail&apos;, &apos;link&apos;];\nvar guest = &apos;{{ theme.valine.guest_info }}&apos;;\nguest = guest.split(&apos;,&apos;).filter(function(item) {\n    return GUEST.indexOf(item) &gt; -1;\n});\nnew Valine({\n    el: &apos;#comments&apos;,\n    verify: {{ theme.valine.verify }},\n    notify: {{ theme.valine.notify }},\n    appId: &apos;{{ theme.valine.appid }}&apos;,\n    appKey: &apos;{{ theme.valine.appkey }}&apos;,\n    placeholder: &apos;{{ theme.valine.placeholder }}&apos;,\n    avatar: &apos;{{ theme.valine.avatar }}&apos;,\n    meta: guest,\n    pageSize: &apos;{{ theme.valine.pageSize }}&apos; || 10,\n    visitor: {{ theme.valine.visitor }},\n    lang: &apos;{{ theme.valine.language }}&apos; || &apos;zh-cn&apos;\n});\n//新增\nvar infoEle= document.querySelector(&apos;#comments .info&apos;);\nif (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0) {\n    infoEle.childNodes.forEach(function(item) {\n    item.parentNode.removeChild(item);\n    });\n}\n&lt;/script&gt;\n</code></pre><h1 id=\"配置分享\"><a href=\"#配置分享\" class=\"headerlink\" title=\"配置分享\"></a>配置分享</h1><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>baidushare: true\n</code></pre><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>baidushare: \n  type: button\n</code></pre><p>按照<a href=\"https://github.com/hrwhisper/baiduShare\" target=\"_blank\" rel=\"noopener\">链接中的方法</a>，将static放进<code>/themes/hexo-theme-next/source</code>目录下。</p>\n<p>修改<code>baidushare.swig</code>文件中的代码。</p>\n<p>修改前：</p>\n<pre><code>.src=&apos;//bdimg.share.baidu.com/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)];\n</code></pre><p>修改后：</p>\n<pre><code>.src=&apos;/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)]; \n</code></pre><h1 id=\"配置版权\"><a href=\"#配置版权\" class=\"headerlink\" title=\"配置版权\"></a>配置版权</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>creative_commons:\n  post: true\n</code></pre><p>修改博客工程根目录下的<code>_config.yml</code>文件</p>\n<pre><code>url: https://jaydenh215.github.io/\n</code></pre><h1 id=\"配置脚注\"><a href=\"#配置脚注\" class=\"headerlink\" title=\"配置脚注\"></a>配置脚注</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>footer:\n  powered:\n    enable: false\n\n  theme:\n    enable: false\n</code></pre><h1 id=\"配置统计\"><a href=\"#配置统计\" class=\"headerlink\" title=\"配置统计\"></a>配置统计</h1><p>next主题集成了许多第三方厂家的统计功能插件，选择<a href=\"https://theme-next.org/docs/third-party-services/statistics-and-analytics\" target=\"_blank\" rel=\"noopener\">LeanCloud</a>。</p>\n<p>完成上述步骤之后，会发现<code>阅读次数</code>后面没有数字，那是因为<code>LeanCloud</code>和<code>next</code>主题还没有联系起来，<br>需要按照<a href=\"https://blog.csdn.net/lijing742180/article/details/87928554\" target=\"_blank\" rel=\"noopener\">该博主的方法</a>来实现。</p>\n<p><a href=\"https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md\" target=\"_blank\" rel=\"noopener\">部署云引擎以保证访客数量不被随意篡改</a></p>\n<p>20190514：总是有问题，所以现在先把leancloud_visitors安全设置为false。</p>\n<h1 id=\"配置搜索\"><a href=\"#配置搜索\" class=\"headerlink\" title=\"配置搜索\"></a>配置搜索</h1><p><a href=\"https://theme-next.org/docs/third-party-services/search-services\" target=\"_blank\" rel=\"noopener\">next主题推荐使用Local Search</a></p>\n<h1 id=\"博文置顶\"><a href=\"#博文置顶\" class=\"headerlink\" title=\"博文置顶\"></a>博文置顶</h1><p><a href=\"http://wangwlj.com/2018/01/09/blog_pin_post/\" target=\"_blank\" rel=\"noopener\">参考这里</a></p>\n<h1 id=\"博文插图\"><a href=\"#博文插图\" class=\"headerlink\" title=\"博文插图\"></a>博文插图</h1><p>修改主题目录（/themes/hexo-theme-next）下的<code>_config.yml</code>文件</p>\n<pre><code>post_asset_folder: true\n</code></pre><p>这样每次hexo new XX，都会同时生成一个XX文件夹用来放图片。</p>\n<p>为了去掉插图的边框，找到<code>/themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl</code>文件并修改代码。</p>\n<pre><code>img {\n    box-sizing: border-box;\n    margin: auto;\n    padding: 0px;\n    border: 0px;\n}\n</code></pre>"},{"title":"rtt+nimble揭秘系列——移植nimble（3）","date":"2019-10-08T16:24:44.000Z","_content":"\n站在巨人的肩膀上可以看的更远。\n<!-- more --> \n\n前言\n===\n\n移植目标：手机app可以搜索到ble广播，能成功连接并发现服务。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 土方法](#1-土方法)\n- [2. 移植host](#2-移植host)\n    - [2.1. 添加nimble](#21-添加nimble)\n    - [2.2. 添加空白SConscript](#22-添加空白sconscript)\n    - [2.3. 移植阶段一](#23-移植阶段一)\n        - [2.3.1. 无法打开头文件](#231-无法打开头文件)\n        - [2.3.2. 无法打开头文件（缺少头文件）](#232-无法打开头文件缺少头文件)\n        - [2.3.3. 无法打开头文件（存在多个同名头文件）](#233-无法打开头文件存在多个同名头文件)\n        - [2.3.4. 缺少标识符定义](#234-缺少标识符定义)\n    - [2.4. 移植阶段二](#24-移植阶段二)\n        - [2.4.1. 缺少endian.c中实现的函数](#241-缺少endianc中实现的函数)\n        - [2.4.2. 缺少mem.c中实现的函数](#242-缺少memc中实现的函数)\n        - [2.4.3. 缺少os_mbuf.c实现的函数](#243-缺少os_mbufc实现的函数)\n        - [2.4.4. 缺少os_mempool.c实现的函数](#244-缺少os_mempoolc实现的函数)\n        - [2.4.5. 缺少nimble_port.c实现的函数](#245-缺少nimble_portc实现的函数)\n        - [2.4.6. 缺少os_msys_init.c实现的函数](#246-缺少os_msys_initc实现的函数)\n        - [2.4.7. 缺少tinycrypt加密组件](#247-缺少tinycrypt加密组件)\n    - [2.5. 移植阶段三](#25-移植阶段三)\n        - [2.5.1. 存在多个ble_hc_trans_xxxx同名函数](#251-存在多个ble_hc_trans_xxxx同名函数)\n        - [2.5.2. 缺少ble_npl_xxx函数定义](#252-缺少ble_npl_xxx函数定义)\n    - [2.6. 移植host总结](#26-移植host总结)\n- [3. 移植controller](#3-移植controller)\n    - [3.1. 移植阶段一](#31-移植阶段一)\n        - [3.1.1. 无法打开头文件](#311-无法打开头文件)\n    - [3.2. 移植阶段二](#32-移植阶段二)\n        - [3.2.1. 无法打开头文件（存在多个同名头文件）](#321-无法打开头文件存在多个同名头文件)\n        - [3.2.2. 缺少标识符定义](#322-缺少标识符定义)\n        - [3.2.3. 无法识别内联汇编](#323-无法识别内联汇编)\n        - [3.2.4. 缺少ble_hw.c中实现的函数](#324-缺少ble_hwc中实现的函数)\n        - [3.2.5. 缺少os_cputime.c中实现的函数](#325-缺少os_cputimec中实现的函数)\n        - [3.2.6. 缺少os_cputime_pwr2.c中实现的函数](#326-缺少os_cputime_pwr2c中实现的函数)\n        - [3.2.7. 缺少hal_timer.c中实现的函数](#327-缺少hal_timerc中实现的函数)\n        - [3.2.8. 缺少ble_npl_hw_set_isr函数定义](#328-缺少ble_npl_hw_set_isr函数定义)\n        - [3.2.9. 缺少ble_npl_hw_is_in_critical函数定义](#329-缺少ble_npl_hw_is_in_critical函数定义)\n    - [3.3. 移植controller总结](#33-移植controller总结)\n- [4. 移植profile](#4-移植profile)\n    - [4.1. 添加心率profile](#41-添加心率profile)\n    - [4.2. 移植proifile总结](#42-移植proifile总结)\n- [5. 启动运行](#5-启动运行)\n    - [5.1. 缺少标识符定义](#51-缺少标识符定义)\n    - [5.2. 修复bug](#52-修复bug)\n    - [5.3. 添加调试](#53-添加调试)\n    - [5.4. 编译烧录](#54-编译烧录)\n- [6. 总结](#6-总结)\n\n<!-- /TOC -->\n\n\n# 1. 土方法\n\n第一个问题，nimble的porting目录看不懂，钻牛角尖要不得，故跑到[大佬](https://github.com/Zero-Free/nrf52832-nimble)的github上寻求解决方案。\n\n然后有了第一个解决思路：基于可以正常运行的工程，将部分nimble源文件从SConscript脚本中移除。\n\n然后第二个问题来了，移除哪些源文件？\n\n按照笔者对[nimble官方文档](http://mynewt.apache.org/latest/network/docs/ble_setup/ble_sync_cb.html)的了解，nimble支持host和controller解耦，那么第一步移植工作就先保留host代码，将controller部分全部移除掉。\n\n# 2. 移植host\n\n## 2.1. 添加nimble\n\n将官网下载的nimble压缩包解压，并将生成的文件夹复制粘贴到myboard目录下，即`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0`。\n\n## 2.2. 添加空白SConscript\n\n添加SConscript文件到nimble目录下，即`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\SConscript`。\n\n## 2.3. 移植阶段一\n\n把所有`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\host`里面除了mesh文件夹和test文件夹以外的.c文件加进刚创建的空白SConscript脚本。\n\n> NOTE：ble mesh后面再挖坑，这里先不展开。\n\n按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。\n\n### 2.3.1. 无法打开头文件\n\n```\nerror:  #5: cannot open source input file \"sysinit/sysinit.h\": No such file or directory\n```\n\n错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本  \n解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为`cwd + '/porting/nimble/include'`，同类报错可用同样方法解决。\n\n### 2.3.2. 无法打开头文件（缺少头文件）\n\n```\nerror:  #5: cannot open source input file \"base64/base64.h\": No such file or directory\n```\n\n错误原因：nimble包没有该文件  \n解决办法：从mynewt的`encoding`目录下，拷贝`base64`到`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\ext\\`，并在SConscript中添加路径，该例子需要添加的路径为`cwd + '/ext/base64/include'`。\n\n### 2.3.3. 无法打开头文件（存在多个同名头文件）\n\n```\nerror:  #5: cannot open source input file \"nimble/nimble_npl_os.h\": No such file or directory\n```\n\n错误原因：nimble包有多个该文件，只是没有将头文件目录添加进编译脚本  \n解决方法：该文件定义了os的抽象接口，协议栈会调用这些接口，这些接口的实现每个os都不一样，我们这里参考[rt-thread官方做法](https://github.com/Zero-Free/nrf52832-nimble/tree/master/packages/NimBLE-latest/porting/npl/rtthread)，直接下载该文件夹到`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl`下，并在SConscript中添加路径，该例子需要添加的路径为`cwd + '/porting/npl/rtthread/include'`。\n\n### 2.3.4. 缺少标识符定义\n\n```\nerror:  #20: identifier \"MYNEWT_VAL_BLEUART_MAX_INPUT\" is undefined\n```\n\n错误原因：缺少宏定义  \n解决方法：将`nimble/host/services/bleuart/src/bleuart.c`从SConscript脚本中删除，暂不考虑实现该profile。\n\n```\nerror:  #20: identifier \"MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT\" is undefined\n```\n\n错误原因：缺少宏定义  \n解决方法：将`nimble/host/services/dis/src/ble_svc_dis.c`从SConscript脚本中删除，暂不考虑实现该profile。\n\n## 2.4. 移植阶段二\n\n经过上节处理之后，编译均是以下错误：\n\n```\nError: L6218E: Undefined symbol xxxx (referred from xxxx).\n```\n\nhost文件夹内的代码会引用其他目录下的`公共组件`以及`公共函数`。组件如：内存池，函数如：大小端转换函数。\n\n所以该阶段目标是将host文件夹依赖的`公共组件`和`公共函数`补充完整。\n\n### 2.4.1. 缺少endian.c中实现的函数\n\n解决方法：将`porting/nimble/src/endian.c`添加进SConscript脚本。\n\n### 2.4.2. 缺少mem.c中实现的函数\n\n解决方法：将`porting/nimble/src/mem.c`添加进SConscript脚本。\n\n### 2.4.3. 缺少os_mbuf.c实现的函数\n\n解决方法：将`porting/nimble/src/os_mbuf.c`添加进SConscript脚本。\n\n### 2.4.4. 缺少os_mempool.c实现的函数\n\n解决方法：将`porting/nimble/src/os_mempool.c`添加进SConscript脚本。\n\n### 2.4.5. 缺少nimble_port.c实现的函数\n\n解决方法：将`porting/nimble/src/nimble_port.c`添加进SConscript脚本。\n\n### 2.4.6. 缺少os_msys_init.c实现的函数\n\n解决方法：将`porting/nimble/src/os_msys_init.c`添加进SConscript脚本。\n\n\n### 2.4.7. 缺少tinycrypt加密组件\n\n解决方法：添加以下路径到SConscript文件。  \n`ext/tinycrypt/src/aes_decrypt.c`  \n`ext/tinycrypt/src/aes_encrypt.c`  \n`ext/tinycrypt/src/utils.c`\n\n\n## 2.5. 移植阶段三\n\n经过上节处理之后，编译剩下以下错误：\n\n```\n1. Error: L6218E: Undefined symbol ble_hci_trans_xxxx (referred from xxxx).\n2. Error: L6218E: Undefined symbol ble_npl_xxx (referred from xxxx).\n```\n\n前面做的移植操作，哪个平台都是一样的。而对于这两类错误，不同的应用场景和平台，解决方案会有所差异。\n\n### 2.5.1. 存在多个ble_hc_trans_xxxx同名函数\n\n全局搜索nimble包会发现这些函数在多个.c文件中都有实现，位置如下：\n\n```\n apache-mynewt-nimble-1.2.0\n └──nimble         \n     └──transport\n            ├──da1469x\n            │     └──src\n            │         └──da1469x_ble_hci.c\n            ├──emspi\n            │    └──src\n            │        └──ble_hci_emspi.c\n            ├──ram\n            │    └──src\n            │        └──ble_hci_ram.c\n            ├──socket\n            │    └──src\n            │        └──ble_hci_socket.c\n            └──uart\n                └──src\n                    └──ble_hci_uart.c\n\n```\n\n这意味着我们需要做出选择，为这些函数接口选择具体实现。这时候引入新问题，“我们在选择什么”。\n\n参考[这篇blog](https://jaydenh215.github.io/2019/10/09/%E6%B5%85%E8%B0%88BLE%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B8%A7/)，可知：\n\nhost和controller可通过hci（host-controller-interface）接口互相通信。具体表现为：\n\n- host通过hci向controller发送command\n- controller通过hci向host发送event\n- host和controller通过hci互传acl data\n\n而编译报错缺失的ble_hc_trans_xxxx函数为：\n\n- ble_hci_trans_reset\n- ble_hci_trans_cfg_hs（该API注册接收evt和acl data的回调函数）\n- ble_hci_trans_buf_alloc\n- ble_hci_trans_buf_free\n- ble_hci_trans_hs_cmd_tx\n- ble_hci_trans_hs_acl_tx\n\n也就是我们在选择用什么样的transport来实现hci功能，即：\n\n- 如果我们需要在一颗芯片上运行host+controller，那么就要选ble_hci_ram.c文件，即host和controller之间用ram通信。\n- 如果我们需要在一颗芯片上运行host，另一颗芯片运行controller，那么就可以选ble_hci_uart.c文件，即host和controller之间用uart通信。\n\n> NOTE：市场上一些简单的智能设备，如手环、心率带、无线传感器，都会选择在一颗芯片上运行完整的协议栈，即host+controller，无论在成本还是开发上都会简单很多。但是一些比较复杂如多协议网关、机顶盒的产品，则需要一个强大的cpu跑linux，并用linux实现host（bluez、bluedroid），然后外挂一颗性能和成本较低的蓝牙芯片跑controller。\n\n这里我们选择ble_hci_ram.c文件，将`nimble/transport/ram/src/ble_hci_ram.c`和`cwd + '/nimble/transport/ram/include'`加进SConscript。\n\n### 2.5.2. 缺少ble_npl_xxx函数定义\n\nnpl全称为nimble porting layer，顾名思义，这些函数是协议栈需要调用的接口，协议栈不会实现这部分内容，需要我们自己去实现，协议栈用到的所有接口在`nimble_npl.h`中。\n\n这部分nimble没有注释说明接口该如何实现，移植者只能参考其他os的实现以及nimble协议栈调用接口代码，去猜这个函数做了什么，我不喜欢这一点。\n\n这里我们将rt-thread官方已经移植好的代码加进SConscript，即`porting/npl/rtthread/src/npl_os_rtthread.c`。\n\n> NOTE：需要注释掉npl_os_rtthread.c里面的ble_npl_task_init函数。\n\n## 2.6. 移植host总结\n\n总的来说，nimble中移植host功能需要关注以下几种类型代码。\n\n1. host协议核心代码\n2. 公用组件和公用函数\n3. hci transport\n4. os特定代码\n\n[myboard文件夹下载地址](https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host)\n\n# 3. 移植controller\n\n## 3.1. 移植阶段一\n\n把所有`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\controller`里面除了test文件夹以外的.c文件加进之前的SConscript脚本。\n\n按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。\n\n### 3.1.1. 无法打开头文件\n\n```\nerror:  #5: cannot open source input file \"controller/ble_ll.h\": No such file or directory\n```\n\n错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本  \n解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为`cwd + '/nimble/controller/include'`，同类报错可用同样方法解决。\n\n## 3.2. 移植阶段二\n\n前面做的移植操作，无论哪个平台都是一样的。而接下来的操作，不同的应用场景和平台，解决方案会有所差异。\n\n### 3.2.1. 无法打开头文件（存在多个同名头文件）\n\n```\nerror:  #5: cannot open source input file \"ble/xcvr.h\": No such file or directory\n```\nxcvr英文原名为transceiver，即既有包含发射器，又有接收器的radio设备。\n\n1. xcvr正常运行前需要有一段rampup时间\n2. xcvr在发射器和接收器之间切换，需要软件执行时间\n\n因为不同设备，这两个参数会有比较大差异，而ble对于时间的要求又是us级别的，所以需要移植者根据自己的硬件设备来实现。\n\n这里我们选择nrf52的xcvr文件，将`nimble/drivers/nrf52/src/ble_phy.c`和`cwd + '/nimble/drivers/nrf52/include'`加进SConscript。\n\n### 3.2.2. 缺少标识符定义\n\n```\nerror:  #20: identifier \"MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT\" is undefined\n```\n\n协议栈要正常运行必须有一些默认参数，否则编译不通过，如：射频发射功率、支持最大连接数等，参数以及参数的说明可以从目录对应的`syscfg.yml`文件获知。\n\n由于我们不使用rt-thread提供的软件包功能，所以将用[该文件](https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/npl/rtthread/include/config/config.h)替换如下路径同名文件：`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\include\\config\\config.h`。\n\n同时在`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\syscfg\\syscfg.h`文件开头位置中include该头文件：\n\n```C\n\n#ifndef H_MYNEWT_SYSCFG_\n#define H_MYNEWT_SYSCFG_\n\n...\n\n#define MYNEWT_VAL(x)                           MYNEWT_VAL_ ## x\n\n#include \"config/config.h\"\n...\n\n#endif\n```\n\n> NOTE：因为通过宏定义配置参数的文件都会include <syscfg/syscfg.h>文件，将include \"config/config.h\"放在该文件前可以起到全局配置的作用。\n\n\n### 3.2.3. 无法识别内联汇编\n\n```\nerror:  #18: expected a \")\"\n```\n\n用c来实现内联汇编的功能，用[该文件](https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/nimble/drivers/nrf52/src/ble_phy.c)替换如下路径同名文件，即：`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\drivers\\nrf52\\src\\ble_phy.c`。\n\n### 3.2.4. 缺少ble_hw.c中实现的函数\n\n解决方法：将`nimble/drivers/nrf52/src/ble_hw.c`添加进SConscript脚本。\n\n### 3.2.5. 缺少os_cputime.c中实现的函数\n\n解决方法：将`porting/nimble/src/os_cputime.c`添加进SConscript脚本。\n\n### 3.2.6. 缺少os_cputime_pwr2.c中实现的函数\n\n解决方法：将`porting/nimble/src/os_cputime_pwr2.c`添加进SConscript脚本。\n\n### 3.2.7. 缺少hal_timer.c中实现的函数\n\n解决方法：将`porting/nimble/src/hal_timer.c`添加进SConscript脚本。\n\n### 3.2.8. 缺少ble_npl_hw_set_isr函数定义\n\n```\nError: L6218E: Undefined symbol ble_npl_hw_set_isr (referred from ble_phy.o).\n```\n\n该接口用于设置中断号以及对应的中断服务函数。\n\n这里我们将`porting/npl/rtthread/src/nrf5x_isr.c`添加进SConscript脚本。\n\n### 3.2.9. 缺少ble_npl_hw_is_in_critical函数定义\n\n在`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\src\\npl_os_rtthread.c`中修改如下实现：\n\n```C\n\nvolatile int ble_npl_in_critical = 0;\n\n\nuint32_t ble_npl_hw_enter_critical(void)\n{\n    ++ble_npl_in_critical;\n    return rt_hw_interrupt_disable();\n}\n\nvoid ble_npl_hw_exit_critical(uint32_t ctx)\n{\n    --ble_npl_in_critical;\n    rt_hw_interrupt_enable(ctx);\n}\n\nbool ble_npl_hw_is_in_critical()\n{\n    return (ble_npl_in_critical > 0);\n}\n```\n\n## 3.3. 移植controller总结\n\n总的来说，nimble中移植controller功能需要关注以下几种类型代码。\n\n1. controller协议核心代码\n2. 硬件平台差异文件（ble_phy.c/ble_hw.c/nrf5x_isr.c）\n3. 公用组件和公用函数(hal_timer.c/...)\n4. 应用宏定义配置文件（config.h/syscfg.yml）\n\n[myboard文件夹下载地址](https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host_controller)\n\n# 4. 移植profile\n\n不同的应用场景对于蓝牙核心协议栈（host+controller）的用法不一样，为了规范化和互联互通，针对某些应用场景，会有一套蓝牙核心协议栈的操作指南，这份指南称为profile。\n\n## 4.1. 添加心率profile\n\n下载[rt-thread官方推荐的应用代码](https://github.com/Zero-Free/nrf52832-nimble/blob/master/packages/NimBLE-latest/apps/blehr/src/blehr.c)，添加进`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\apps\\blehr\\src\\`文件夹。\n\n1. 将`apps/blehr/src/gatt_svr.c`添加进SConscript脚本。\n2. 将`apps/blehr/src/blehr.c`添加进SConscript脚本。\n2. 将`cwd + '/apps/blehr/src'`添加进SConscript脚本。\n\n## 4.2. 移植proifile总结\n\n添加profile的过程比较杂乱，但这没办法，因为profile和os、nimble的启动方式等等都有耦合，特别是rtthread这里启动nimble的方式有点绕。\n\n\n# 5. 启动运行\n\n经过上节处理之后，编译报以下错误：\n\n```\nError: L6218E: Undefined symbol ble_hs_thread_startup (referred from blehr.o).\n```\n\n解决方法：将`porting/npl/rtthread/src/nimble_port_rtthread.c`添加进SConscript脚本。\n\n通过阅读`nimble_port_rttherad.c`文件得知，如果需要支持controller，还需要先增加宏定义`NIMBLE_CFG_CONTROLLER=1`，所以将该宏定义添加进SConscript脚本。\n\n## 5.1. 缺少标识符定义\n\n```\nerror:  #20: identifier \"MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE\" is undefined\n\nerror:  #20: identifier \"MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY\" is undefined\n\nerror:  #20: identifier \"MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE\" is undefined\n\nerror:  #20: identifier \"MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY\" is undefined\n```\n\n在`porting/npl/rtthread/include/config/config.h`文件添加以下内容：\n\n```C\n//thread config\n#ifndef MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE\n#define MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE     (2048)\n#endif\n\n#ifndef MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY\n#define MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY       (5)\n#endif\n\n\n#ifndef MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE\n#define MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE       (2048)\n#endif\n\n#ifndef MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY\n#define MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY         (4) // must higher than MYNEWT_VAL_BLE_HOST_TASK_PRIORITY, numerically smaller\n#endif\n```\n\n## 5.2. 修复bug\n\n将`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\os\\endian.h`文件\n```C\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n```\n\n改为：\n\n```C\n#if defined (__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n```\n\n## 5.3. 添加调试\n\n将`porting/npl/rtthread/src/modlog.c`添加进SConscript脚本。\n\n用[该文件](https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/npl/rtthread/src/modlog.c)替换`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\src\\modlog.c`。\n\n用[该文件](https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/nimble/include/modlog/modlog.h)替换`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\modlog\\modlog.h`。\n\n## 5.4. 编译烧录\n\n[myboard文件夹下载地址](https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host_controller_profile)\n\n生成工程、编译、烧录后，在串口调试助手输入`ble_hr`，设备开始广播。\n\n![](ble_hr.gif)\n\n# 6. 总结\n\n通过这一章节的学习，对于nimble的目录结构、参数配置方式，有更深刻的认识。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/rtt-nimble揭秘系列——移植nimble（3）.md","raw":"---\ntitle: rtt+nimble揭秘系列——移植nimble（3）\ndate: 2019-10-09 00:24:44\ntags:\n- rtthread\n- nimble\n\ncategories:\n- 一得之见\n---\n\n站在巨人的肩膀上可以看的更远。\n<!-- more --> \n\n前言\n===\n\n移植目标：手机app可以搜索到ble广播，能成功连接并发现服务。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 土方法](#1-土方法)\n- [2. 移植host](#2-移植host)\n    - [2.1. 添加nimble](#21-添加nimble)\n    - [2.2. 添加空白SConscript](#22-添加空白sconscript)\n    - [2.3. 移植阶段一](#23-移植阶段一)\n        - [2.3.1. 无法打开头文件](#231-无法打开头文件)\n        - [2.3.2. 无法打开头文件（缺少头文件）](#232-无法打开头文件缺少头文件)\n        - [2.3.3. 无法打开头文件（存在多个同名头文件）](#233-无法打开头文件存在多个同名头文件)\n        - [2.3.4. 缺少标识符定义](#234-缺少标识符定义)\n    - [2.4. 移植阶段二](#24-移植阶段二)\n        - [2.4.1. 缺少endian.c中实现的函数](#241-缺少endianc中实现的函数)\n        - [2.4.2. 缺少mem.c中实现的函数](#242-缺少memc中实现的函数)\n        - [2.4.3. 缺少os_mbuf.c实现的函数](#243-缺少os_mbufc实现的函数)\n        - [2.4.4. 缺少os_mempool.c实现的函数](#244-缺少os_mempoolc实现的函数)\n        - [2.4.5. 缺少nimble_port.c实现的函数](#245-缺少nimble_portc实现的函数)\n        - [2.4.6. 缺少os_msys_init.c实现的函数](#246-缺少os_msys_initc实现的函数)\n        - [2.4.7. 缺少tinycrypt加密组件](#247-缺少tinycrypt加密组件)\n    - [2.5. 移植阶段三](#25-移植阶段三)\n        - [2.5.1. 存在多个ble_hc_trans_xxxx同名函数](#251-存在多个ble_hc_trans_xxxx同名函数)\n        - [2.5.2. 缺少ble_npl_xxx函数定义](#252-缺少ble_npl_xxx函数定义)\n    - [2.6. 移植host总结](#26-移植host总结)\n- [3. 移植controller](#3-移植controller)\n    - [3.1. 移植阶段一](#31-移植阶段一)\n        - [3.1.1. 无法打开头文件](#311-无法打开头文件)\n    - [3.2. 移植阶段二](#32-移植阶段二)\n        - [3.2.1. 无法打开头文件（存在多个同名头文件）](#321-无法打开头文件存在多个同名头文件)\n        - [3.2.2. 缺少标识符定义](#322-缺少标识符定义)\n        - [3.2.3. 无法识别内联汇编](#323-无法识别内联汇编)\n        - [3.2.4. 缺少ble_hw.c中实现的函数](#324-缺少ble_hwc中实现的函数)\n        - [3.2.5. 缺少os_cputime.c中实现的函数](#325-缺少os_cputimec中实现的函数)\n        - [3.2.6. 缺少os_cputime_pwr2.c中实现的函数](#326-缺少os_cputime_pwr2c中实现的函数)\n        - [3.2.7. 缺少hal_timer.c中实现的函数](#327-缺少hal_timerc中实现的函数)\n        - [3.2.8. 缺少ble_npl_hw_set_isr函数定义](#328-缺少ble_npl_hw_set_isr函数定义)\n        - [3.2.9. 缺少ble_npl_hw_is_in_critical函数定义](#329-缺少ble_npl_hw_is_in_critical函数定义)\n    - [3.3. 移植controller总结](#33-移植controller总结)\n- [4. 移植profile](#4-移植profile)\n    - [4.1. 添加心率profile](#41-添加心率profile)\n    - [4.2. 移植proifile总结](#42-移植proifile总结)\n- [5. 启动运行](#5-启动运行)\n    - [5.1. 缺少标识符定义](#51-缺少标识符定义)\n    - [5.2. 修复bug](#52-修复bug)\n    - [5.3. 添加调试](#53-添加调试)\n    - [5.4. 编译烧录](#54-编译烧录)\n- [6. 总结](#6-总结)\n\n<!-- /TOC -->\n\n\n# 1. 土方法\n\n第一个问题，nimble的porting目录看不懂，钻牛角尖要不得，故跑到[大佬](https://github.com/Zero-Free/nrf52832-nimble)的github上寻求解决方案。\n\n然后有了第一个解决思路：基于可以正常运行的工程，将部分nimble源文件从SConscript脚本中移除。\n\n然后第二个问题来了，移除哪些源文件？\n\n按照笔者对[nimble官方文档](http://mynewt.apache.org/latest/network/docs/ble_setup/ble_sync_cb.html)的了解，nimble支持host和controller解耦，那么第一步移植工作就先保留host代码，将controller部分全部移除掉。\n\n# 2. 移植host\n\n## 2.1. 添加nimble\n\n将官网下载的nimble压缩包解压，并将生成的文件夹复制粘贴到myboard目录下，即`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0`。\n\n## 2.2. 添加空白SConscript\n\n添加SConscript文件到nimble目录下，即`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\SConscript`。\n\n## 2.3. 移植阶段一\n\n把所有`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\host`里面除了mesh文件夹和test文件夹以外的.c文件加进刚创建的空白SConscript脚本。\n\n> NOTE：ble mesh后面再挖坑，这里先不展开。\n\n按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。\n\n### 2.3.1. 无法打开头文件\n\n```\nerror:  #5: cannot open source input file \"sysinit/sysinit.h\": No such file or directory\n```\n\n错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本  \n解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为`cwd + '/porting/nimble/include'`，同类报错可用同样方法解决。\n\n### 2.3.2. 无法打开头文件（缺少头文件）\n\n```\nerror:  #5: cannot open source input file \"base64/base64.h\": No such file or directory\n```\n\n错误原因：nimble包没有该文件  \n解决办法：从mynewt的`encoding`目录下，拷贝`base64`到`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\ext\\`，并在SConscript中添加路径，该例子需要添加的路径为`cwd + '/ext/base64/include'`。\n\n### 2.3.3. 无法打开头文件（存在多个同名头文件）\n\n```\nerror:  #5: cannot open source input file \"nimble/nimble_npl_os.h\": No such file or directory\n```\n\n错误原因：nimble包有多个该文件，只是没有将头文件目录添加进编译脚本  \n解决方法：该文件定义了os的抽象接口，协议栈会调用这些接口，这些接口的实现每个os都不一样，我们这里参考[rt-thread官方做法](https://github.com/Zero-Free/nrf52832-nimble/tree/master/packages/NimBLE-latest/porting/npl/rtthread)，直接下载该文件夹到`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl`下，并在SConscript中添加路径，该例子需要添加的路径为`cwd + '/porting/npl/rtthread/include'`。\n\n### 2.3.4. 缺少标识符定义\n\n```\nerror:  #20: identifier \"MYNEWT_VAL_BLEUART_MAX_INPUT\" is undefined\n```\n\n错误原因：缺少宏定义  \n解决方法：将`nimble/host/services/bleuart/src/bleuart.c`从SConscript脚本中删除，暂不考虑实现该profile。\n\n```\nerror:  #20: identifier \"MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT\" is undefined\n```\n\n错误原因：缺少宏定义  \n解决方法：将`nimble/host/services/dis/src/ble_svc_dis.c`从SConscript脚本中删除，暂不考虑实现该profile。\n\n## 2.4. 移植阶段二\n\n经过上节处理之后，编译均是以下错误：\n\n```\nError: L6218E: Undefined symbol xxxx (referred from xxxx).\n```\n\nhost文件夹内的代码会引用其他目录下的`公共组件`以及`公共函数`。组件如：内存池，函数如：大小端转换函数。\n\n所以该阶段目标是将host文件夹依赖的`公共组件`和`公共函数`补充完整。\n\n### 2.4.1. 缺少endian.c中实现的函数\n\n解决方法：将`porting/nimble/src/endian.c`添加进SConscript脚本。\n\n### 2.4.2. 缺少mem.c中实现的函数\n\n解决方法：将`porting/nimble/src/mem.c`添加进SConscript脚本。\n\n### 2.4.3. 缺少os_mbuf.c实现的函数\n\n解决方法：将`porting/nimble/src/os_mbuf.c`添加进SConscript脚本。\n\n### 2.4.4. 缺少os_mempool.c实现的函数\n\n解决方法：将`porting/nimble/src/os_mempool.c`添加进SConscript脚本。\n\n### 2.4.5. 缺少nimble_port.c实现的函数\n\n解决方法：将`porting/nimble/src/nimble_port.c`添加进SConscript脚本。\n\n### 2.4.6. 缺少os_msys_init.c实现的函数\n\n解决方法：将`porting/nimble/src/os_msys_init.c`添加进SConscript脚本。\n\n\n### 2.4.7. 缺少tinycrypt加密组件\n\n解决方法：添加以下路径到SConscript文件。  \n`ext/tinycrypt/src/aes_decrypt.c`  \n`ext/tinycrypt/src/aes_encrypt.c`  \n`ext/tinycrypt/src/utils.c`\n\n\n## 2.5. 移植阶段三\n\n经过上节处理之后，编译剩下以下错误：\n\n```\n1. Error: L6218E: Undefined symbol ble_hci_trans_xxxx (referred from xxxx).\n2. Error: L6218E: Undefined symbol ble_npl_xxx (referred from xxxx).\n```\n\n前面做的移植操作，哪个平台都是一样的。而对于这两类错误，不同的应用场景和平台，解决方案会有所差异。\n\n### 2.5.1. 存在多个ble_hc_trans_xxxx同名函数\n\n全局搜索nimble包会发现这些函数在多个.c文件中都有实现，位置如下：\n\n```\n apache-mynewt-nimble-1.2.0\n └──nimble         \n     └──transport\n            ├──da1469x\n            │     └──src\n            │         └──da1469x_ble_hci.c\n            ├──emspi\n            │    └──src\n            │        └──ble_hci_emspi.c\n            ├──ram\n            │    └──src\n            │        └──ble_hci_ram.c\n            ├──socket\n            │    └──src\n            │        └──ble_hci_socket.c\n            └──uart\n                └──src\n                    └──ble_hci_uart.c\n\n```\n\n这意味着我们需要做出选择，为这些函数接口选择具体实现。这时候引入新问题，“我们在选择什么”。\n\n参考[这篇blog](https://jaydenh215.github.io/2019/10/09/%E6%B5%85%E8%B0%88BLE%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B8%A7/)，可知：\n\nhost和controller可通过hci（host-controller-interface）接口互相通信。具体表现为：\n\n- host通过hci向controller发送command\n- controller通过hci向host发送event\n- host和controller通过hci互传acl data\n\n而编译报错缺失的ble_hc_trans_xxxx函数为：\n\n- ble_hci_trans_reset\n- ble_hci_trans_cfg_hs（该API注册接收evt和acl data的回调函数）\n- ble_hci_trans_buf_alloc\n- ble_hci_trans_buf_free\n- ble_hci_trans_hs_cmd_tx\n- ble_hci_trans_hs_acl_tx\n\n也就是我们在选择用什么样的transport来实现hci功能，即：\n\n- 如果我们需要在一颗芯片上运行host+controller，那么就要选ble_hci_ram.c文件，即host和controller之间用ram通信。\n- 如果我们需要在一颗芯片上运行host，另一颗芯片运行controller，那么就可以选ble_hci_uart.c文件，即host和controller之间用uart通信。\n\n> NOTE：市场上一些简单的智能设备，如手环、心率带、无线传感器，都会选择在一颗芯片上运行完整的协议栈，即host+controller，无论在成本还是开发上都会简单很多。但是一些比较复杂如多协议网关、机顶盒的产品，则需要一个强大的cpu跑linux，并用linux实现host（bluez、bluedroid），然后外挂一颗性能和成本较低的蓝牙芯片跑controller。\n\n这里我们选择ble_hci_ram.c文件，将`nimble/transport/ram/src/ble_hci_ram.c`和`cwd + '/nimble/transport/ram/include'`加进SConscript。\n\n### 2.5.2. 缺少ble_npl_xxx函数定义\n\nnpl全称为nimble porting layer，顾名思义，这些函数是协议栈需要调用的接口，协议栈不会实现这部分内容，需要我们自己去实现，协议栈用到的所有接口在`nimble_npl.h`中。\n\n这部分nimble没有注释说明接口该如何实现，移植者只能参考其他os的实现以及nimble协议栈调用接口代码，去猜这个函数做了什么，我不喜欢这一点。\n\n这里我们将rt-thread官方已经移植好的代码加进SConscript，即`porting/npl/rtthread/src/npl_os_rtthread.c`。\n\n> NOTE：需要注释掉npl_os_rtthread.c里面的ble_npl_task_init函数。\n\n## 2.6. 移植host总结\n\n总的来说，nimble中移植host功能需要关注以下几种类型代码。\n\n1. host协议核心代码\n2. 公用组件和公用函数\n3. hci transport\n4. os特定代码\n\n[myboard文件夹下载地址](https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host)\n\n# 3. 移植controller\n\n## 3.1. 移植阶段一\n\n把所有`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\controller`里面除了test文件夹以外的.c文件加进之前的SConscript脚本。\n\n按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。\n\n### 3.1.1. 无法打开头文件\n\n```\nerror:  #5: cannot open source input file \"controller/ble_ll.h\": No such file or directory\n```\n\n错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本  \n解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为`cwd + '/nimble/controller/include'`，同类报错可用同样方法解决。\n\n## 3.2. 移植阶段二\n\n前面做的移植操作，无论哪个平台都是一样的。而接下来的操作，不同的应用场景和平台，解决方案会有所差异。\n\n### 3.2.1. 无法打开头文件（存在多个同名头文件）\n\n```\nerror:  #5: cannot open source input file \"ble/xcvr.h\": No such file or directory\n```\nxcvr英文原名为transceiver，即既有包含发射器，又有接收器的radio设备。\n\n1. xcvr正常运行前需要有一段rampup时间\n2. xcvr在发射器和接收器之间切换，需要软件执行时间\n\n因为不同设备，这两个参数会有比较大差异，而ble对于时间的要求又是us级别的，所以需要移植者根据自己的硬件设备来实现。\n\n这里我们选择nrf52的xcvr文件，将`nimble/drivers/nrf52/src/ble_phy.c`和`cwd + '/nimble/drivers/nrf52/include'`加进SConscript。\n\n### 3.2.2. 缺少标识符定义\n\n```\nerror:  #20: identifier \"MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT\" is undefined\n```\n\n协议栈要正常运行必须有一些默认参数，否则编译不通过，如：射频发射功率、支持最大连接数等，参数以及参数的说明可以从目录对应的`syscfg.yml`文件获知。\n\n由于我们不使用rt-thread提供的软件包功能，所以将用[该文件](https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/npl/rtthread/include/config/config.h)替换如下路径同名文件：`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\include\\config\\config.h`。\n\n同时在`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\syscfg\\syscfg.h`文件开头位置中include该头文件：\n\n```C\n\n#ifndef H_MYNEWT_SYSCFG_\n#define H_MYNEWT_SYSCFG_\n\n...\n\n#define MYNEWT_VAL(x)                           MYNEWT_VAL_ ## x\n\n#include \"config/config.h\"\n...\n\n#endif\n```\n\n> NOTE：因为通过宏定义配置参数的文件都会include <syscfg/syscfg.h>文件，将include \"config/config.h\"放在该文件前可以起到全局配置的作用。\n\n\n### 3.2.3. 无法识别内联汇编\n\n```\nerror:  #18: expected a \")\"\n```\n\n用c来实现内联汇编的功能，用[该文件](https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/nimble/drivers/nrf52/src/ble_phy.c)替换如下路径同名文件，即：`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\drivers\\nrf52\\src\\ble_phy.c`。\n\n### 3.2.4. 缺少ble_hw.c中实现的函数\n\n解决方法：将`nimble/drivers/nrf52/src/ble_hw.c`添加进SConscript脚本。\n\n### 3.2.5. 缺少os_cputime.c中实现的函数\n\n解决方法：将`porting/nimble/src/os_cputime.c`添加进SConscript脚本。\n\n### 3.2.6. 缺少os_cputime_pwr2.c中实现的函数\n\n解决方法：将`porting/nimble/src/os_cputime_pwr2.c`添加进SConscript脚本。\n\n### 3.2.7. 缺少hal_timer.c中实现的函数\n\n解决方法：将`porting/nimble/src/hal_timer.c`添加进SConscript脚本。\n\n### 3.2.8. 缺少ble_npl_hw_set_isr函数定义\n\n```\nError: L6218E: Undefined symbol ble_npl_hw_set_isr (referred from ble_phy.o).\n```\n\n该接口用于设置中断号以及对应的中断服务函数。\n\n这里我们将`porting/npl/rtthread/src/nrf5x_isr.c`添加进SConscript脚本。\n\n### 3.2.9. 缺少ble_npl_hw_is_in_critical函数定义\n\n在`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\src\\npl_os_rtthread.c`中修改如下实现：\n\n```C\n\nvolatile int ble_npl_in_critical = 0;\n\n\nuint32_t ble_npl_hw_enter_critical(void)\n{\n    ++ble_npl_in_critical;\n    return rt_hw_interrupt_disable();\n}\n\nvoid ble_npl_hw_exit_critical(uint32_t ctx)\n{\n    --ble_npl_in_critical;\n    rt_hw_interrupt_enable(ctx);\n}\n\nbool ble_npl_hw_is_in_critical()\n{\n    return (ble_npl_in_critical > 0);\n}\n```\n\n## 3.3. 移植controller总结\n\n总的来说，nimble中移植controller功能需要关注以下几种类型代码。\n\n1. controller协议核心代码\n2. 硬件平台差异文件（ble_phy.c/ble_hw.c/nrf5x_isr.c）\n3. 公用组件和公用函数(hal_timer.c/...)\n4. 应用宏定义配置文件（config.h/syscfg.yml）\n\n[myboard文件夹下载地址](https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host_controller)\n\n# 4. 移植profile\n\n不同的应用场景对于蓝牙核心协议栈（host+controller）的用法不一样，为了规范化和互联互通，针对某些应用场景，会有一套蓝牙核心协议栈的操作指南，这份指南称为profile。\n\n## 4.1. 添加心率profile\n\n下载[rt-thread官方推荐的应用代码](https://github.com/Zero-Free/nrf52832-nimble/blob/master/packages/NimBLE-latest/apps/blehr/src/blehr.c)，添加进`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\apps\\blehr\\src\\`文件夹。\n\n1. 将`apps/blehr/src/gatt_svr.c`添加进SConscript脚本。\n2. 将`apps/blehr/src/blehr.c`添加进SConscript脚本。\n2. 将`cwd + '/apps/blehr/src'`添加进SConscript脚本。\n\n## 4.2. 移植proifile总结\n\n添加profile的过程比较杂乱，但这没办法，因为profile和os、nimble的启动方式等等都有耦合，特别是rtthread这里启动nimble的方式有点绕。\n\n\n# 5. 启动运行\n\n经过上节处理之后，编译报以下错误：\n\n```\nError: L6218E: Undefined symbol ble_hs_thread_startup (referred from blehr.o).\n```\n\n解决方法：将`porting/npl/rtthread/src/nimble_port_rtthread.c`添加进SConscript脚本。\n\n通过阅读`nimble_port_rttherad.c`文件得知，如果需要支持controller，还需要先增加宏定义`NIMBLE_CFG_CONTROLLER=1`，所以将该宏定义添加进SConscript脚本。\n\n## 5.1. 缺少标识符定义\n\n```\nerror:  #20: identifier \"MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE\" is undefined\n\nerror:  #20: identifier \"MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY\" is undefined\n\nerror:  #20: identifier \"MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE\" is undefined\n\nerror:  #20: identifier \"MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY\" is undefined\n```\n\n在`porting/npl/rtthread/include/config/config.h`文件添加以下内容：\n\n```C\n//thread config\n#ifndef MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE\n#define MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE     (2048)\n#endif\n\n#ifndef MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY\n#define MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY       (5)\n#endif\n\n\n#ifndef MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE\n#define MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE       (2048)\n#endif\n\n#ifndef MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY\n#define MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY         (4) // must higher than MYNEWT_VAL_BLE_HOST_TASK_PRIORITY, numerically smaller\n#endif\n```\n\n## 5.2. 修复bug\n\n将`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\os\\endian.h`文件\n```C\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n```\n\n改为：\n\n```C\n#if defined (__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n```\n\n## 5.3. 添加调试\n\n将`porting/npl/rtthread/src/modlog.c`添加进SConscript脚本。\n\n用[该文件](https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/npl/rtthread/src/modlog.c)替换`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\src\\modlog.c`。\n\n用[该文件](https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/nimble/include/modlog/modlog.h)替换`rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\modlog\\modlog.h`。\n\n## 5.4. 编译烧录\n\n[myboard文件夹下载地址](https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host_controller_profile)\n\n生成工程、编译、烧录后，在串口调试助手输入`ble_hr`，设备开始广播。\n\n![](ble_hr.gif)\n\n# 6. 总结\n\n通过这一章节的学习，对于nimble的目录结构、参数配置方式，有更深刻的认识。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"rtt-nimble揭秘系列——移植nimble（3）","published":1,"updated":"2019-10-23T05:10:56.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8q8l001hgcg8gwvpjcki","content":"<p>站在巨人的肩膀上可以看的更远。<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>移植目标：手机app可以搜索到ble广播，能成功连接并发现服务。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-土方法\">1. 土方法</a></li>\n<li><a href=\"#2-移植host\">2. 移植host</a><ul>\n<li><a href=\"#21-添加nimble\">2.1. 添加nimble</a></li>\n<li><a href=\"#22-添加空白sconscript\">2.2. 添加空白SConscript</a></li>\n<li><a href=\"#23-移植阶段一\">2.3. 移植阶段一</a><ul>\n<li><a href=\"#231-无法打开头文件\">2.3.1. 无法打开头文件</a></li>\n<li><a href=\"#232-无法打开头文件缺少头文件\">2.3.2. 无法打开头文件（缺少头文件）</a></li>\n<li><a href=\"#233-无法打开头文件存在多个同名头文件\">2.3.3. 无法打开头文件（存在多个同名头文件）</a></li>\n<li><a href=\"#234-缺少标识符定义\">2.3.4. 缺少标识符定义</a></li>\n</ul>\n</li>\n<li><a href=\"#24-移植阶段二\">2.4. 移植阶段二</a><ul>\n<li><a href=\"#241-缺少endianc中实现的函数\">2.4.1. 缺少endian.c中实现的函数</a></li>\n<li><a href=\"#242-缺少memc中实现的函数\">2.4.2. 缺少mem.c中实现的函数</a></li>\n<li><a href=\"#243-缺少os_mbufc实现的函数\">2.4.3. 缺少os_mbuf.c实现的函数</a></li>\n<li><a href=\"#244-缺少os_mempoolc实现的函数\">2.4.4. 缺少os_mempool.c实现的函数</a></li>\n<li><a href=\"#245-缺少nimble_portc实现的函数\">2.4.5. 缺少nimble_port.c实现的函数</a></li>\n<li><a href=\"#246-缺少os_msys_initc实现的函数\">2.4.6. 缺少os_msys_init.c实现的函数</a></li>\n<li><a href=\"#247-缺少tinycrypt加密组件\">2.4.7. 缺少tinycrypt加密组件</a></li>\n</ul>\n</li>\n<li><a href=\"#25-移植阶段三\">2.5. 移植阶段三</a><ul>\n<li><a href=\"#251-存在多个ble_hc_trans_xxxx同名函数\">2.5.1. 存在多个ble_hc_trans_xxxx同名函数</a></li>\n<li><a href=\"#252-缺少ble_npl_xxx函数定义\">2.5.2. 缺少ble_npl_xxx函数定义</a></li>\n</ul>\n</li>\n<li><a href=\"#26-移植host总结\">2.6. 移植host总结</a></li>\n</ul>\n</li>\n<li><a href=\"#3-移植controller\">3. 移植controller</a><ul>\n<li><a href=\"#31-移植阶段一\">3.1. 移植阶段一</a><ul>\n<li><a href=\"#311-无法打开头文件\">3.1.1. 无法打开头文件</a></li>\n</ul>\n</li>\n<li><a href=\"#32-移植阶段二\">3.2. 移植阶段二</a><ul>\n<li><a href=\"#321-无法打开头文件存在多个同名头文件\">3.2.1. 无法打开头文件（存在多个同名头文件）</a></li>\n<li><a href=\"#322-缺少标识符定义\">3.2.2. 缺少标识符定义</a></li>\n<li><a href=\"#323-无法识别内联汇编\">3.2.3. 无法识别内联汇编</a></li>\n<li><a href=\"#324-缺少ble_hwc中实现的函数\">3.2.4. 缺少ble_hw.c中实现的函数</a></li>\n<li><a href=\"#325-缺少os_cputimec中实现的函数\">3.2.5. 缺少os_cputime.c中实现的函数</a></li>\n<li><a href=\"#326-缺少os_cputime_pwr2c中实现的函数\">3.2.6. 缺少os_cputime_pwr2.c中实现的函数</a></li>\n<li><a href=\"#327-缺少hal_timerc中实现的函数\">3.2.7. 缺少hal_timer.c中实现的函数</a></li>\n<li><a href=\"#328-缺少ble_npl_hw_set_isr函数定义\">3.2.8. 缺少ble_npl_hw_set_isr函数定义</a></li>\n<li><a href=\"#329-缺少ble_npl_hw_is_in_critical函数定义\">3.2.9. 缺少ble_npl_hw_is_in_critical函数定义</a></li>\n</ul>\n</li>\n<li><a href=\"#33-移植controller总结\">3.3. 移植controller总结</a></li>\n</ul>\n</li>\n<li><a href=\"#4-移植profile\">4. 移植profile</a><ul>\n<li><a href=\"#41-添加心率profile\">4.1. 添加心率profile</a></li>\n<li><a href=\"#42-移植proifile总结\">4.2. 移植proifile总结</a></li>\n</ul>\n</li>\n<li><a href=\"#5-启动运行\">5. 启动运行</a><ul>\n<li><a href=\"#51-缺少标识符定义\">5.1. 缺少标识符定义</a></li>\n<li><a href=\"#52-修复bug\">5.2. 修复bug</a></li>\n<li><a href=\"#53-添加调试\">5.3. 添加调试</a></li>\n<li><a href=\"#54-编译烧录\">5.4. 编译烧录</a></li>\n</ul>\n</li>\n<li><a href=\"#6-总结\">6. 总结</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-土方法\"><a href=\"#1-土方法\" class=\"headerlink\" title=\"1. 土方法\"></a>1. 土方法</h1><p>第一个问题，nimble的porting目录看不懂，钻牛角尖要不得，故跑到<a href=\"https://github.com/Zero-Free/nrf52832-nimble\" target=\"_blank\" rel=\"noopener\">大佬</a>的github上寻求解决方案。</p>\n<p>然后有了第一个解决思路：基于可以正常运行的工程，将部分nimble源文件从SConscript脚本中移除。</p>\n<p>然后第二个问题来了，移除哪些源文件？</p>\n<p>按照笔者对<a href=\"http://mynewt.apache.org/latest/network/docs/ble_setup/ble_sync_cb.html\" target=\"_blank\" rel=\"noopener\">nimble官方文档</a>的了解，nimble支持host和controller解耦，那么第一步移植工作就先保留host代码，将controller部分全部移除掉。</p>\n<h1 id=\"2-移植host\"><a href=\"#2-移植host\" class=\"headerlink\" title=\"2. 移植host\"></a>2. 移植host</h1><h2 id=\"2-1-添加nimble\"><a href=\"#2-1-添加nimble\" class=\"headerlink\" title=\"2.1. 添加nimble\"></a>2.1. 添加nimble</h2><p>将官网下载的nimble压缩包解压，并将生成的文件夹复制粘贴到myboard目录下，即<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0</code>。</p>\n<h2 id=\"2-2-添加空白SConscript\"><a href=\"#2-2-添加空白SConscript\" class=\"headerlink\" title=\"2.2. 添加空白SConscript\"></a>2.2. 添加空白SConscript</h2><p>添加SConscript文件到nimble目录下，即<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\SConscript</code>。</p>\n<h2 id=\"2-3-移植阶段一\"><a href=\"#2-3-移植阶段一\" class=\"headerlink\" title=\"2.3. 移植阶段一\"></a>2.3. 移植阶段一</h2><p>把所有<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\host</code>里面除了mesh文件夹和test文件夹以外的.c文件加进刚创建的空白SConscript脚本。</p>\n<blockquote>\n<p>NOTE：ble mesh后面再挖坑，这里先不展开。</p>\n</blockquote>\n<p>按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。</p>\n<h3 id=\"2-3-1-无法打开头文件\"><a href=\"#2-3-1-无法打开头文件\" class=\"headerlink\" title=\"2.3.1. 无法打开头文件\"></a>2.3.1. 无法打开头文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;sysinit/sysinit.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本<br>解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为<code>cwd + &#39;/porting/nimble/include&#39;</code>，同类报错可用同样方法解决。</p>\n<h3 id=\"2-3-2-无法打开头文件（缺少头文件）\"><a href=\"#2-3-2-无法打开头文件（缺少头文件）\" class=\"headerlink\" title=\"2.3.2. 无法打开头文件（缺少头文件）\"></a>2.3.2. 无法打开头文件（缺少头文件）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;base64/base64.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>错误原因：nimble包没有该文件<br>解决办法：从mynewt的<code>encoding</code>目录下，拷贝<code>base64</code>到<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\ext\\</code>，并在SConscript中添加路径，该例子需要添加的路径为<code>cwd + &#39;/ext/base64/include&#39;</code>。</p>\n<h3 id=\"2-3-3-无法打开头文件（存在多个同名头文件）\"><a href=\"#2-3-3-无法打开头文件（存在多个同名头文件）\" class=\"headerlink\" title=\"2.3.3. 无法打开头文件（存在多个同名头文件）\"></a>2.3.3. 无法打开头文件（存在多个同名头文件）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;nimble/nimble_npl_os.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>错误原因：nimble包有多个该文件，只是没有将头文件目录添加进编译脚本<br>解决方法：该文件定义了os的抽象接口，协议栈会调用这些接口，这些接口的实现每个os都不一样，我们这里参考<a href=\"https://github.com/Zero-Free/nrf52832-nimble/tree/master/packages/NimBLE-latest/porting/npl/rtthread\" target=\"_blank\" rel=\"noopener\">rt-thread官方做法</a>，直接下载该文件夹到<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl</code>下，并在SConscript中添加路径，该例子需要添加的路径为<code>cwd + &#39;/porting/npl/rtthread/include&#39;</code>。</p>\n<h3 id=\"2-3-4-缺少标识符定义\"><a href=\"#2-3-4-缺少标识符定义\" class=\"headerlink\" title=\"2.3.4. 缺少标识符定义\"></a>2.3.4. 缺少标识符定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLEUART_MAX_INPUT&quot; is undefined</span><br></pre></td></tr></table></figure>\n<p>错误原因：缺少宏定义<br>解决方法：将<code>nimble/host/services/bleuart/src/bleuart.c</code>从SConscript脚本中删除，暂不考虑实现该profile。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT&quot; is undefined</span><br></pre></td></tr></table></figure>\n<p>错误原因：缺少宏定义<br>解决方法：将<code>nimble/host/services/dis/src/ble_svc_dis.c</code>从SConscript脚本中删除，暂不考虑实现该profile。</p>\n<h2 id=\"2-4-移植阶段二\"><a href=\"#2-4-移植阶段二\" class=\"headerlink\" title=\"2.4. 移植阶段二\"></a>2.4. 移植阶段二</h2><p>经过上节处理之后，编译均是以下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: L6218E: Undefined symbol xxxx (referred from xxxx).</span><br></pre></td></tr></table></figure>\n<p>host文件夹内的代码会引用其他目录下的<code>公共组件</code>以及<code>公共函数</code>。组件如：内存池，函数如：大小端转换函数。</p>\n<p>所以该阶段目标是将host文件夹依赖的<code>公共组件</code>和<code>公共函数</code>补充完整。</p>\n<h3 id=\"2-4-1-缺少endian-c中实现的函数\"><a href=\"#2-4-1-缺少endian-c中实现的函数\" class=\"headerlink\" title=\"2.4.1. 缺少endian.c中实现的函数\"></a>2.4.1. 缺少endian.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/endian.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-2-缺少mem-c中实现的函数\"><a href=\"#2-4-2-缺少mem-c中实现的函数\" class=\"headerlink\" title=\"2.4.2. 缺少mem.c中实现的函数\"></a>2.4.2. 缺少mem.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/mem.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-3-缺少os-mbuf-c实现的函数\"><a href=\"#2-4-3-缺少os-mbuf-c实现的函数\" class=\"headerlink\" title=\"2.4.3. 缺少os_mbuf.c实现的函数\"></a>2.4.3. 缺少os_mbuf.c实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_mbuf.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-4-缺少os-mempool-c实现的函数\"><a href=\"#2-4-4-缺少os-mempool-c实现的函数\" class=\"headerlink\" title=\"2.4.4. 缺少os_mempool.c实现的函数\"></a>2.4.4. 缺少os_mempool.c实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_mempool.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-5-缺少nimble-port-c实现的函数\"><a href=\"#2-4-5-缺少nimble-port-c实现的函数\" class=\"headerlink\" title=\"2.4.5. 缺少nimble_port.c实现的函数\"></a>2.4.5. 缺少nimble_port.c实现的函数</h3><p>解决方法：将<code>porting/nimble/src/nimble_port.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-6-缺少os-msys-init-c实现的函数\"><a href=\"#2-4-6-缺少os-msys-init-c实现的函数\" class=\"headerlink\" title=\"2.4.6. 缺少os_msys_init.c实现的函数\"></a>2.4.6. 缺少os_msys_init.c实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_msys_init.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-7-缺少tinycrypt加密组件\"><a href=\"#2-4-7-缺少tinycrypt加密组件\" class=\"headerlink\" title=\"2.4.7. 缺少tinycrypt加密组件\"></a>2.4.7. 缺少tinycrypt加密组件</h3><p>解决方法：添加以下路径到SConscript文件。<br><code>ext/tinycrypt/src/aes_decrypt.c</code><br><code>ext/tinycrypt/src/aes_encrypt.c</code><br><code>ext/tinycrypt/src/utils.c</code></p>\n<h2 id=\"2-5-移植阶段三\"><a href=\"#2-5-移植阶段三\" class=\"headerlink\" title=\"2.5. 移植阶段三\"></a>2.5. 移植阶段三</h2><p>经过上节处理之后，编译剩下以下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Error: L6218E: Undefined symbol ble_hci_trans_xxxx (referred from xxxx).</span><br><span class=\"line\">2. Error: L6218E: Undefined symbol ble_npl_xxx (referred from xxxx).</span><br></pre></td></tr></table></figure>\n<p>前面做的移植操作，哪个平台都是一样的。而对于这两类错误，不同的应用场景和平台，解决方案会有所差异。</p>\n<h3 id=\"2-5-1-存在多个ble-hc-trans-xxxx同名函数\"><a href=\"#2-5-1-存在多个ble-hc-trans-xxxx同名函数\" class=\"headerlink\" title=\"2.5.1. 存在多个ble_hc_trans_xxxx同名函数\"></a>2.5.1. 存在多个ble_hc_trans_xxxx同名函数</h3><p>全局搜索nimble包会发现这些函数在多个.c文件中都有实现，位置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apache-mynewt-nimble-1.2.0</span><br><span class=\"line\">└──nimble         </span><br><span class=\"line\">    └──transport</span><br><span class=\"line\">           ├──da1469x</span><br><span class=\"line\">           │     └──src</span><br><span class=\"line\">           │         └──da1469x_ble_hci.c</span><br><span class=\"line\">           ├──emspi</span><br><span class=\"line\">           │    └──src</span><br><span class=\"line\">           │        └──ble_hci_emspi.c</span><br><span class=\"line\">           ├──ram</span><br><span class=\"line\">           │    └──src</span><br><span class=\"line\">           │        └──ble_hci_ram.c</span><br><span class=\"line\">           ├──socket</span><br><span class=\"line\">           │    └──src</span><br><span class=\"line\">           │        └──ble_hci_socket.c</span><br><span class=\"line\">           └──uart</span><br><span class=\"line\">               └──src</span><br><span class=\"line\">                   └──ble_hci_uart.c</span><br></pre></td></tr></table></figure>\n<p>这意味着我们需要做出选择，为这些函数接口选择具体实现。这时候引入新问题，“我们在选择什么”。</p>\n<p>参考<a href=\"https://jaydenh215.github.io/2019/10/09/%E6%B5%85%E8%B0%88BLE%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B8%A7/\">这篇blog</a>，可知：</p>\n<p>host和controller可通过hci（host-controller-interface）接口互相通信。具体表现为：</p>\n<ul>\n<li>host通过hci向controller发送command</li>\n<li>controller通过hci向host发送event</li>\n<li>host和controller通过hci互传acl data</li>\n</ul>\n<p>而编译报错缺失的ble_hc_trans_xxxx函数为：</p>\n<ul>\n<li>ble_hci_trans_reset</li>\n<li>ble_hci_trans_cfg_hs（该API注册接收evt和acl data的回调函数）</li>\n<li>ble_hci_trans_buf_alloc</li>\n<li>ble_hci_trans_buf_free</li>\n<li>ble_hci_trans_hs_cmd_tx</li>\n<li>ble_hci_trans_hs_acl_tx</li>\n</ul>\n<p>也就是我们在选择用什么样的transport来实现hci功能，即：</p>\n<ul>\n<li>如果我们需要在一颗芯片上运行host+controller，那么就要选ble_hci_ram.c文件，即host和controller之间用ram通信。</li>\n<li>如果我们需要在一颗芯片上运行host，另一颗芯片运行controller，那么就可以选ble_hci_uart.c文件，即host和controller之间用uart通信。</li>\n</ul>\n<blockquote>\n<p>NOTE：市场上一些简单的智能设备，如手环、心率带、无线传感器，都会选择在一颗芯片上运行完整的协议栈，即host+controller，无论在成本还是开发上都会简单很多。但是一些比较复杂如多协议网关、机顶盒的产品，则需要一个强大的cpu跑linux，并用linux实现host（bluez、bluedroid），然后外挂一颗性能和成本较低的蓝牙芯片跑controller。</p>\n</blockquote>\n<p>这里我们选择ble_hci_ram.c文件，将<code>nimble/transport/ram/src/ble_hci_ram.c</code>和<code>cwd + &#39;/nimble/transport/ram/include&#39;</code>加进SConscript。</p>\n<h3 id=\"2-5-2-缺少ble-npl-xxx函数定义\"><a href=\"#2-5-2-缺少ble-npl-xxx函数定义\" class=\"headerlink\" title=\"2.5.2. 缺少ble_npl_xxx函数定义\"></a>2.5.2. 缺少ble_npl_xxx函数定义</h3><p>npl全称为nimble porting layer，顾名思义，这些函数是协议栈需要调用的接口，协议栈不会实现这部分内容，需要我们自己去实现，协议栈用到的所有接口在<code>nimble_npl.h</code>中。</p>\n<p>这部分nimble没有注释说明接口该如何实现，移植者只能参考其他os的实现以及nimble协议栈调用接口代码，去猜这个函数做了什么，我不喜欢这一点。</p>\n<p>这里我们将rt-thread官方已经移植好的代码加进SConscript，即<code>porting/npl/rtthread/src/npl_os_rtthread.c</code>。</p>\n<blockquote>\n<p>NOTE：需要注释掉npl_os_rtthread.c里面的ble_npl_task_init函数。</p>\n</blockquote>\n<h2 id=\"2-6-移植host总结\"><a href=\"#2-6-移植host总结\" class=\"headerlink\" title=\"2.6. 移植host总结\"></a>2.6. 移植host总结</h2><p>总的来说，nimble中移植host功能需要关注以下几种类型代码。</p>\n<ol>\n<li>host协议核心代码</li>\n<li>公用组件和公用函数</li>\n<li>hci transport</li>\n<li>os特定代码</li>\n</ol>\n<p><a href=\"https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host\" target=\"_blank\" rel=\"noopener\">myboard文件夹下载地址</a></p>\n<h1 id=\"3-移植controller\"><a href=\"#3-移植controller\" class=\"headerlink\" title=\"3. 移植controller\"></a>3. 移植controller</h1><h2 id=\"3-1-移植阶段一\"><a href=\"#3-1-移植阶段一\" class=\"headerlink\" title=\"3.1. 移植阶段一\"></a>3.1. 移植阶段一</h2><p>把所有<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\controller</code>里面除了test文件夹以外的.c文件加进之前的SConscript脚本。</p>\n<p>按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。</p>\n<h3 id=\"3-1-1-无法打开头文件\"><a href=\"#3-1-1-无法打开头文件\" class=\"headerlink\" title=\"3.1.1. 无法打开头文件\"></a>3.1.1. 无法打开头文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;controller/ble_ll.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本<br>解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为<code>cwd + &#39;/nimble/controller/include&#39;</code>，同类报错可用同样方法解决。</p>\n<h2 id=\"3-2-移植阶段二\"><a href=\"#3-2-移植阶段二\" class=\"headerlink\" title=\"3.2. 移植阶段二\"></a>3.2. 移植阶段二</h2><p>前面做的移植操作，无论哪个平台都是一样的。而接下来的操作，不同的应用场景和平台，解决方案会有所差异。</p>\n<h3 id=\"3-2-1-无法打开头文件（存在多个同名头文件）\"><a href=\"#3-2-1-无法打开头文件（存在多个同名头文件）\" class=\"headerlink\" title=\"3.2.1. 无法打开头文件（存在多个同名头文件）\"></a>3.2.1. 无法打开头文件（存在多个同名头文件）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;ble/xcvr.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>xcvr英文原名为transceiver，即既有包含发射器，又有接收器的radio设备。</p>\n<ol>\n<li>xcvr正常运行前需要有一段rampup时间</li>\n<li>xcvr在发射器和接收器之间切换，需要软件执行时间</li>\n</ol>\n<p>因为不同设备，这两个参数会有比较大差异，而ble对于时间的要求又是us级别的，所以需要移植者根据自己的硬件设备来实现。</p>\n<p>这里我们选择nrf52的xcvr文件，将<code>nimble/drivers/nrf52/src/ble_phy.c</code>和<code>cwd + &#39;/nimble/drivers/nrf52/include&#39;</code>加进SConscript。</p>\n<h3 id=\"3-2-2-缺少标识符定义\"><a href=\"#3-2-2-缺少标识符定义\" class=\"headerlink\" title=\"3.2.2. 缺少标识符定义\"></a>3.2.2. 缺少标识符定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT&quot; is undefined</span><br></pre></td></tr></table></figure>\n<p>协议栈要正常运行必须有一些默认参数，否则编译不通过，如：射频发射功率、支持最大连接数等，参数以及参数的说明可以从目录对应的<code>syscfg.yml</code>文件获知。</p>\n<p>由于我们不使用rt-thread提供的软件包功能，所以将用<a href=\"https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/npl/rtthread/include/config/config.h\" target=\"_blank\" rel=\"noopener\">该文件</a>替换如下路径同名文件：<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\include\\config\\config.h</code>。</p>\n<p>同时在<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\syscfg\\syscfg.h</code>文件开头位置中include该头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> H_MYNEWT_SYSCFG_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> H_MYNEWT_SYSCFG_</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL(x)                           MYNEWT_VAL_ ## x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"config/config.h\"</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>NOTE：因为通过宏定义配置参数的文件都会include &lt;syscfg/syscfg.h&gt;文件，将include “config/config.h”放在该文件前可以起到全局配置的作用。</p>\n</blockquote>\n<h3 id=\"3-2-3-无法识别内联汇编\"><a href=\"#3-2-3-无法识别内联汇编\" class=\"headerlink\" title=\"3.2.3. 无法识别内联汇编\"></a>3.2.3. 无法识别内联汇编</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #18: expected a &quot;)&quot;</span><br></pre></td></tr></table></figure>\n<p>用c来实现内联汇编的功能，用<a href=\"https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/nimble/drivers/nrf52/src/ble_phy.c\" target=\"_blank\" rel=\"noopener\">该文件</a>替换如下路径同名文件，即：<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\drivers\\nrf52\\src\\ble_phy.c</code>。</p>\n<h3 id=\"3-2-4-缺少ble-hw-c中实现的函数\"><a href=\"#3-2-4-缺少ble-hw-c中实现的函数\" class=\"headerlink\" title=\"3.2.4. 缺少ble_hw.c中实现的函数\"></a>3.2.4. 缺少ble_hw.c中实现的函数</h3><p>解决方法：将<code>nimble/drivers/nrf52/src/ble_hw.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-5-缺少os-cputime-c中实现的函数\"><a href=\"#3-2-5-缺少os-cputime-c中实现的函数\" class=\"headerlink\" title=\"3.2.5. 缺少os_cputime.c中实现的函数\"></a>3.2.5. 缺少os_cputime.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_cputime.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-6-缺少os-cputime-pwr2-c中实现的函数\"><a href=\"#3-2-6-缺少os-cputime-pwr2-c中实现的函数\" class=\"headerlink\" title=\"3.2.6. 缺少os_cputime_pwr2.c中实现的函数\"></a>3.2.6. 缺少os_cputime_pwr2.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_cputime_pwr2.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-7-缺少hal-timer-c中实现的函数\"><a href=\"#3-2-7-缺少hal-timer-c中实现的函数\" class=\"headerlink\" title=\"3.2.7. 缺少hal_timer.c中实现的函数\"></a>3.2.7. 缺少hal_timer.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/hal_timer.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-8-缺少ble-npl-hw-set-isr函数定义\"><a href=\"#3-2-8-缺少ble-npl-hw-set-isr函数定义\" class=\"headerlink\" title=\"3.2.8. 缺少ble_npl_hw_set_isr函数定义\"></a>3.2.8. 缺少ble_npl_hw_set_isr函数定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: L6218E: Undefined symbol ble_npl_hw_set_isr (referred from ble_phy.o).</span><br></pre></td></tr></table></figure>\n<p>该接口用于设置中断号以及对应的中断服务函数。</p>\n<p>这里我们将<code>porting/npl/rtthread/src/nrf5x_isr.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-9-缺少ble-npl-hw-is-in-critical函数定义\"><a href=\"#3-2-9-缺少ble-npl-hw-is-in-critical函数定义\" class=\"headerlink\" title=\"3.2.9. 缺少ble_npl_hw_is_in_critical函数定义\"></a>3.2.9. 缺少ble_npl_hw_is_in_critical函数定义</h3><p>在<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\src\\npl_os_rtthread.c</code>中修改如下实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> ble_npl_in_critical = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> ble_npl_hw_enter_critical(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ++ble_npl_in_critical;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rt_hw_interrupt_disable();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ble_npl_hw_exit_critical</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> ctx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    --ble_npl_in_critical;</span><br><span class=\"line\">    rt_hw_interrupt_enable(ctx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ble_npl_hw_is_in_critical</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ble_npl_in_critical &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3-移植controller总结\"><a href=\"#3-3-移植controller总结\" class=\"headerlink\" title=\"3.3. 移植controller总结\"></a>3.3. 移植controller总结</h2><p>总的来说，nimble中移植controller功能需要关注以下几种类型代码。</p>\n<ol>\n<li>controller协议核心代码</li>\n<li>硬件平台差异文件（ble_phy.c/ble_hw.c/nrf5x_isr.c）</li>\n<li>公用组件和公用函数(hal_timer.c/…)</li>\n<li>应用宏定义配置文件（config.h/syscfg.yml）</li>\n</ol>\n<p><a href=\"https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host_controller\" target=\"_blank\" rel=\"noopener\">myboard文件夹下载地址</a></p>\n<h1 id=\"4-移植profile\"><a href=\"#4-移植profile\" class=\"headerlink\" title=\"4. 移植profile\"></a>4. 移植profile</h1><p>不同的应用场景对于蓝牙核心协议栈（host+controller）的用法不一样，为了规范化和互联互通，针对某些应用场景，会有一套蓝牙核心协议栈的操作指南，这份指南称为profile。</p>\n<h2 id=\"4-1-添加心率profile\"><a href=\"#4-1-添加心率profile\" class=\"headerlink\" title=\"4.1. 添加心率profile\"></a>4.1. 添加心率profile</h2><p>下载<a href=\"https://github.com/Zero-Free/nrf52832-nimble/blob/master/packages/NimBLE-latest/apps/blehr/src/blehr.c\" target=\"_blank\" rel=\"noopener\">rt-thread官方推荐的应用代码</a>，添加进<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\apps\\blehr\\src\\</code>文件夹。</p>\n<ol>\n<li>将<code>apps/blehr/src/gatt_svr.c</code>添加进SConscript脚本。</li>\n<li>将<code>apps/blehr/src/blehr.c</code>添加进SConscript脚本。</li>\n<li>将<code>cwd + &#39;/apps/blehr/src&#39;</code>添加进SConscript脚本。</li>\n</ol>\n<h2 id=\"4-2-移植proifile总结\"><a href=\"#4-2-移植proifile总结\" class=\"headerlink\" title=\"4.2. 移植proifile总结\"></a>4.2. 移植proifile总结</h2><p>添加profile的过程比较杂乱，但这没办法，因为profile和os、nimble的启动方式等等都有耦合，特别是rtthread这里启动nimble的方式有点绕。</p>\n<h1 id=\"5-启动运行\"><a href=\"#5-启动运行\" class=\"headerlink\" title=\"5. 启动运行\"></a>5. 启动运行</h1><p>经过上节处理之后，编译报以下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: L6218E: Undefined symbol ble_hs_thread_startup (referred from blehr.o).</span><br></pre></td></tr></table></figure>\n<p>解决方法：将<code>porting/npl/rtthread/src/nimble_port_rtthread.c</code>添加进SConscript脚本。</p>\n<p>通过阅读<code>nimble_port_rttherad.c</code>文件得知，如果需要支持controller，还需要先增加宏定义<code>NIMBLE_CFG_CONTROLLER=1</code>，所以将该宏定义添加进SConscript脚本。</p>\n<h2 id=\"5-1-缺少标识符定义\"><a href=\"#5-1-缺少标识符定义\" class=\"headerlink\" title=\"5.1. 缺少标识符定义\"></a>5.1. 缺少标识符定义</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE&quot; is undefined</span><br><span class=\"line\"></span><br><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY&quot; is undefined</span><br><span class=\"line\"></span><br><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE&quot; is undefined</span><br><span class=\"line\"></span><br><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY&quot; is undefined</span><br></pre></td></tr></table></figure>\n<p>在<code>porting/npl/rtthread/include/config/config.h</code>文件添加以下内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//thread config</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE     (2048)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY       (5)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE       (2048)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY         (4) <span class=\"comment\">// must higher than MYNEWT_VAL_BLE_HOST_TASK_PRIORITY, numerically smaller</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2-修复bug\"><a href=\"#5-2-修复bug\" class=\"headerlink\" title=\"5.2. 修复bug\"></a>5.2. 修复bug</h2><p>将<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\os\\endian.h</code>文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br></pre></td></tr></table></figure></p>\n<p>改为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined (__BYTE_ORDER__) &amp;&amp; (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-3-添加调试\"><a href=\"#5-3-添加调试\" class=\"headerlink\" title=\"5.3. 添加调试\"></a>5.3. 添加调试</h2><p>将<code>porting/npl/rtthread/src/modlog.c</code>添加进SConscript脚本。</p>\n<p>用<a href=\"https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/npl/rtthread/src/modlog.c\" target=\"_blank\" rel=\"noopener\">该文件</a>替换<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\src\\modlog.c</code>。</p>\n<p>用<a href=\"https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/nimble/include/modlog/modlog.h\" target=\"_blank\" rel=\"noopener\">该文件</a>替换<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\modlog\\modlog.h</code>。</p>\n<h2 id=\"5-4-编译烧录\"><a href=\"#5-4-编译烧录\" class=\"headerlink\" title=\"5.4. 编译烧录\"></a>5.4. 编译烧录</h2><p><a href=\"https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host_controller_profile\" target=\"_blank\" rel=\"noopener\">myboard文件夹下载地址</a></p>\n<p>生成工程、编译、烧录后，在串口调试助手输入<code>ble_hr</code>，设备开始广播。</p>\n<p><img src=\"ble_hr.gif\" alt></p>\n<h1 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h1><p>通过这一章节的学习，对于nimble的目录结构、参数配置方式，有更深刻的认识。</p>\n","site":{"data":{}},"excerpt":"<p>站在巨人的肩膀上可以看的更远。<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>移植目标：手机app可以搜索到ble广播，能成功连接并发现服务。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-土方法\">1. 土方法</a></li>\n<li><a href=\"#2-移植host\">2. 移植host</a><ul>\n<li><a href=\"#21-添加nimble\">2.1. 添加nimble</a></li>\n<li><a href=\"#22-添加空白sconscript\">2.2. 添加空白SConscript</a></li>\n<li><a href=\"#23-移植阶段一\">2.3. 移植阶段一</a><ul>\n<li><a href=\"#231-无法打开头文件\">2.3.1. 无法打开头文件</a></li>\n<li><a href=\"#232-无法打开头文件缺少头文件\">2.3.2. 无法打开头文件（缺少头文件）</a></li>\n<li><a href=\"#233-无法打开头文件存在多个同名头文件\">2.3.3. 无法打开头文件（存在多个同名头文件）</a></li>\n<li><a href=\"#234-缺少标识符定义\">2.3.4. 缺少标识符定义</a></li>\n</ul>\n</li>\n<li><a href=\"#24-移植阶段二\">2.4. 移植阶段二</a><ul>\n<li><a href=\"#241-缺少endianc中实现的函数\">2.4.1. 缺少endian.c中实现的函数</a></li>\n<li><a href=\"#242-缺少memc中实现的函数\">2.4.2. 缺少mem.c中实现的函数</a></li>\n<li><a href=\"#243-缺少os_mbufc实现的函数\">2.4.3. 缺少os_mbuf.c实现的函数</a></li>\n<li><a href=\"#244-缺少os_mempoolc实现的函数\">2.4.4. 缺少os_mempool.c实现的函数</a></li>\n<li><a href=\"#245-缺少nimble_portc实现的函数\">2.4.5. 缺少nimble_port.c实现的函数</a></li>\n<li><a href=\"#246-缺少os_msys_initc实现的函数\">2.4.6. 缺少os_msys_init.c实现的函数</a></li>\n<li><a href=\"#247-缺少tinycrypt加密组件\">2.4.7. 缺少tinycrypt加密组件</a></li>\n</ul>\n</li>\n<li><a href=\"#25-移植阶段三\">2.5. 移植阶段三</a><ul>\n<li><a href=\"#251-存在多个ble_hc_trans_xxxx同名函数\">2.5.1. 存在多个ble_hc_trans_xxxx同名函数</a></li>\n<li><a href=\"#252-缺少ble_npl_xxx函数定义\">2.5.2. 缺少ble_npl_xxx函数定义</a></li>\n</ul>\n</li>\n<li><a href=\"#26-移植host总结\">2.6. 移植host总结</a></li>\n</ul>\n</li>\n<li><a href=\"#3-移植controller\">3. 移植controller</a><ul>\n<li><a href=\"#31-移植阶段一\">3.1. 移植阶段一</a><ul>\n<li><a href=\"#311-无法打开头文件\">3.1.1. 无法打开头文件</a></li>\n</ul>\n</li>\n<li><a href=\"#32-移植阶段二\">3.2. 移植阶段二</a><ul>\n<li><a href=\"#321-无法打开头文件存在多个同名头文件\">3.2.1. 无法打开头文件（存在多个同名头文件）</a></li>\n<li><a href=\"#322-缺少标识符定义\">3.2.2. 缺少标识符定义</a></li>\n<li><a href=\"#323-无法识别内联汇编\">3.2.3. 无法识别内联汇编</a></li>\n<li><a href=\"#324-缺少ble_hwc中实现的函数\">3.2.4. 缺少ble_hw.c中实现的函数</a></li>\n<li><a href=\"#325-缺少os_cputimec中实现的函数\">3.2.5. 缺少os_cputime.c中实现的函数</a></li>\n<li><a href=\"#326-缺少os_cputime_pwr2c中实现的函数\">3.2.6. 缺少os_cputime_pwr2.c中实现的函数</a></li>\n<li><a href=\"#327-缺少hal_timerc中实现的函数\">3.2.7. 缺少hal_timer.c中实现的函数</a></li>\n<li><a href=\"#328-缺少ble_npl_hw_set_isr函数定义\">3.2.8. 缺少ble_npl_hw_set_isr函数定义</a></li>\n<li><a href=\"#329-缺少ble_npl_hw_is_in_critical函数定义\">3.2.9. 缺少ble_npl_hw_is_in_critical函数定义</a></li>\n</ul>\n</li>\n<li><a href=\"#33-移植controller总结\">3.3. 移植controller总结</a></li>\n</ul>\n</li>\n<li><a href=\"#4-移植profile\">4. 移植profile</a><ul>\n<li><a href=\"#41-添加心率profile\">4.1. 添加心率profile</a></li>\n<li><a href=\"#42-移植proifile总结\">4.2. 移植proifile总结</a></li>\n</ul>\n</li>\n<li><a href=\"#5-启动运行\">5. 启动运行</a><ul>\n<li><a href=\"#51-缺少标识符定义\">5.1. 缺少标识符定义</a></li>\n<li><a href=\"#52-修复bug\">5.2. 修复bug</a></li>\n<li><a href=\"#53-添加调试\">5.3. 添加调试</a></li>\n<li><a href=\"#54-编译烧录\">5.4. 编译烧录</a></li>\n</ul>\n</li>\n<li><a href=\"#6-总结\">6. 总结</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-土方法\"><a href=\"#1-土方法\" class=\"headerlink\" title=\"1. 土方法\"></a>1. 土方法</h1><p>第一个问题，nimble的porting目录看不懂，钻牛角尖要不得，故跑到<a href=\"https://github.com/Zero-Free/nrf52832-nimble\" target=\"_blank\" rel=\"noopener\">大佬</a>的github上寻求解决方案。</p>\n<p>然后有了第一个解决思路：基于可以正常运行的工程，将部分nimble源文件从SConscript脚本中移除。</p>\n<p>然后第二个问题来了，移除哪些源文件？</p>\n<p>按照笔者对<a href=\"http://mynewt.apache.org/latest/network/docs/ble_setup/ble_sync_cb.html\" target=\"_blank\" rel=\"noopener\">nimble官方文档</a>的了解，nimble支持host和controller解耦，那么第一步移植工作就先保留host代码，将controller部分全部移除掉。</p>\n<h1 id=\"2-移植host\"><a href=\"#2-移植host\" class=\"headerlink\" title=\"2. 移植host\"></a>2. 移植host</h1><h2 id=\"2-1-添加nimble\"><a href=\"#2-1-添加nimble\" class=\"headerlink\" title=\"2.1. 添加nimble\"></a>2.1. 添加nimble</h2><p>将官网下载的nimble压缩包解压，并将生成的文件夹复制粘贴到myboard目录下，即<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0</code>。</p>\n<h2 id=\"2-2-添加空白SConscript\"><a href=\"#2-2-添加空白SConscript\" class=\"headerlink\" title=\"2.2. 添加空白SConscript\"></a>2.2. 添加空白SConscript</h2><p>添加SConscript文件到nimble目录下，即<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\SConscript</code>。</p>\n<h2 id=\"2-3-移植阶段一\"><a href=\"#2-3-移植阶段一\" class=\"headerlink\" title=\"2.3. 移植阶段一\"></a>2.3. 移植阶段一</h2><p>把所有<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\host</code>里面除了mesh文件夹和test文件夹以外的.c文件加进刚创建的空白SConscript脚本。</p>\n<blockquote>\n<p>NOTE：ble mesh后面再挖坑，这里先不展开。</p>\n</blockquote>\n<p>按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。</p>\n<h3 id=\"2-3-1-无法打开头文件\"><a href=\"#2-3-1-无法打开头文件\" class=\"headerlink\" title=\"2.3.1. 无法打开头文件\"></a>2.3.1. 无法打开头文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;sysinit/sysinit.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本<br>解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为<code>cwd + &#39;/porting/nimble/include&#39;</code>，同类报错可用同样方法解决。</p>\n<h3 id=\"2-3-2-无法打开头文件（缺少头文件）\"><a href=\"#2-3-2-无法打开头文件（缺少头文件）\" class=\"headerlink\" title=\"2.3.2. 无法打开头文件（缺少头文件）\"></a>2.3.2. 无法打开头文件（缺少头文件）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;base64/base64.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>错误原因：nimble包没有该文件<br>解决办法：从mynewt的<code>encoding</code>目录下，拷贝<code>base64</code>到<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\ext\\</code>，并在SConscript中添加路径，该例子需要添加的路径为<code>cwd + &#39;/ext/base64/include&#39;</code>。</p>\n<h3 id=\"2-3-3-无法打开头文件（存在多个同名头文件）\"><a href=\"#2-3-3-无法打开头文件（存在多个同名头文件）\" class=\"headerlink\" title=\"2.3.3. 无法打开头文件（存在多个同名头文件）\"></a>2.3.3. 无法打开头文件（存在多个同名头文件）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;nimble/nimble_npl_os.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>错误原因：nimble包有多个该文件，只是没有将头文件目录添加进编译脚本<br>解决方法：该文件定义了os的抽象接口，协议栈会调用这些接口，这些接口的实现每个os都不一样，我们这里参考<a href=\"https://github.com/Zero-Free/nrf52832-nimble/tree/master/packages/NimBLE-latest/porting/npl/rtthread\" target=\"_blank\" rel=\"noopener\">rt-thread官方做法</a>，直接下载该文件夹到<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl</code>下，并在SConscript中添加路径，该例子需要添加的路径为<code>cwd + &#39;/porting/npl/rtthread/include&#39;</code>。</p>\n<h3 id=\"2-3-4-缺少标识符定义\"><a href=\"#2-3-4-缺少标识符定义\" class=\"headerlink\" title=\"2.3.4. 缺少标识符定义\"></a>2.3.4. 缺少标识符定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLEUART_MAX_INPUT&quot; is undefined</span><br></pre></td></tr></table></figure>\n<p>错误原因：缺少宏定义<br>解决方法：将<code>nimble/host/services/bleuart/src/bleuart.c</code>从SConscript脚本中删除，暂不考虑实现该profile。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT&quot; is undefined</span><br></pre></td></tr></table></figure>\n<p>错误原因：缺少宏定义<br>解决方法：将<code>nimble/host/services/dis/src/ble_svc_dis.c</code>从SConscript脚本中删除，暂不考虑实现该profile。</p>\n<h2 id=\"2-4-移植阶段二\"><a href=\"#2-4-移植阶段二\" class=\"headerlink\" title=\"2.4. 移植阶段二\"></a>2.4. 移植阶段二</h2><p>经过上节处理之后，编译均是以下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: L6218E: Undefined symbol xxxx (referred from xxxx).</span><br></pre></td></tr></table></figure>\n<p>host文件夹内的代码会引用其他目录下的<code>公共组件</code>以及<code>公共函数</code>。组件如：内存池，函数如：大小端转换函数。</p>\n<p>所以该阶段目标是将host文件夹依赖的<code>公共组件</code>和<code>公共函数</code>补充完整。</p>\n<h3 id=\"2-4-1-缺少endian-c中实现的函数\"><a href=\"#2-4-1-缺少endian-c中实现的函数\" class=\"headerlink\" title=\"2.4.1. 缺少endian.c中实现的函数\"></a>2.4.1. 缺少endian.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/endian.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-2-缺少mem-c中实现的函数\"><a href=\"#2-4-2-缺少mem-c中实现的函数\" class=\"headerlink\" title=\"2.4.2. 缺少mem.c中实现的函数\"></a>2.4.2. 缺少mem.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/mem.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-3-缺少os-mbuf-c实现的函数\"><a href=\"#2-4-3-缺少os-mbuf-c实现的函数\" class=\"headerlink\" title=\"2.4.3. 缺少os_mbuf.c实现的函数\"></a>2.4.3. 缺少os_mbuf.c实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_mbuf.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-4-缺少os-mempool-c实现的函数\"><a href=\"#2-4-4-缺少os-mempool-c实现的函数\" class=\"headerlink\" title=\"2.4.4. 缺少os_mempool.c实现的函数\"></a>2.4.4. 缺少os_mempool.c实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_mempool.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-5-缺少nimble-port-c实现的函数\"><a href=\"#2-4-5-缺少nimble-port-c实现的函数\" class=\"headerlink\" title=\"2.4.5. 缺少nimble_port.c实现的函数\"></a>2.4.5. 缺少nimble_port.c实现的函数</h3><p>解决方法：将<code>porting/nimble/src/nimble_port.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-6-缺少os-msys-init-c实现的函数\"><a href=\"#2-4-6-缺少os-msys-init-c实现的函数\" class=\"headerlink\" title=\"2.4.6. 缺少os_msys_init.c实现的函数\"></a>2.4.6. 缺少os_msys_init.c实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_msys_init.c</code>添加进SConscript脚本。</p>\n<h3 id=\"2-4-7-缺少tinycrypt加密组件\"><a href=\"#2-4-7-缺少tinycrypt加密组件\" class=\"headerlink\" title=\"2.4.7. 缺少tinycrypt加密组件\"></a>2.4.7. 缺少tinycrypt加密组件</h3><p>解决方法：添加以下路径到SConscript文件。<br><code>ext/tinycrypt/src/aes_decrypt.c</code><br><code>ext/tinycrypt/src/aes_encrypt.c</code><br><code>ext/tinycrypt/src/utils.c</code></p>\n<h2 id=\"2-5-移植阶段三\"><a href=\"#2-5-移植阶段三\" class=\"headerlink\" title=\"2.5. 移植阶段三\"></a>2.5. 移植阶段三</h2><p>经过上节处理之后，编译剩下以下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. Error: L6218E: Undefined symbol ble_hci_trans_xxxx (referred from xxxx).</span><br><span class=\"line\">2. Error: L6218E: Undefined symbol ble_npl_xxx (referred from xxxx).</span><br></pre></td></tr></table></figure>\n<p>前面做的移植操作，哪个平台都是一样的。而对于这两类错误，不同的应用场景和平台，解决方案会有所差异。</p>\n<h3 id=\"2-5-1-存在多个ble-hc-trans-xxxx同名函数\"><a href=\"#2-5-1-存在多个ble-hc-trans-xxxx同名函数\" class=\"headerlink\" title=\"2.5.1. 存在多个ble_hc_trans_xxxx同名函数\"></a>2.5.1. 存在多个ble_hc_trans_xxxx同名函数</h3><p>全局搜索nimble包会发现这些函数在多个.c文件中都有实现，位置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apache-mynewt-nimble-1.2.0</span><br><span class=\"line\">└──nimble         </span><br><span class=\"line\">    └──transport</span><br><span class=\"line\">           ├──da1469x</span><br><span class=\"line\">           │     └──src</span><br><span class=\"line\">           │         └──da1469x_ble_hci.c</span><br><span class=\"line\">           ├──emspi</span><br><span class=\"line\">           │    └──src</span><br><span class=\"line\">           │        └──ble_hci_emspi.c</span><br><span class=\"line\">           ├──ram</span><br><span class=\"line\">           │    └──src</span><br><span class=\"line\">           │        └──ble_hci_ram.c</span><br><span class=\"line\">           ├──socket</span><br><span class=\"line\">           │    └──src</span><br><span class=\"line\">           │        └──ble_hci_socket.c</span><br><span class=\"line\">           └──uart</span><br><span class=\"line\">               └──src</span><br><span class=\"line\">                   └──ble_hci_uart.c</span><br></pre></td></tr></table></figure>\n<p>这意味着我们需要做出选择，为这些函数接口选择具体实现。这时候引入新问题，“我们在选择什么”。</p>\n<p>参考<a href=\"https://jaydenh215.github.io/2019/10/09/%E6%B5%85%E8%B0%88BLE%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B8%A7/\">这篇blog</a>，可知：</p>\n<p>host和controller可通过hci（host-controller-interface）接口互相通信。具体表现为：</p>\n<ul>\n<li>host通过hci向controller发送command</li>\n<li>controller通过hci向host发送event</li>\n<li>host和controller通过hci互传acl data</li>\n</ul>\n<p>而编译报错缺失的ble_hc_trans_xxxx函数为：</p>\n<ul>\n<li>ble_hci_trans_reset</li>\n<li>ble_hci_trans_cfg_hs（该API注册接收evt和acl data的回调函数）</li>\n<li>ble_hci_trans_buf_alloc</li>\n<li>ble_hci_trans_buf_free</li>\n<li>ble_hci_trans_hs_cmd_tx</li>\n<li>ble_hci_trans_hs_acl_tx</li>\n</ul>\n<p>也就是我们在选择用什么样的transport来实现hci功能，即：</p>\n<ul>\n<li>如果我们需要在一颗芯片上运行host+controller，那么就要选ble_hci_ram.c文件，即host和controller之间用ram通信。</li>\n<li>如果我们需要在一颗芯片上运行host，另一颗芯片运行controller，那么就可以选ble_hci_uart.c文件，即host和controller之间用uart通信。</li>\n</ul>\n<blockquote>\n<p>NOTE：市场上一些简单的智能设备，如手环、心率带、无线传感器，都会选择在一颗芯片上运行完整的协议栈，即host+controller，无论在成本还是开发上都会简单很多。但是一些比较复杂如多协议网关、机顶盒的产品，则需要一个强大的cpu跑linux，并用linux实现host（bluez、bluedroid），然后外挂一颗性能和成本较低的蓝牙芯片跑controller。</p>\n</blockquote>\n<p>这里我们选择ble_hci_ram.c文件，将<code>nimble/transport/ram/src/ble_hci_ram.c</code>和<code>cwd + &#39;/nimble/transport/ram/include&#39;</code>加进SConscript。</p>\n<h3 id=\"2-5-2-缺少ble-npl-xxx函数定义\"><a href=\"#2-5-2-缺少ble-npl-xxx函数定义\" class=\"headerlink\" title=\"2.5.2. 缺少ble_npl_xxx函数定义\"></a>2.5.2. 缺少ble_npl_xxx函数定义</h3><p>npl全称为nimble porting layer，顾名思义，这些函数是协议栈需要调用的接口，协议栈不会实现这部分内容，需要我们自己去实现，协议栈用到的所有接口在<code>nimble_npl.h</code>中。</p>\n<p>这部分nimble没有注释说明接口该如何实现，移植者只能参考其他os的实现以及nimble协议栈调用接口代码，去猜这个函数做了什么，我不喜欢这一点。</p>\n<p>这里我们将rt-thread官方已经移植好的代码加进SConscript，即<code>porting/npl/rtthread/src/npl_os_rtthread.c</code>。</p>\n<blockquote>\n<p>NOTE：需要注释掉npl_os_rtthread.c里面的ble_npl_task_init函数。</p>\n</blockquote>\n<h2 id=\"2-6-移植host总结\"><a href=\"#2-6-移植host总结\" class=\"headerlink\" title=\"2.6. 移植host总结\"></a>2.6. 移植host总结</h2><p>总的来说，nimble中移植host功能需要关注以下几种类型代码。</p>\n<ol>\n<li>host协议核心代码</li>\n<li>公用组件和公用函数</li>\n<li>hci transport</li>\n<li>os特定代码</li>\n</ol>\n<p><a href=\"https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host\" target=\"_blank\" rel=\"noopener\">myboard文件夹下载地址</a></p>\n<h1 id=\"3-移植controller\"><a href=\"#3-移植controller\" class=\"headerlink\" title=\"3. 移植controller\"></a>3. 移植controller</h1><h2 id=\"3-1-移植阶段一\"><a href=\"#3-1-移植阶段一\" class=\"headerlink\" title=\"3.1. 移植阶段一\"></a>3.1. 移植阶段一</h2><p>把所有<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\controller</code>里面除了test文件夹以外的.c文件加进之前的SConscript脚本。</p>\n<p>按照上述步骤操作后，编译过程中必然会一路报错，以下是解决方案，请大家对号入座一个个消掉。</p>\n<h3 id=\"3-1-1-无法打开头文件\"><a href=\"#3-1-1-无法打开头文件\" class=\"headerlink\" title=\"3.1.1. 无法打开头文件\"></a>3.1.1. 无法打开头文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;controller/ble_ll.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>错误原因：nimble包有该文件，只是没有将头文件目录添加进编译脚本<br>解决方法：在nimble包中找到唯一对应的头文件，并在SConscript中添加路径，该例子需要添加的路径为<code>cwd + &#39;/nimble/controller/include&#39;</code>，同类报错可用同样方法解决。</p>\n<h2 id=\"3-2-移植阶段二\"><a href=\"#3-2-移植阶段二\" class=\"headerlink\" title=\"3.2. 移植阶段二\"></a>3.2. 移植阶段二</h2><p>前面做的移植操作，无论哪个平台都是一样的。而接下来的操作，不同的应用场景和平台，解决方案会有所差异。</p>\n<h3 id=\"3-2-1-无法打开头文件（存在多个同名头文件）\"><a href=\"#3-2-1-无法打开头文件（存在多个同名头文件）\" class=\"headerlink\" title=\"3.2.1. 无法打开头文件（存在多个同名头文件）\"></a>3.2.1. 无法打开头文件（存在多个同名头文件）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #5: cannot open source input file &quot;ble/xcvr.h&quot;: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>xcvr英文原名为transceiver，即既有包含发射器，又有接收器的radio设备。</p>\n<ol>\n<li>xcvr正常运行前需要有一段rampup时间</li>\n<li>xcvr在发射器和接收器之间切换，需要软件执行时间</li>\n</ol>\n<p>因为不同设备，这两个参数会有比较大差异，而ble对于时间的要求又是us级别的，所以需要移植者根据自己的硬件设备来实现。</p>\n<p>这里我们选择nrf52的xcvr文件，将<code>nimble/drivers/nrf52/src/ble_phy.c</code>和<code>cwd + &#39;/nimble/drivers/nrf52/include&#39;</code>加进SConscript。</p>\n<h3 id=\"3-2-2-缺少标识符定义\"><a href=\"#3-2-2-缺少标识符定义\" class=\"headerlink\" title=\"3.2.2. 缺少标识符定义\"></a>3.2.2. 缺少标识符定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_SVC_DIS_MODEL_NUMBER_DEFAULT&quot; is undefined</span><br></pre></td></tr></table></figure>\n<p>协议栈要正常运行必须有一些默认参数，否则编译不通过，如：射频发射功率、支持最大连接数等，参数以及参数的说明可以从目录对应的<code>syscfg.yml</code>文件获知。</p>\n<p>由于我们不使用rt-thread提供的软件包功能，所以将用<a href=\"https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/npl/rtthread/include/config/config.h\" target=\"_blank\" rel=\"noopener\">该文件</a>替换如下路径同名文件：<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\include\\config\\config.h</code>。</p>\n<p>同时在<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\syscfg\\syscfg.h</code>文件开头位置中include该头文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> H_MYNEWT_SYSCFG_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> H_MYNEWT_SYSCFG_</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL(x)                           MYNEWT_VAL_ ## x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"config/config.h\"</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>NOTE：因为通过宏定义配置参数的文件都会include &lt;syscfg/syscfg.h&gt;文件，将include “config/config.h”放在该文件前可以起到全局配置的作用。</p>\n</blockquote>\n<h3 id=\"3-2-3-无法识别内联汇编\"><a href=\"#3-2-3-无法识别内联汇编\" class=\"headerlink\" title=\"3.2.3. 无法识别内联汇编\"></a>3.2.3. 无法识别内联汇编</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #18: expected a &quot;)&quot;</span><br></pre></td></tr></table></figure>\n<p>用c来实现内联汇编的功能，用<a href=\"https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/nimble/drivers/nrf52/src/ble_phy.c\" target=\"_blank\" rel=\"noopener\">该文件</a>替换如下路径同名文件，即：<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\nimble\\drivers\\nrf52\\src\\ble_phy.c</code>。</p>\n<h3 id=\"3-2-4-缺少ble-hw-c中实现的函数\"><a href=\"#3-2-4-缺少ble-hw-c中实现的函数\" class=\"headerlink\" title=\"3.2.4. 缺少ble_hw.c中实现的函数\"></a>3.2.4. 缺少ble_hw.c中实现的函数</h3><p>解决方法：将<code>nimble/drivers/nrf52/src/ble_hw.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-5-缺少os-cputime-c中实现的函数\"><a href=\"#3-2-5-缺少os-cputime-c中实现的函数\" class=\"headerlink\" title=\"3.2.5. 缺少os_cputime.c中实现的函数\"></a>3.2.5. 缺少os_cputime.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_cputime.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-6-缺少os-cputime-pwr2-c中实现的函数\"><a href=\"#3-2-6-缺少os-cputime-pwr2-c中实现的函数\" class=\"headerlink\" title=\"3.2.6. 缺少os_cputime_pwr2.c中实现的函数\"></a>3.2.6. 缺少os_cputime_pwr2.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/os_cputime_pwr2.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-7-缺少hal-timer-c中实现的函数\"><a href=\"#3-2-7-缺少hal-timer-c中实现的函数\" class=\"headerlink\" title=\"3.2.7. 缺少hal_timer.c中实现的函数\"></a>3.2.7. 缺少hal_timer.c中实现的函数</h3><p>解决方法：将<code>porting/nimble/src/hal_timer.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-8-缺少ble-npl-hw-set-isr函数定义\"><a href=\"#3-2-8-缺少ble-npl-hw-set-isr函数定义\" class=\"headerlink\" title=\"3.2.8. 缺少ble_npl_hw_set_isr函数定义\"></a>3.2.8. 缺少ble_npl_hw_set_isr函数定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: L6218E: Undefined symbol ble_npl_hw_set_isr (referred from ble_phy.o).</span><br></pre></td></tr></table></figure>\n<p>该接口用于设置中断号以及对应的中断服务函数。</p>\n<p>这里我们将<code>porting/npl/rtthread/src/nrf5x_isr.c</code>添加进SConscript脚本。</p>\n<h3 id=\"3-2-9-缺少ble-npl-hw-is-in-critical函数定义\"><a href=\"#3-2-9-缺少ble-npl-hw-is-in-critical函数定义\" class=\"headerlink\" title=\"3.2.9. 缺少ble_npl_hw_is_in_critical函数定义\"></a>3.2.9. 缺少ble_npl_hw_is_in_critical函数定义</h3><p>在<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\src\\npl_os_rtthread.c</code>中修改如下实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> ble_npl_in_critical = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> ble_npl_hw_enter_critical(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ++ble_npl_in_critical;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rt_hw_interrupt_disable();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ble_npl_hw_exit_critical</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> ctx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    --ble_npl_in_critical;</span><br><span class=\"line\">    rt_hw_interrupt_enable(ctx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ble_npl_hw_is_in_critical</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ble_npl_in_critical &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3-移植controller总结\"><a href=\"#3-3-移植controller总结\" class=\"headerlink\" title=\"3.3. 移植controller总结\"></a>3.3. 移植controller总结</h2><p>总的来说，nimble中移植controller功能需要关注以下几种类型代码。</p>\n<ol>\n<li>controller协议核心代码</li>\n<li>硬件平台差异文件（ble_phy.c/ble_hw.c/nrf5x_isr.c）</li>\n<li>公用组件和公用函数(hal_timer.c/…)</li>\n<li>应用宏定义配置文件（config.h/syscfg.yml）</li>\n</ol>\n<p><a href=\"https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host_controller\" target=\"_blank\" rel=\"noopener\">myboard文件夹下载地址</a></p>\n<h1 id=\"4-移植profile\"><a href=\"#4-移植profile\" class=\"headerlink\" title=\"4. 移植profile\"></a>4. 移植profile</h1><p>不同的应用场景对于蓝牙核心协议栈（host+controller）的用法不一样，为了规范化和互联互通，针对某些应用场景，会有一套蓝牙核心协议栈的操作指南，这份指南称为profile。</p>\n<h2 id=\"4-1-添加心率profile\"><a href=\"#4-1-添加心率profile\" class=\"headerlink\" title=\"4.1. 添加心率profile\"></a>4.1. 添加心率profile</h2><p>下载<a href=\"https://github.com/Zero-Free/nrf52832-nimble/blob/master/packages/NimBLE-latest/apps/blehr/src/blehr.c\" target=\"_blank\" rel=\"noopener\">rt-thread官方推荐的应用代码</a>，添加进<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\apps\\blehr\\src\\</code>文件夹。</p>\n<ol>\n<li>将<code>apps/blehr/src/gatt_svr.c</code>添加进SConscript脚本。</li>\n<li>将<code>apps/blehr/src/blehr.c</code>添加进SConscript脚本。</li>\n<li>将<code>cwd + &#39;/apps/blehr/src&#39;</code>添加进SConscript脚本。</li>\n</ol>\n<h2 id=\"4-2-移植proifile总结\"><a href=\"#4-2-移植proifile总结\" class=\"headerlink\" title=\"4.2. 移植proifile总结\"></a>4.2. 移植proifile总结</h2><p>添加profile的过程比较杂乱，但这没办法，因为profile和os、nimble的启动方式等等都有耦合，特别是rtthread这里启动nimble的方式有点绕。</p>\n<h1 id=\"5-启动运行\"><a href=\"#5-启动运行\" class=\"headerlink\" title=\"5. 启动运行\"></a>5. 启动运行</h1><p>经过上节处理之后，编译报以下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: L6218E: Undefined symbol ble_hs_thread_startup (referred from blehr.o).</span><br></pre></td></tr></table></figure>\n<p>解决方法：将<code>porting/npl/rtthread/src/nimble_port_rtthread.c</code>添加进SConscript脚本。</p>\n<p>通过阅读<code>nimble_port_rttherad.c</code>文件得知，如果需要支持controller，还需要先增加宏定义<code>NIMBLE_CFG_CONTROLLER=1</code>，所以将该宏定义添加进SConscript脚本。</p>\n<h2 id=\"5-1-缺少标识符定义\"><a href=\"#5-1-缺少标识符定义\" class=\"headerlink\" title=\"5.1. 缺少标识符定义\"></a>5.1. 缺少标识符定义</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE&quot; is undefined</span><br><span class=\"line\"></span><br><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY&quot; is undefined</span><br><span class=\"line\"></span><br><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE&quot; is undefined</span><br><span class=\"line\"></span><br><span class=\"line\">error:  #20: identifier &quot;MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY&quot; is undefined</span><br></pre></td></tr></table></figure>\n<p>在<code>porting/npl/rtthread/include/config/config.h</code>文件添加以下内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//thread config</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL_BLE_HOST_THREAD_STACK_SIZE     (2048)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL_BLE_HOST_THREAD_PRIORITY       (5)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL_BLE_CTLR_THREAD_STACK_SIZE       (2048)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYNEWT_VAL_BLE_CTLR_THREAD_PRIORITY         (4) <span class=\"comment\">// must higher than MYNEWT_VAL_BLE_HOST_TASK_PRIORITY, numerically smaller</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2-修复bug\"><a href=\"#5-2-修复bug\" class=\"headerlink\" title=\"5.2. 修复bug\"></a>5.2. 修复bug</h2><p>将<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\os\\endian.h</code>文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br></pre></td></tr></table></figure></p>\n<p>改为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined (__BYTE_ORDER__) &amp;&amp; (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-3-添加调试\"><a href=\"#5-3-添加调试\" class=\"headerlink\" title=\"5.3. 添加调试\"></a>5.3. 添加调试</h2><p>将<code>porting/npl/rtthread/src/modlog.c</code>添加进SConscript脚本。</p>\n<p>用<a href=\"https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/npl/rtthread/src/modlog.c\" target=\"_blank\" rel=\"noopener\">该文件</a>替换<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\npl\\rtthread\\src\\modlog.c</code>。</p>\n<p>用<a href=\"https://github.com/JaydenH215/rtt_nimble/blob/master/myboard_with_nimble_host_controller_profile/apache-mynewt-nimble-1.2.0/porting/nimble/include/modlog/modlog.h\" target=\"_blank\" rel=\"noopener\">该文件</a>替换<code>rt-thread\\bsp\\myboard\\apache-mynewt-nimble-1.2.0\\porting\\nimble\\include\\modlog\\modlog.h</code>。</p>\n<h2 id=\"5-4-编译烧录\"><a href=\"#5-4-编译烧录\" class=\"headerlink\" title=\"5.4. 编译烧录\"></a>5.4. 编译烧录</h2><p><a href=\"https://github.com/JaydenH215/rtt_nimble/tree/master/myboard_with_nimble_host_controller_profile\" target=\"_blank\" rel=\"noopener\">myboard文件夹下载地址</a></p>\n<p>生成工程、编译、烧录后，在串口调试助手输入<code>ble_hr</code>，设备开始广播。</p>\n<p><img src=\"ble_hr.gif\" alt></p>\n<h1 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h1><p>通过这一章节的学习，对于nimble的目录结构、参数配置方式，有更深刻的认识。</p>"},{"title":"BLE安全机制从入门到放弃","date":"2019-05-14T05:02:11.000Z","top":true,"_content":"\n网上介绍BLE安全机制的文章大多只关注业务概念，如：配对加密是什么，绑定过程是什么；而忽略了其中涉及到的信息安全知识，如：使用了加密和认证有什么用，不用又会怎么样。让新人读了有种云里雾里，知其然而不知其所以然的感觉。这里结合涉及到的信息安全知识，换一个角度来认识BLE安全机制。\n<!-- more --> \n\n前言\n===\n\n标题中的“放弃”有点调侃的意思，是指读者在读完之后，可以不依赖别人，靠自己读蓝牙核心规范加深认识，这样收获也会更多，也是这篇博文的目标。\n\n为了易于理解，会对蓝牙核心规范的算法进行裁剪，但是原理是不变的，标准算法应参考蓝牙核心规范。\n\n最后，这是博主的一得之见，欢迎各位指正。\n\n目录\n===\n\n<!-- TOC -->\n\n- [密码技术初探](#密码技术初探)\n    - [对称密码](#对称密码)\n    - [diffie-hellman密钥交换算法](#diffie-hellman密钥交换算法)\n    - [椭圆曲线diffie-hellman密钥交换算法](#椭圆曲线diffie-hellman密钥交换算法)\n    - [消息认证码](#消息认证码)\n    - [认证加密CCM](#认证加密ccm)\n    - [信息安全小结](#信息安全小结)\n- [ble安全机制初探](#ble安全机制初探)\n    - [ble40安全机制](#ble40安全机制)\n    - [ble42安全机制](#ble42安全机制)\n- [总结](#总结)\n- [参考资料](#参考资料)\n\n<!-- /TOC -->\n\n# 密码技术初探\n\n在介绍密码技术之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。\n\n<div align=center>重要角色一览表![](ImportantPerson.png)\n</div>\n\nAlice和Bob分别是两家银行，Bob银行通过网络向Alice银行发送了一条500元的汇款请求：<strong>从账户B-6789向账户A-1234汇款500元</strong>。\n\n\n当然，会有人在网络中尝试攻击银行间通信，妄想用非法手段牟利，其中就有这样一个分工明确的组织，由以下成员组成：\n\n- Eve\n  - 窃听不同银行之间的消息，从中获取重要信息，如获知“从账户B-6789向账户A-1234汇款500元”。\n- Mallory：\n  - 篡改不同银行之间的消息，如修改汇款请求为“从账户B-6789向账户A-1234汇款5000000元”。\n  - 伪装成Bob银行，以Bob银行名义发送一条新的汇款请求给Alice银行。\n\n从上述例子可知消息面临的威胁有：`窃听`、`篡改`和`伪装`，对应的安全特性为：`机密性`、`一致性`、`是否已认证`。\n\n“威胁”和“安全特性”的关系可以这样描述：\n- 如果消息没有加密，消息则不具有机密性，无法防止他人窃听；\n- 如果发送者发送的消息和接收者的消息是不同的，说明消息被篡改过，不具有一致性；\n- 如果没有对消息进行认证，无法保证消息来自正确发送者而不是伪装者。\n\n存在威胁，就会有对应的解决方法，下面会针对每个威胁介绍对应的密码技术。\n\n## 对称密码\n\n算法一般指复杂步骤，加密算法指的是用明文生成密文的步骤，解密的步骤称为解密算法，两者统称为密码算法，密码算法需要用到密钥。\n\n所谓对称密码（symmetric cryptography）技术，即加密和解密时用的是同一个密钥，加密和解密的算法一般是公开的，如AES128。\n\n<div align=center>![](SymmetricCryptography.png)对称密码应用图\n</div>\n\n**对称密码解决的问题**\n\n如上图所示\n1. Bob创建一条汇款请求消息；\n2. 用密钥key对它加密；\n3. 将加密后的消息发给Alice；\n4. Alice收到密文；\n5. Eve窃听到了加密后的消息，由于没有密钥key，无法解读内容；\n6. Alice用密钥key对消息解密；\n7. Alice获得一条汇款请求消息。\n\n对称密码技术可以解决`窃听`的威胁。\n\n**对称密码无法解决的问题**\n\n对称密码技术可以解决`窃听`的威胁，但是有一个前提，就是在这之前发送者和接收者要有相同的密钥key，所以一定要先给接收者配送密钥，有以下几种方式：\n\n1. Bob通过网络先将key发送给Alice，但容易被Eve截取到；\n2. Bob乘坐交通工具将密钥key亲手交给Alice，或者其他网络以外的方式配送密钥，这种方式成本高维护麻烦，称为带外（Out-Of-Band）配送；\n3. 用diffie-hellman密钥交换算法解决；\n4. 用椭圆曲线diffie-hellman密钥交换算法解决。\n\n## diffie-hellman密钥交换算法\n\n先不管DH密钥交换算法是什么，我们现在关注问题是：在Eve窃听网络的情况下，如何解决Bob配送key给Alice的问题？\n\n密码界的前辈们从数学角度上找到了答案：利用这个数学难题，Bob和Alice可以在Eve窃听的情况下，协商出一个密钥，而Eve不知道密钥是什么。\n\n最好解决配送问题的办法就是不配送，通过协商获得相同的密钥，是不是很神奇，话不多说，我们看看是怎么实现的。\n\n**离散对数问题**\n\n背景知识：mod符号表达的意思是求余数，如表达式5 mod 7的计算思路为：5除以7等于0，余数为5，所以5 mod 7 = 5。\n\n现有离散对数问题如下，请问满足公式的x是多少：\n\n<div align=center>![](7^xmod13=8.png)</div>\n\n\n为了求x，我们可以运用上面提到的背景知识来做计算，像下面这样依次尝试一遍，就可以得到x = 9。\n\n<div align=center>![](7^xmod13=y.png)</div>\n\n例子的数字较小，所以很快就找到答案了，当数字很大时，计算x就会变得非常耗时，快速求出离散对数的算法到现在还没被发现，所以可以得到这样的一个简单结论：\n\n<div align=center>![](g^xmodp=y.png)</div>\n\n对于上图公式，已知G、p、Y的时候，很难求出x。\n\n接下来我们看看如何具体利用这个数学问题来协商出密钥的。\n\n**diffie-hellman密钥交换算法应用**\n\n在DH中，我们将Y称为公钥（public key），将x称为私钥（private key），则有以下结论：已知G、p、公钥的时候，很难求出私钥。\n\n<div align=center>![](DH.png)DH应用图\n</div>\n\n如上图所示\n1. Bob和Alice选择一个公开的G和p，Eve当然也知道这个公开的G和p；\n2. Bob和Alice分别随机生成各自的私钥sb和sa；\n3. Bob和Alice根据G、p以及各自的私钥，生成公钥pb和pa；\n4. Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa；\n5. Bob和Alice计算出共享密钥DHkey。\n\nEve能计算出DHkey吗？\n\n对比三个角色最后的“已知信息”可知，只要Eve知道任一私钥（sb或sa），它就能容易算出DHkey，而这时候问题就变成了：Eve在已知G、p、公钥情况下，是否能求出私钥，这也就是我们上面提到的离散对数问题，这是很难做到的。\n\n**diffie-hellman密钥交换算法解决的问题**\n\n因为DH密钥交换算法利用了“离散对数问题”的复杂度，所以就算Eve一直窃听，Bob和Alice也能协商出一个共享密钥，而Eve却因为复杂的数学问题而没办法算出共享密钥，也就解决了对称密码中的配送问题。\n\n## 椭圆曲线diffie-hellman密钥交换算法\n\nDH是利用了“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就叫椭圆曲线diffie-hellman密钥交换（ECDH）。\n\n两者密钥交换总体流程相同，只是利用的数学问题不同而已，ECDH能够用较短的密钥长度实现较高的安全性。\n\n**椭圆曲线diffie-hellman密钥交换算法应用**\n\nECDH中的数学问题可以这样简单定义：\n\n<div align=center>![](y=xg.png)</div>\n\n已知椭圆曲线上的点Y、基点G的时候，很难求出x。其中算术符号`*`表示的不是普通的乘法，而是一种在椭圆曲线上的特殊算法。\n\n在ECDH中，我们称Y为公钥（public key），x为私钥（private key）。\n\n<div align=center>![](ECDH.png)ECDH应用图\n</div>\n\n如上图所示\n1. Bob和Alice选择一条密码学家推荐的椭圆曲线，选择曲线上的一个基点G；\n2. Bob和Alice分别随机生成各自的私钥sb和sa；\n3. Bob和Alice根据G以及各自的私钥，生成公钥pb和pa；\n4. Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa；\n5. Bob和Alice计算出共享密钥DHkey。\n\n**椭圆曲线diffie-hellman密钥交换算法无法解决的问题**\n\nDH和ECDH都能解决密钥配送问题，结合对称密码技术，就能保证消息的机密性，防止被`窃听`了，但是对于`篡改`和`伪装`的攻击，却无能为力。为了解决剩下这两个威胁，就要靠其他技术手段了。\n\n<div align=center>![](tamper.png)篡改示意图\n</div>\n\n如上图所示，Mallory不需要知道密文是什么意思，但是他可以修改密文，导致Alice解密出预期以外的内容。\n\n<div align=center>![](camouflage.png)伪装示意图\n</div>\n\n如上图所示，Mallory夹在Bob和Alice之间并伪装他们。对于Mallory来说，DHkey是赤裸裸的，所以Bob和Alice互发的消息是没有机密性的，这种攻击也称为中间人攻击（MITM）。\n\n## 消息认证码\n\n消息认证码（MAC）技术是检查信息一致性并进行认证的技术，发送者通过MAC算法可以输出一个MIC值，接收者通过校验MIC值不仅可以判断消息一致性，还能判断消息是否来自正确的发送者。\n\n<div align=center>![](MAC.png)</div>\n\nMAC技术有以下几种重要性质：\n\n- 正向快速：给定明文、MAC算法和密钥key，在有限时间和有限资源内能计算出MIC。\n- 逆向困难：给定MIC、MAC算法和明文，在有限时间内很难（基本不可能）逆推出密钥。\n- 输入敏感：原始输入信息修改一点信息，产生的MIC看起来应该都有很大不同。\n- 冲突避免：很难找到两段内容不同的明文，使得它们的MIC一致（发生冲突）。即对于任意两个不同的数据块，其MIC相同的可能性极小；对于一个给定的数据块，找到和它MIC相同的数据块极为困难。\n\nMAC技术与对称加密技术有一个显著差异：加密解密是双向的，可以互相推导，而认证只能单向；加密是为了解密，MAC设计是无法解。\n\n**消息认证码解决的问题**\n\n消息经过CMAC算法之后，为何Mallory无法篡改消息和伪装呢？\n\n<div align=center>![](authentication.png)消息一致性检查和认证示意图\n</div>\n\n- Mallory如果想篡改明文，那就同时也要篡改MIC，否则无法通过Alice的校验，但是应该将MIC改成多少呢？因为Malloyr没有共享密钥，所以他也不知道MIC应该是什么。如果想篡改MIC，那就同时也要篡改明文才能通过Alice的校验，由于MAC算法的逆向困难性质，Mallory不知道明文应该是什么。\n\n- Bob用CMAC算法认证一条消息并发给Alice，并要求Alice也用CMAC算法认证并返回一条消息给Bob。若Mallory伪装成Alice，由于没有认证密钥，无法返回通过Bob校验的消息。\n\n**消息认证码无法解决的问题**\n\n没错，要使用MAC技术，首先要有相同的认证密钥，又回到了之前的密钥配送问题，具体这里采用哪种方式解决配送密钥问题，视实际情况而定。\n\n**消息认证码攻击方式**\n\n对于MAC算法来说，应保证不能根据MIC和明文推测出通信双方所使用的密钥。但实际上用穷举法是可以推测出来的，如果使用密码学安全的、高强度的伪随机数生成器生成密钥，就会使得破解时间需要很长以至在现实中几乎不可能破解。而如果密钥是人为选定的，就会大大增加被推测出来的风险。\n\n## 认证加密CCM\n\n其实上文一直在有意无意的强调一个事情，那就是加密和认证是独立的两个概念。加密能防止`窃听`，认证能防止`篡改`和`伪装`。前辈们用一种密码技术将两者融合起来——CCM（Counter with CBC-MAC）。\n\n通过查阅资料，以我的战五渣水平只能理解到这一程度：\n\n- 发送方先对明文使用MAC技术，然后对称加密成密文；\n- 接收方先用对称加密技术解密密文，然后用MAC技术校验明文；\n- 发送方和接收方需要至少一个共享随机数和一个共享密钥，随机数可以公开，密钥不可以公开。\n\n<div align=center>![](CCM.png)个人猜测CCM应用示意图\n</div>\n\n上图只是个人猜测的示意图，有可能是不对的，因为不是术业专攻方向，没有深入研究，秉着求真精神，觉得应该提醒大家，避免误导。\n\n放上图的目的是：加密和认证可以做在一个算法中，而且BLE就是这么用的。\n\n## 信息安全小结\n\n<div align=center>![](SecurityTechnology.png)威胁、安全特性、密码技术关系图\n</div>\n\n总结：\n- 为了解决`窃听`问题，采用对称密码技术；\n- 为了解决对称密码技术的加密密钥配送问题，采用配送密钥技术；\n- 为了解决`篡改`问题，采用消息认证码技术；\n- 为了解决`伪装`问题，采用消息认证码技术；\n- 为了解决消息认证码技术的认证密钥配送问题，采用配送密钥技术。\n\n> Tips：无论消息认证码技术还是对称密码技术，都需要用到配送密钥技术，而不同的配送密钥技术本身，也会涉及到认证强度的问题。比如希望用ECDH来解决消息认证码的认证密钥配送问题，但是ECDH本身认证强度为零，所以它也需要消息认证码技术来证明ECDH过程中没有出现篡改或者伪装攻击，即又要使用消息认证码技术，导致进入了死循环。所以需要选择合适的密钥配送技术，常见的有：邮箱验证码、手机短信验证码、NFC、目测法等。\n\n# ble安全机制初探\n\n在介绍ble安全机制之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。\n\n<div align=center>ble重要角色一览表![](BleImportantPerson.png)\n</div>\n\n背景知识：简单来说ble设备可分为两种角色，一种是主机角色（master），另一种是从机角色（slave），有以下几种差异：\n\n1. 建立连接前\n    - 主机能进入扫描状态、发起连接状态，不能进入广播状态；\n    - 从机能进入广播状态，不能进入扫描状态和发起连接状态；\n    - 一定是由主机发起连接，从机只能被连接。\n\n2. 建立连接后\n    - 一定是由主机发起配对，但是从机能够请求主机发起配对；\n    \n\n<div align=center>![](KindOfPhase.png)ble各个状态示意图\n</div>\n\n- 广播状态：设备正在往空中发送广播包，谁都可以收得到；\n- 扫描状态：设备正在接收空中的广播包，看看谁在发，发什么；\n- 发起连接状态：设备指定与另外一个设备发起连接；\n- 明文数传阶段：两个已连接设备之间，用明文传送数据包；\n- 配对阶段：两个已连接设备之间，运用密码技术生成各种安全强度的密钥；\n- 加密过程：两个已连接设备之间，使用配对阶段输出的密钥，或者绑定阶段提供的密钥，衍生出最终用于加密底层数据包的密钥；\n- 密文数传阶段：两个已连接设备之间，用密文传送数据包；\n- 绑定阶段：用“绑定”这个词特定描述配对阶段中的第三阶段，该阶段交换绑定信息，有了绑定信息下次需要密文数传可以跳过配对阶段。\n\n除了展示两种角色的异同，我觉得有必要通过上图澄清几个概念，加深大家的理解：\n\n1. 复杂密码技术是运用在已连接之后的配对阶段，所以不存在配对失败，导致ble无法正常建立连接，至多是配对失败，导致连接断开。\n2. 连接后，不一定要启动配对，如果明文数传已经满足应用要求，就没必要启动配对了。\n\n## ble40安全机制\n\n从用户角度提出问题：我现在对密码技术有初步了解了，也知道ble安全机制的一些背景知识，评估下来连接之后的明文数传风险太大，我要用到密文数传，ble提供什么样的解决方案呢？\n\n<div align=center>![](SmpAndEncryption.png)ble4.0安全机制简单示意图\n</div>\n\n上图是ble4.0安全机制简单示意图，是上一节“建立连接后”的细节展开，观察方式从上到下为角色的时间轴，从左到右分别是不同的角色，空白地方的文本为传递的数据，虚线为可选项，双斜杠为不展开讨论的内容。\n\n对于密文数传，ble提供解决方案分四种情况：\n\n1. 首次连接无绑定\n   - 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。\n\n2. 首次连接有绑定\n   - 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传，进入绑定阶段，从机将长期密钥（LTK）发送给主机保存。\n\n2. 第二次连接且首次连接无绑定\n   - 第二次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。\n\n3. 第二次连接且首次连接有绑定\n   - 第二次连接，跳过配对阶段，加密过程使用之前绑定的LTK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。\n\n由下往上读图，回答用户提出的问题：\n\nble4.0选择CCM给明文数据认证加密，想要使用CCM，就需要一个密钥和一个随机数用于CCM认证加密，所以ble有一个“加密过程”负责输出一个密钥（sessionKey）和一个随机数（IV），而加密过程又需要一个密钥来产生sessionKey，所以ble有一个“配对阶段”来输出一个临时密钥（STK）给加密过程，或者在绑定阶段输出一个长期密钥（LTK）给加密过程下一次连接时候使用。\n\n**TK配对码的生成和配送**\n\nble4.0的TK配对码生成和配送方式有多种，常用的两种TK配对码的生成和配送方式是：JustWorks和Passkey，他们有以下差异：\n\n1. JustWorks模式时，生成的TK是000000，因为这是公开的，没有配送的意义，配送目的是为了防止通信双方以外的第三方获得密钥，由于现在认证码是公开的，就没配送的意义了，而且由于认证码泄露，这种模式不能提供篡改和伪装保护。\n\n2. Passkey模式时，TK的生成方式和配送方式如下：通信其中一方如Alice随机生成TK为142536，通过显示屏/短信/NFC等蓝牙以外的输出数据的方式，将配对码告知给Bob's User，Bob's User通过键盘往Bob设备输入142536，使得Bob和Alice拥有一个共享认证密钥，而针对蓝牙基带攻击的第三方Mallory不知道，从而提供篡改和伪装保护。\n\n下面来看一下图，Passkey模式是怎么做到认证保护的。\n\n<div align=center>![](MITM.png)认证保护示意图\n</div>\n\n通过正常认证过程，可以发现Bob和Alice只在空中交互了两次，所以Mallory的攻击时机有两个，第一个是Bob和Alice交换MIC的时刻，另一个是在Bob和Alice交换明文的时刻。\n\n分两种攻击行为\n\n1. 篡改MIC或者明文其中一项，属于篡改攻击。\n    - 如果篡改MIC，那就是在未知明文和TK的情况下，凭空捏造一个EMIC，而且这个EMIC还要能够通过后续校验，这个几乎不可能。MIC是果，明文和TK是因，因果倒置不可能吧。\n    - 如果篡改明文，那就是给定MIC，基于MAC算法且未知认证密钥TK的情况下，推导出另一份明文，根据MAC算法性质，这个是很难做到的。\n\n2. 同时篡改MIC和明文，属于伪装攻击，也叫MITM攻击。\n    - 因为伪造认证码EMIC和伪造明文Erand是Mallory提供的，计算过程可能是EMIC = MAC(EK, Erand)，而真实配对码TK和伪造配对码EKEY只有百万分之一的几率是相同的，所以看作是不相同的，也即EK != TK，根据MAC的输入敏感性质，EMIC != MAC(TK, Erand)，最终认证失败。\n\n**ble4.0真的足够安全吗？**\n\n我们先列出ble4.0安全机制各个密钥的安全依赖关系：\n\nCCM -> sessionKey -> STK(LTK) -> TK\n\n可以看到，最终的源头是TK认证码，只有保证TK足够安全，密文才能保证安全，也就是说不能让非法分子获得TK，否则他们就能够将密文解密了。\n\n一般我们依靠MAC算法本身的性质，可以保证认证密钥不被推算出来，但是但是这些性质的前提是：认证密钥是使用密码学安全的、高强度的伪随机数生成器生成的，而且这些密钥位数很多，以至于无法穷举。\n\n而实际TK的取值是000000~999999，最多只有100万种可能性，先抓取配对阶段（phase2.2）中用到的明文、MIC，再通过穷举的方式，就可以推算出TK了。\n\n我们分析一下，如果在整个安全机制过程中，一直存在窃听者Eve，那么我们会面临什么威胁。\n\n> Tips：在这里也顺带分析静态配对码和动态配对码的区别，静态配对码是指每次输入都是固定的TK值，动态配对码是指每次输入都是动态产生的TK值，其实核心规范里面没有提过静态配对码，但是很多人会希望有如下功能：在一个设备预设一个配对码为123456，然后配对阶段时另一个设备输入配对码123456则通过认证，否则不通过，其实对于ble来说，由于TK可以被破解，所以静态配对码没有起到安全保护作用。\n\n- 如果是静态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。\n\n    1. Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改；\n    2. Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改；\n    3. 伪装Bob或者Alice与对方首次连接，因为TK是静态配对码，通过认证，伪装成功。\n    \n- 如果是动态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。\n\n    1. Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改；\n    2. Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改；\n    3. 伪装Bob或者Alice与对方首次连接，因为TK是动态配对码，之前破解的TK用不上，无法通过认证，伪装失败。\n\n总结出几个观点：\n\n1. 因为“加密”都依赖于认证码TK，而TK容易被穷举破解，加密则形同虚设。\n\n2. 上面描述的威胁，首先是窃听成功，才能篡改成功，问题是出在了窃听上。正常情况下对于密文的处理，CCM需要先解密，后认证。如果Eve没有窃听成功，乱篡改Bob发出的CCM认证加密过的密文，那么Alice解密出来的数据几乎不可能通过后续认证的。正是因为Eve窃听成功，知道篡改哪部分内容，所以才会造成威胁。解决窃听问题，就能同时解决篡改问题了。\n\n3. TK是不安全的，以至于如果使用静态配对码而不是动态配对码，就无法解决伪装问题，如果认证码不像TK那样范围窄，静态配对码技术本身也没什么问题，但是最好还是定期更新。\n\n上面总结的也是ble4.2安全机制里面做的一部分改善，比如增加破解TK的难度，引入ECDH解决窃听问题。\n\n## ble42安全机制\n\n上一节，我们分析了ble4.0的安全“漏洞\"， 接下来简单说一下ble4.2作出的应对措施。\n\n- 无法改变的前提：\n    1. 配对码是6个字节。\n\n- 可能的攻击方式：\n    1. Eve窃听整个过程，从而破解TK，下一次可以伪装Bob和Alice主动发起连接认证。\n    2. Eve窃听整个过程，从而破解TK，从而得到STK，然后窃取LTK。\n    3. Mallory发起MITM攻击，即使攻击失败，包含整个TK信息的MAC和MIC会被Mallory获得。（虽然我不知道有什么用）\n\n- 提出对应解决的方案：\n    1. 动态认证码；\n    2. ECDH保证机密性；\n    3. 将TK拆成20bit，每次认证一个bit，攻击失败只会暴露1个bit，不会暴露整个TK。\n\nBLE4.2与BLE4.0的安全机制区别主要体现在“配对阶段”的phase2，在这个阶段引入了ECDH，下面展开passkey模式的phase2（包括phase2.1~2.3）。\n\n<div align=center>![](ECDHMITM.png)BLE4.2 phase2示意图\n</div>\n\n在“Authentication Stage1”过程，可以发现Bob和Alice只在空中交互了三次，所以Mallory的攻击时机有三个：\n\n1. 交换公钥的时刻\n2. 交换MIC的时刻\n3. 交换明文的时刻。\n\n后两个攻击方式，在BLE4.0已经分析过了，至于第一个攻击时机，因为公钥是也是MAC算法里面的一个参数，所以它也不能被随意篡改，如果改了后面的Ea和Eb校验就不通过了，即给ECDH也提供了MITM保护。\n\n> Tips：这里之所以可以提供MITM保护的实质是人的参与，通过观察的方法获得配对码，绕开了蓝牙空中传输来获得配对码，从而不会受到第三者攻击。\n\n对比BLE4.2和BLE4.0的主要区别：\n\n- BLE4.2没有STK，在配对过程直接生成LTK，因为LTK在配对阶段就已经强制生成了，加密过程直接使用LTK，BLE4.2的绑定阶段(phase3)不会发送LTK。\n\n- LTK是DHkey衍生出来的，DHkey是第三方无法窃听也无法破解出来的，所以可以保证后面用CCM加密后数据的机密性。\n\nBLE4.2完美解决了BLE4.0的安全漏洞。\n\n# 总结\n\n文章提到的只是BLE常见的一些概念，其他如：签名（Signed）、授权（Authorization）之类都没有提及，有兴趣的读者可以去核心规范探索一番。\n\n参考资料里面有许多优秀的书籍和文章，比如密码技术相关知识我是从《图解密码技术》获知的，关于具体的实战抓包分析，吹爆“BLE配对过程详解”这篇文章。\n\n最后最后，感谢您阅读到最后，这是对我最大的鼓励，也希望这篇博文能让您有一点点的收获。\n\n后记\n===\n一开始是想将MESH加进来的，但是考虑到还没上过正式的项目去体验过，怕写出来理解的不够透彻，所以还是算了，以后有机会再单独开一篇吧，但是有兴趣的朋友可以私底下一起交流。\n\n\n# 参考资料\n- 《图解密码技术》\n- [BLE配对过程详解](http://bbs.21ic.com/blog-1827100-160300.html)\n- [BLE核心规范](https://www.bluetooth.com/specifications/bluetooth-core-specification/)\n- [Hash算法总结](https://blog.csdn.net/asdzheng/article/details/70226007)\n- [穷举法破解BLE的TK值](https://www.cnblogs.com/xumaojun/p/8541638.html)","source":"_posts/BLE安全机制从入门到放弃.md","raw":"---\ntitle: BLE安全机制从入门到放弃\ndate: 2019-05-14 13:02:11\ntags:\n- BLE\n- 安全机制\n- 蓝牙\n\ncategories:\n- 一得之见\n\ntop: true\n---\n\n网上介绍BLE安全机制的文章大多只关注业务概念，如：配对加密是什么，绑定过程是什么；而忽略了其中涉及到的信息安全知识，如：使用了加密和认证有什么用，不用又会怎么样。让新人读了有种云里雾里，知其然而不知其所以然的感觉。这里结合涉及到的信息安全知识，换一个角度来认识BLE安全机制。\n<!-- more --> \n\n前言\n===\n\n标题中的“放弃”有点调侃的意思，是指读者在读完之后，可以不依赖别人，靠自己读蓝牙核心规范加深认识，这样收获也会更多，也是这篇博文的目标。\n\n为了易于理解，会对蓝牙核心规范的算法进行裁剪，但是原理是不变的，标准算法应参考蓝牙核心规范。\n\n最后，这是博主的一得之见，欢迎各位指正。\n\n目录\n===\n\n<!-- TOC -->\n\n- [密码技术初探](#密码技术初探)\n    - [对称密码](#对称密码)\n    - [diffie-hellman密钥交换算法](#diffie-hellman密钥交换算法)\n    - [椭圆曲线diffie-hellman密钥交换算法](#椭圆曲线diffie-hellman密钥交换算法)\n    - [消息认证码](#消息认证码)\n    - [认证加密CCM](#认证加密ccm)\n    - [信息安全小结](#信息安全小结)\n- [ble安全机制初探](#ble安全机制初探)\n    - [ble40安全机制](#ble40安全机制)\n    - [ble42安全机制](#ble42安全机制)\n- [总结](#总结)\n- [参考资料](#参考资料)\n\n<!-- /TOC -->\n\n# 密码技术初探\n\n在介绍密码技术之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。\n\n<div align=center>重要角色一览表![](ImportantPerson.png)\n</div>\n\nAlice和Bob分别是两家银行，Bob银行通过网络向Alice银行发送了一条500元的汇款请求：<strong>从账户B-6789向账户A-1234汇款500元</strong>。\n\n\n当然，会有人在网络中尝试攻击银行间通信，妄想用非法手段牟利，其中就有这样一个分工明确的组织，由以下成员组成：\n\n- Eve\n  - 窃听不同银行之间的消息，从中获取重要信息，如获知“从账户B-6789向账户A-1234汇款500元”。\n- Mallory：\n  - 篡改不同银行之间的消息，如修改汇款请求为“从账户B-6789向账户A-1234汇款5000000元”。\n  - 伪装成Bob银行，以Bob银行名义发送一条新的汇款请求给Alice银行。\n\n从上述例子可知消息面临的威胁有：`窃听`、`篡改`和`伪装`，对应的安全特性为：`机密性`、`一致性`、`是否已认证`。\n\n“威胁”和“安全特性”的关系可以这样描述：\n- 如果消息没有加密，消息则不具有机密性，无法防止他人窃听；\n- 如果发送者发送的消息和接收者的消息是不同的，说明消息被篡改过，不具有一致性；\n- 如果没有对消息进行认证，无法保证消息来自正确发送者而不是伪装者。\n\n存在威胁，就会有对应的解决方法，下面会针对每个威胁介绍对应的密码技术。\n\n## 对称密码\n\n算法一般指复杂步骤，加密算法指的是用明文生成密文的步骤，解密的步骤称为解密算法，两者统称为密码算法，密码算法需要用到密钥。\n\n所谓对称密码（symmetric cryptography）技术，即加密和解密时用的是同一个密钥，加密和解密的算法一般是公开的，如AES128。\n\n<div align=center>![](SymmetricCryptography.png)对称密码应用图\n</div>\n\n**对称密码解决的问题**\n\n如上图所示\n1. Bob创建一条汇款请求消息；\n2. 用密钥key对它加密；\n3. 将加密后的消息发给Alice；\n4. Alice收到密文；\n5. Eve窃听到了加密后的消息，由于没有密钥key，无法解读内容；\n6. Alice用密钥key对消息解密；\n7. Alice获得一条汇款请求消息。\n\n对称密码技术可以解决`窃听`的威胁。\n\n**对称密码无法解决的问题**\n\n对称密码技术可以解决`窃听`的威胁，但是有一个前提，就是在这之前发送者和接收者要有相同的密钥key，所以一定要先给接收者配送密钥，有以下几种方式：\n\n1. Bob通过网络先将key发送给Alice，但容易被Eve截取到；\n2. Bob乘坐交通工具将密钥key亲手交给Alice，或者其他网络以外的方式配送密钥，这种方式成本高维护麻烦，称为带外（Out-Of-Band）配送；\n3. 用diffie-hellman密钥交换算法解决；\n4. 用椭圆曲线diffie-hellman密钥交换算法解决。\n\n## diffie-hellman密钥交换算法\n\n先不管DH密钥交换算法是什么，我们现在关注问题是：在Eve窃听网络的情况下，如何解决Bob配送key给Alice的问题？\n\n密码界的前辈们从数学角度上找到了答案：利用这个数学难题，Bob和Alice可以在Eve窃听的情况下，协商出一个密钥，而Eve不知道密钥是什么。\n\n最好解决配送问题的办法就是不配送，通过协商获得相同的密钥，是不是很神奇，话不多说，我们看看是怎么实现的。\n\n**离散对数问题**\n\n背景知识：mod符号表达的意思是求余数，如表达式5 mod 7的计算思路为：5除以7等于0，余数为5，所以5 mod 7 = 5。\n\n现有离散对数问题如下，请问满足公式的x是多少：\n\n<div align=center>![](7^xmod13=8.png)</div>\n\n\n为了求x，我们可以运用上面提到的背景知识来做计算，像下面这样依次尝试一遍，就可以得到x = 9。\n\n<div align=center>![](7^xmod13=y.png)</div>\n\n例子的数字较小，所以很快就找到答案了，当数字很大时，计算x就会变得非常耗时，快速求出离散对数的算法到现在还没被发现，所以可以得到这样的一个简单结论：\n\n<div align=center>![](g^xmodp=y.png)</div>\n\n对于上图公式，已知G、p、Y的时候，很难求出x。\n\n接下来我们看看如何具体利用这个数学问题来协商出密钥的。\n\n**diffie-hellman密钥交换算法应用**\n\n在DH中，我们将Y称为公钥（public key），将x称为私钥（private key），则有以下结论：已知G、p、公钥的时候，很难求出私钥。\n\n<div align=center>![](DH.png)DH应用图\n</div>\n\n如上图所示\n1. Bob和Alice选择一个公开的G和p，Eve当然也知道这个公开的G和p；\n2. Bob和Alice分别随机生成各自的私钥sb和sa；\n3. Bob和Alice根据G、p以及各自的私钥，生成公钥pb和pa；\n4. Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa；\n5. Bob和Alice计算出共享密钥DHkey。\n\nEve能计算出DHkey吗？\n\n对比三个角色最后的“已知信息”可知，只要Eve知道任一私钥（sb或sa），它就能容易算出DHkey，而这时候问题就变成了：Eve在已知G、p、公钥情况下，是否能求出私钥，这也就是我们上面提到的离散对数问题，这是很难做到的。\n\n**diffie-hellman密钥交换算法解决的问题**\n\n因为DH密钥交换算法利用了“离散对数问题”的复杂度，所以就算Eve一直窃听，Bob和Alice也能协商出一个共享密钥，而Eve却因为复杂的数学问题而没办法算出共享密钥，也就解决了对称密码中的配送问题。\n\n## 椭圆曲线diffie-hellman密钥交换算法\n\nDH是利用了“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就叫椭圆曲线diffie-hellman密钥交换（ECDH）。\n\n两者密钥交换总体流程相同，只是利用的数学问题不同而已，ECDH能够用较短的密钥长度实现较高的安全性。\n\n**椭圆曲线diffie-hellman密钥交换算法应用**\n\nECDH中的数学问题可以这样简单定义：\n\n<div align=center>![](y=xg.png)</div>\n\n已知椭圆曲线上的点Y、基点G的时候，很难求出x。其中算术符号`*`表示的不是普通的乘法，而是一种在椭圆曲线上的特殊算法。\n\n在ECDH中，我们称Y为公钥（public key），x为私钥（private key）。\n\n<div align=center>![](ECDH.png)ECDH应用图\n</div>\n\n如上图所示\n1. Bob和Alice选择一条密码学家推荐的椭圆曲线，选择曲线上的一个基点G；\n2. Bob和Alice分别随机生成各自的私钥sb和sa；\n3. Bob和Alice根据G以及各自的私钥，生成公钥pb和pa；\n4. Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa；\n5. Bob和Alice计算出共享密钥DHkey。\n\n**椭圆曲线diffie-hellman密钥交换算法无法解决的问题**\n\nDH和ECDH都能解决密钥配送问题，结合对称密码技术，就能保证消息的机密性，防止被`窃听`了，但是对于`篡改`和`伪装`的攻击，却无能为力。为了解决剩下这两个威胁，就要靠其他技术手段了。\n\n<div align=center>![](tamper.png)篡改示意图\n</div>\n\n如上图所示，Mallory不需要知道密文是什么意思，但是他可以修改密文，导致Alice解密出预期以外的内容。\n\n<div align=center>![](camouflage.png)伪装示意图\n</div>\n\n如上图所示，Mallory夹在Bob和Alice之间并伪装他们。对于Mallory来说，DHkey是赤裸裸的，所以Bob和Alice互发的消息是没有机密性的，这种攻击也称为中间人攻击（MITM）。\n\n## 消息认证码\n\n消息认证码（MAC）技术是检查信息一致性并进行认证的技术，发送者通过MAC算法可以输出一个MIC值，接收者通过校验MIC值不仅可以判断消息一致性，还能判断消息是否来自正确的发送者。\n\n<div align=center>![](MAC.png)</div>\n\nMAC技术有以下几种重要性质：\n\n- 正向快速：给定明文、MAC算法和密钥key，在有限时间和有限资源内能计算出MIC。\n- 逆向困难：给定MIC、MAC算法和明文，在有限时间内很难（基本不可能）逆推出密钥。\n- 输入敏感：原始输入信息修改一点信息，产生的MIC看起来应该都有很大不同。\n- 冲突避免：很难找到两段内容不同的明文，使得它们的MIC一致（发生冲突）。即对于任意两个不同的数据块，其MIC相同的可能性极小；对于一个给定的数据块，找到和它MIC相同的数据块极为困难。\n\nMAC技术与对称加密技术有一个显著差异：加密解密是双向的，可以互相推导，而认证只能单向；加密是为了解密，MAC设计是无法解。\n\n**消息认证码解决的问题**\n\n消息经过CMAC算法之后，为何Mallory无法篡改消息和伪装呢？\n\n<div align=center>![](authentication.png)消息一致性检查和认证示意图\n</div>\n\n- Mallory如果想篡改明文，那就同时也要篡改MIC，否则无法通过Alice的校验，但是应该将MIC改成多少呢？因为Malloyr没有共享密钥，所以他也不知道MIC应该是什么。如果想篡改MIC，那就同时也要篡改明文才能通过Alice的校验，由于MAC算法的逆向困难性质，Mallory不知道明文应该是什么。\n\n- Bob用CMAC算法认证一条消息并发给Alice，并要求Alice也用CMAC算法认证并返回一条消息给Bob。若Mallory伪装成Alice，由于没有认证密钥，无法返回通过Bob校验的消息。\n\n**消息认证码无法解决的问题**\n\n没错，要使用MAC技术，首先要有相同的认证密钥，又回到了之前的密钥配送问题，具体这里采用哪种方式解决配送密钥问题，视实际情况而定。\n\n**消息认证码攻击方式**\n\n对于MAC算法来说，应保证不能根据MIC和明文推测出通信双方所使用的密钥。但实际上用穷举法是可以推测出来的，如果使用密码学安全的、高强度的伪随机数生成器生成密钥，就会使得破解时间需要很长以至在现实中几乎不可能破解。而如果密钥是人为选定的，就会大大增加被推测出来的风险。\n\n## 认证加密CCM\n\n其实上文一直在有意无意的强调一个事情，那就是加密和认证是独立的两个概念。加密能防止`窃听`，认证能防止`篡改`和`伪装`。前辈们用一种密码技术将两者融合起来——CCM（Counter with CBC-MAC）。\n\n通过查阅资料，以我的战五渣水平只能理解到这一程度：\n\n- 发送方先对明文使用MAC技术，然后对称加密成密文；\n- 接收方先用对称加密技术解密密文，然后用MAC技术校验明文；\n- 发送方和接收方需要至少一个共享随机数和一个共享密钥，随机数可以公开，密钥不可以公开。\n\n<div align=center>![](CCM.png)个人猜测CCM应用示意图\n</div>\n\n上图只是个人猜测的示意图，有可能是不对的，因为不是术业专攻方向，没有深入研究，秉着求真精神，觉得应该提醒大家，避免误导。\n\n放上图的目的是：加密和认证可以做在一个算法中，而且BLE就是这么用的。\n\n## 信息安全小结\n\n<div align=center>![](SecurityTechnology.png)威胁、安全特性、密码技术关系图\n</div>\n\n总结：\n- 为了解决`窃听`问题，采用对称密码技术；\n- 为了解决对称密码技术的加密密钥配送问题，采用配送密钥技术；\n- 为了解决`篡改`问题，采用消息认证码技术；\n- 为了解决`伪装`问题，采用消息认证码技术；\n- 为了解决消息认证码技术的认证密钥配送问题，采用配送密钥技术。\n\n> Tips：无论消息认证码技术还是对称密码技术，都需要用到配送密钥技术，而不同的配送密钥技术本身，也会涉及到认证强度的问题。比如希望用ECDH来解决消息认证码的认证密钥配送问题，但是ECDH本身认证强度为零，所以它也需要消息认证码技术来证明ECDH过程中没有出现篡改或者伪装攻击，即又要使用消息认证码技术，导致进入了死循环。所以需要选择合适的密钥配送技术，常见的有：邮箱验证码、手机短信验证码、NFC、目测法等。\n\n# ble安全机制初探\n\n在介绍ble安全机制之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。\n\n<div align=center>ble重要角色一览表![](BleImportantPerson.png)\n</div>\n\n背景知识：简单来说ble设备可分为两种角色，一种是主机角色（master），另一种是从机角色（slave），有以下几种差异：\n\n1. 建立连接前\n    - 主机能进入扫描状态、发起连接状态，不能进入广播状态；\n    - 从机能进入广播状态，不能进入扫描状态和发起连接状态；\n    - 一定是由主机发起连接，从机只能被连接。\n\n2. 建立连接后\n    - 一定是由主机发起配对，但是从机能够请求主机发起配对；\n    \n\n<div align=center>![](KindOfPhase.png)ble各个状态示意图\n</div>\n\n- 广播状态：设备正在往空中发送广播包，谁都可以收得到；\n- 扫描状态：设备正在接收空中的广播包，看看谁在发，发什么；\n- 发起连接状态：设备指定与另外一个设备发起连接；\n- 明文数传阶段：两个已连接设备之间，用明文传送数据包；\n- 配对阶段：两个已连接设备之间，运用密码技术生成各种安全强度的密钥；\n- 加密过程：两个已连接设备之间，使用配对阶段输出的密钥，或者绑定阶段提供的密钥，衍生出最终用于加密底层数据包的密钥；\n- 密文数传阶段：两个已连接设备之间，用密文传送数据包；\n- 绑定阶段：用“绑定”这个词特定描述配对阶段中的第三阶段，该阶段交换绑定信息，有了绑定信息下次需要密文数传可以跳过配对阶段。\n\n除了展示两种角色的异同，我觉得有必要通过上图澄清几个概念，加深大家的理解：\n\n1. 复杂密码技术是运用在已连接之后的配对阶段，所以不存在配对失败，导致ble无法正常建立连接，至多是配对失败，导致连接断开。\n2. 连接后，不一定要启动配对，如果明文数传已经满足应用要求，就没必要启动配对了。\n\n## ble40安全机制\n\n从用户角度提出问题：我现在对密码技术有初步了解了，也知道ble安全机制的一些背景知识，评估下来连接之后的明文数传风险太大，我要用到密文数传，ble提供什么样的解决方案呢？\n\n<div align=center>![](SmpAndEncryption.png)ble4.0安全机制简单示意图\n</div>\n\n上图是ble4.0安全机制简单示意图，是上一节“建立连接后”的细节展开，观察方式从上到下为角色的时间轴，从左到右分别是不同的角色，空白地方的文本为传递的数据，虚线为可选项，双斜杠为不展开讨论的内容。\n\n对于密文数传，ble提供解决方案分四种情况：\n\n1. 首次连接无绑定\n   - 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。\n\n2. 首次连接有绑定\n   - 首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传，进入绑定阶段，从机将长期密钥（LTK）发送给主机保存。\n\n2. 第二次连接且首次连接无绑定\n   - 第二次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。\n\n3. 第二次连接且首次连接有绑定\n   - 第二次连接，跳过配对阶段，加密过程使用之前绑定的LTK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。\n\n由下往上读图，回答用户提出的问题：\n\nble4.0选择CCM给明文数据认证加密，想要使用CCM，就需要一个密钥和一个随机数用于CCM认证加密，所以ble有一个“加密过程”负责输出一个密钥（sessionKey）和一个随机数（IV），而加密过程又需要一个密钥来产生sessionKey，所以ble有一个“配对阶段”来输出一个临时密钥（STK）给加密过程，或者在绑定阶段输出一个长期密钥（LTK）给加密过程下一次连接时候使用。\n\n**TK配对码的生成和配送**\n\nble4.0的TK配对码生成和配送方式有多种，常用的两种TK配对码的生成和配送方式是：JustWorks和Passkey，他们有以下差异：\n\n1. JustWorks模式时，生成的TK是000000，因为这是公开的，没有配送的意义，配送目的是为了防止通信双方以外的第三方获得密钥，由于现在认证码是公开的，就没配送的意义了，而且由于认证码泄露，这种模式不能提供篡改和伪装保护。\n\n2. Passkey模式时，TK的生成方式和配送方式如下：通信其中一方如Alice随机生成TK为142536，通过显示屏/短信/NFC等蓝牙以外的输出数据的方式，将配对码告知给Bob's User，Bob's User通过键盘往Bob设备输入142536，使得Bob和Alice拥有一个共享认证密钥，而针对蓝牙基带攻击的第三方Mallory不知道，从而提供篡改和伪装保护。\n\n下面来看一下图，Passkey模式是怎么做到认证保护的。\n\n<div align=center>![](MITM.png)认证保护示意图\n</div>\n\n通过正常认证过程，可以发现Bob和Alice只在空中交互了两次，所以Mallory的攻击时机有两个，第一个是Bob和Alice交换MIC的时刻，另一个是在Bob和Alice交换明文的时刻。\n\n分两种攻击行为\n\n1. 篡改MIC或者明文其中一项，属于篡改攻击。\n    - 如果篡改MIC，那就是在未知明文和TK的情况下，凭空捏造一个EMIC，而且这个EMIC还要能够通过后续校验，这个几乎不可能。MIC是果，明文和TK是因，因果倒置不可能吧。\n    - 如果篡改明文，那就是给定MIC，基于MAC算法且未知认证密钥TK的情况下，推导出另一份明文，根据MAC算法性质，这个是很难做到的。\n\n2. 同时篡改MIC和明文，属于伪装攻击，也叫MITM攻击。\n    - 因为伪造认证码EMIC和伪造明文Erand是Mallory提供的，计算过程可能是EMIC = MAC(EK, Erand)，而真实配对码TK和伪造配对码EKEY只有百万分之一的几率是相同的，所以看作是不相同的，也即EK != TK，根据MAC的输入敏感性质，EMIC != MAC(TK, Erand)，最终认证失败。\n\n**ble4.0真的足够安全吗？**\n\n我们先列出ble4.0安全机制各个密钥的安全依赖关系：\n\nCCM -> sessionKey -> STK(LTK) -> TK\n\n可以看到，最终的源头是TK认证码，只有保证TK足够安全，密文才能保证安全，也就是说不能让非法分子获得TK，否则他们就能够将密文解密了。\n\n一般我们依靠MAC算法本身的性质，可以保证认证密钥不被推算出来，但是但是这些性质的前提是：认证密钥是使用密码学安全的、高强度的伪随机数生成器生成的，而且这些密钥位数很多，以至于无法穷举。\n\n而实际TK的取值是000000~999999，最多只有100万种可能性，先抓取配对阶段（phase2.2）中用到的明文、MIC，再通过穷举的方式，就可以推算出TK了。\n\n我们分析一下，如果在整个安全机制过程中，一直存在窃听者Eve，那么我们会面临什么威胁。\n\n> Tips：在这里也顺带分析静态配对码和动态配对码的区别，静态配对码是指每次输入都是固定的TK值，动态配对码是指每次输入都是动态产生的TK值，其实核心规范里面没有提过静态配对码，但是很多人会希望有如下功能：在一个设备预设一个配对码为123456，然后配对阶段时另一个设备输入配对码123456则通过认证，否则不通过，其实对于ble来说，由于TK可以被破解，所以静态配对码没有起到安全保护作用。\n\n- 如果是静态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。\n\n    1. Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改；\n    2. Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改；\n    3. 伪装Bob或者Alice与对方首次连接，因为TK是静态配对码，通过认证，伪装成功。\n    \n- 如果是动态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。\n\n    1. Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改；\n    2. Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改；\n    3. 伪装Bob或者Alice与对方首次连接，因为TK是动态配对码，之前破解的TK用不上，无法通过认证，伪装失败。\n\n总结出几个观点：\n\n1. 因为“加密”都依赖于认证码TK，而TK容易被穷举破解，加密则形同虚设。\n\n2. 上面描述的威胁，首先是窃听成功，才能篡改成功，问题是出在了窃听上。正常情况下对于密文的处理，CCM需要先解密，后认证。如果Eve没有窃听成功，乱篡改Bob发出的CCM认证加密过的密文，那么Alice解密出来的数据几乎不可能通过后续认证的。正是因为Eve窃听成功，知道篡改哪部分内容，所以才会造成威胁。解决窃听问题，就能同时解决篡改问题了。\n\n3. TK是不安全的，以至于如果使用静态配对码而不是动态配对码，就无法解决伪装问题，如果认证码不像TK那样范围窄，静态配对码技术本身也没什么问题，但是最好还是定期更新。\n\n上面总结的也是ble4.2安全机制里面做的一部分改善，比如增加破解TK的难度，引入ECDH解决窃听问题。\n\n## ble42安全机制\n\n上一节，我们分析了ble4.0的安全“漏洞\"， 接下来简单说一下ble4.2作出的应对措施。\n\n- 无法改变的前提：\n    1. 配对码是6个字节。\n\n- 可能的攻击方式：\n    1. Eve窃听整个过程，从而破解TK，下一次可以伪装Bob和Alice主动发起连接认证。\n    2. Eve窃听整个过程，从而破解TK，从而得到STK，然后窃取LTK。\n    3. Mallory发起MITM攻击，即使攻击失败，包含整个TK信息的MAC和MIC会被Mallory获得。（虽然我不知道有什么用）\n\n- 提出对应解决的方案：\n    1. 动态认证码；\n    2. ECDH保证机密性；\n    3. 将TK拆成20bit，每次认证一个bit，攻击失败只会暴露1个bit，不会暴露整个TK。\n\nBLE4.2与BLE4.0的安全机制区别主要体现在“配对阶段”的phase2，在这个阶段引入了ECDH，下面展开passkey模式的phase2（包括phase2.1~2.3）。\n\n<div align=center>![](ECDHMITM.png)BLE4.2 phase2示意图\n</div>\n\n在“Authentication Stage1”过程，可以发现Bob和Alice只在空中交互了三次，所以Mallory的攻击时机有三个：\n\n1. 交换公钥的时刻\n2. 交换MIC的时刻\n3. 交换明文的时刻。\n\n后两个攻击方式，在BLE4.0已经分析过了，至于第一个攻击时机，因为公钥是也是MAC算法里面的一个参数，所以它也不能被随意篡改，如果改了后面的Ea和Eb校验就不通过了，即给ECDH也提供了MITM保护。\n\n> Tips：这里之所以可以提供MITM保护的实质是人的参与，通过观察的方法获得配对码，绕开了蓝牙空中传输来获得配对码，从而不会受到第三者攻击。\n\n对比BLE4.2和BLE4.0的主要区别：\n\n- BLE4.2没有STK，在配对过程直接生成LTK，因为LTK在配对阶段就已经强制生成了，加密过程直接使用LTK，BLE4.2的绑定阶段(phase3)不会发送LTK。\n\n- LTK是DHkey衍生出来的，DHkey是第三方无法窃听也无法破解出来的，所以可以保证后面用CCM加密后数据的机密性。\n\nBLE4.2完美解决了BLE4.0的安全漏洞。\n\n# 总结\n\n文章提到的只是BLE常见的一些概念，其他如：签名（Signed）、授权（Authorization）之类都没有提及，有兴趣的读者可以去核心规范探索一番。\n\n参考资料里面有许多优秀的书籍和文章，比如密码技术相关知识我是从《图解密码技术》获知的，关于具体的实战抓包分析，吹爆“BLE配对过程详解”这篇文章。\n\n最后最后，感谢您阅读到最后，这是对我最大的鼓励，也希望这篇博文能让您有一点点的收获。\n\n后记\n===\n一开始是想将MESH加进来的，但是考虑到还没上过正式的项目去体验过，怕写出来理解的不够透彻，所以还是算了，以后有机会再单独开一篇吧，但是有兴趣的朋友可以私底下一起交流。\n\n\n# 参考资料\n- 《图解密码技术》\n- [BLE配对过程详解](http://bbs.21ic.com/blog-1827100-160300.html)\n- [BLE核心规范](https://www.bluetooth.com/specifications/bluetooth-core-specification/)\n- [Hash算法总结](https://blog.csdn.net/asdzheng/article/details/70226007)\n- [穷举法破解BLE的TK值](https://www.cnblogs.com/xumaojun/p/8541638.html)","slug":"BLE安全机制从入门到放弃","published":1,"updated":"2019-06-08T04:49:11.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8qal001lgcg8edulpzf9","content":"<p>网上介绍BLE安全机制的文章大多只关注业务概念，如：配对加密是什么，绑定过程是什么；而忽略了其中涉及到的信息安全知识，如：使用了加密和认证有什么用，不用又会怎么样。让新人读了有种云里雾里，知其然而不知其所以然的感觉。这里结合涉及到的信息安全知识，换一个角度来认识BLE安全机制。<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>标题中的“放弃”有点调侃的意思，是指读者在读完之后，可以不依赖别人，靠自己读蓝牙核心规范加深认识，这样收获也会更多，也是这篇博文的目标。</p>\n<p>为了易于理解，会对蓝牙核心规范的算法进行裁剪，但是原理是不变的，标准算法应参考蓝牙核心规范。</p>\n<p>最后，这是博主的一得之见，欢迎各位指正。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#密码技术初探\">密码技术初探</a><ul>\n<li><a href=\"#对称密码\">对称密码</a></li>\n<li><a href=\"#diffie-hellman密钥交换算法\">diffie-hellman密钥交换算法</a></li>\n<li><a href=\"#椭圆曲线diffie-hellman密钥交换算法\">椭圆曲线diffie-hellman密钥交换算法</a></li>\n<li><a href=\"#消息认证码\">消息认证码</a></li>\n<li><a href=\"#认证加密ccm\">认证加密CCM</a></li>\n<li><a href=\"#信息安全小结\">信息安全小结</a></li>\n</ul>\n</li>\n<li><a href=\"#ble安全机制初探\">ble安全机制初探</a><ul>\n<li><a href=\"#ble40安全机制\">ble40安全机制</a></li>\n<li><a href=\"#ble42安全机制\">ble42安全机制</a></li>\n</ul>\n</li>\n<li><a href=\"#总结\">总结</a></li>\n<li><a href=\"#参考资料\">参考资料</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"密码技术初探\"><a href=\"#密码技术初探\" class=\"headerlink\" title=\"密码技术初探\"></a>密码技术初探</h1><p>在介绍密码技术之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。</p>\n<div align=\"center\">重要角色一览表<img src=\"ImportantPerson.png\" alt><br></div>\n\n<p>Alice和Bob分别是两家银行，Bob银行通过网络向Alice银行发送了一条500元的汇款请求：<strong>从账户B-6789向账户A-1234汇款500元</strong>。</p>\n<p>当然，会有人在网络中尝试攻击银行间通信，妄想用非法手段牟利，其中就有这样一个分工明确的组织，由以下成员组成：</p>\n<ul>\n<li>Eve<ul>\n<li>窃听不同银行之间的消息，从中获取重要信息，如获知“从账户B-6789向账户A-1234汇款500元”。</li>\n</ul>\n</li>\n<li>Mallory：<ul>\n<li>篡改不同银行之间的消息，如修改汇款请求为“从账户B-6789向账户A-1234汇款5000000元”。</li>\n<li>伪装成Bob银行，以Bob银行名义发送一条新的汇款请求给Alice银行。</li>\n</ul>\n</li>\n</ul>\n<p>从上述例子可知消息面临的威胁有：<code>窃听</code>、<code>篡改</code>和<code>伪装</code>，对应的安全特性为：<code>机密性</code>、<code>一致性</code>、<code>是否已认证</code>。</p>\n<p>“威胁”和“安全特性”的关系可以这样描述：</p>\n<ul>\n<li>如果消息没有加密，消息则不具有机密性，无法防止他人窃听；</li>\n<li>如果发送者发送的消息和接收者的消息是不同的，说明消息被篡改过，不具有一致性；</li>\n<li>如果没有对消息进行认证，无法保证消息来自正确发送者而不是伪装者。</li>\n</ul>\n<p>存在威胁，就会有对应的解决方法，下面会针对每个威胁介绍对应的密码技术。</p>\n<h2 id=\"对称密码\"><a href=\"#对称密码\" class=\"headerlink\" title=\"对称密码\"></a>对称密码</h2><p>算法一般指复杂步骤，加密算法指的是用明文生成密文的步骤，解密的步骤称为解密算法，两者统称为密码算法，密码算法需要用到密钥。</p>\n<p>所谓对称密码（symmetric cryptography）技术，即加密和解密时用的是同一个密钥，加密和解密的算法一般是公开的，如AES128。</p>\n<div align=\"center\"><img src=\"SymmetricCryptography.png\" alt>对称密码应用图<br></div>\n\n<p><strong>对称密码解决的问题</strong></p>\n<p>如上图所示</p>\n<ol>\n<li>Bob创建一条汇款请求消息；</li>\n<li>用密钥key对它加密；</li>\n<li>将加密后的消息发给Alice；</li>\n<li>Alice收到密文；</li>\n<li>Eve窃听到了加密后的消息，由于没有密钥key，无法解读内容；</li>\n<li>Alice用密钥key对消息解密；</li>\n<li>Alice获得一条汇款请求消息。</li>\n</ol>\n<p>对称密码技术可以解决<code>窃听</code>的威胁。</p>\n<p><strong>对称密码无法解决的问题</strong></p>\n<p>对称密码技术可以解决<code>窃听</code>的威胁，但是有一个前提，就是在这之前发送者和接收者要有相同的密钥key，所以一定要先给接收者配送密钥，有以下几种方式：</p>\n<ol>\n<li>Bob通过网络先将key发送给Alice，但容易被Eve截取到；</li>\n<li>Bob乘坐交通工具将密钥key亲手交给Alice，或者其他网络以外的方式配送密钥，这种方式成本高维护麻烦，称为带外（Out-Of-Band）配送；</li>\n<li>用diffie-hellman密钥交换算法解决；</li>\n<li>用椭圆曲线diffie-hellman密钥交换算法解决。</li>\n</ol>\n<h2 id=\"diffie-hellman密钥交换算法\"><a href=\"#diffie-hellman密钥交换算法\" class=\"headerlink\" title=\"diffie-hellman密钥交换算法\"></a>diffie-hellman密钥交换算法</h2><p>先不管DH密钥交换算法是什么，我们现在关注问题是：在Eve窃听网络的情况下，如何解决Bob配送key给Alice的问题？</p>\n<p>密码界的前辈们从数学角度上找到了答案：利用这个数学难题，Bob和Alice可以在Eve窃听的情况下，协商出一个密钥，而Eve不知道密钥是什么。</p>\n<p>最好解决配送问题的办法就是不配送，通过协商获得相同的密钥，是不是很神奇，话不多说，我们看看是怎么实现的。</p>\n<p><strong>离散对数问题</strong></p>\n<p>背景知识：mod符号表达的意思是求余数，如表达式5 mod 7的计算思路为：5除以7等于0，余数为5，所以5 mod 7 = 5。</p>\n<p>现有离散对数问题如下，请问满足公式的x是多少：</p>\n<div align=\"center\"><img src=\"7^xmod13=8.png\" alt></div>\n\n\n<p>为了求x，我们可以运用上面提到的背景知识来做计算，像下面这样依次尝试一遍，就可以得到x = 9。</p>\n<div align=\"center\"><img src=\"7^xmod13=y.png\" alt></div>\n\n<p>例子的数字较小，所以很快就找到答案了，当数字很大时，计算x就会变得非常耗时，快速求出离散对数的算法到现在还没被发现，所以可以得到这样的一个简单结论：</p>\n<div align=\"center\"><img src=\"g^xmodp=y.png\" alt></div>\n\n<p>对于上图公式，已知G、p、Y的时候，很难求出x。</p>\n<p>接下来我们看看如何具体利用这个数学问题来协商出密钥的。</p>\n<p><strong>diffie-hellman密钥交换算法应用</strong></p>\n<p>在DH中，我们将Y称为公钥（public key），将x称为私钥（private key），则有以下结论：已知G、p、公钥的时候，很难求出私钥。</p>\n<div align=\"center\"><img src=\"DH.png\" alt>DH应用图<br></div>\n\n<p>如上图所示</p>\n<ol>\n<li>Bob和Alice选择一个公开的G和p，Eve当然也知道这个公开的G和p；</li>\n<li>Bob和Alice分别随机生成各自的私钥sb和sa；</li>\n<li>Bob和Alice根据G、p以及各自的私钥，生成公钥pb和pa；</li>\n<li>Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa；</li>\n<li>Bob和Alice计算出共享密钥DHkey。</li>\n</ol>\n<p>Eve能计算出DHkey吗？</p>\n<p>对比三个角色最后的“已知信息”可知，只要Eve知道任一私钥（sb或sa），它就能容易算出DHkey，而这时候问题就变成了：Eve在已知G、p、公钥情况下，是否能求出私钥，这也就是我们上面提到的离散对数问题，这是很难做到的。</p>\n<p><strong>diffie-hellman密钥交换算法解决的问题</strong></p>\n<p>因为DH密钥交换算法利用了“离散对数问题”的复杂度，所以就算Eve一直窃听，Bob和Alice也能协商出一个共享密钥，而Eve却因为复杂的数学问题而没办法算出共享密钥，也就解决了对称密码中的配送问题。</p>\n<h2 id=\"椭圆曲线diffie-hellman密钥交换算法\"><a href=\"#椭圆曲线diffie-hellman密钥交换算法\" class=\"headerlink\" title=\"椭圆曲线diffie-hellman密钥交换算法\"></a>椭圆曲线diffie-hellman密钥交换算法</h2><p>DH是利用了“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就叫椭圆曲线diffie-hellman密钥交换（ECDH）。</p>\n<p>两者密钥交换总体流程相同，只是利用的数学问题不同而已，ECDH能够用较短的密钥长度实现较高的安全性。</p>\n<p><strong>椭圆曲线diffie-hellman密钥交换算法应用</strong></p>\n<p>ECDH中的数学问题可以这样简单定义：</p>\n<div align=\"center\"><img src=\"y=xg.png\" alt></div>\n\n<p>已知椭圆曲线上的点Y、基点G的时候，很难求出x。其中算术符号<code>*</code>表示的不是普通的乘法，而是一种在椭圆曲线上的特殊算法。</p>\n<p>在ECDH中，我们称Y为公钥（public key），x为私钥（private key）。</p>\n<div align=\"center\"><img src=\"ECDH.png\" alt>ECDH应用图<br></div>\n\n<p>如上图所示</p>\n<ol>\n<li>Bob和Alice选择一条密码学家推荐的椭圆曲线，选择曲线上的一个基点G；</li>\n<li>Bob和Alice分别随机生成各自的私钥sb和sa；</li>\n<li>Bob和Alice根据G以及各自的私钥，生成公钥pb和pa；</li>\n<li>Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa；</li>\n<li>Bob和Alice计算出共享密钥DHkey。</li>\n</ol>\n<p><strong>椭圆曲线diffie-hellman密钥交换算法无法解决的问题</strong></p>\n<p>DH和ECDH都能解决密钥配送问题，结合对称密码技术，就能保证消息的机密性，防止被<code>窃听</code>了，但是对于<code>篡改</code>和<code>伪装</code>的攻击，却无能为力。为了解决剩下这两个威胁，就要靠其他技术手段了。</p>\n<div align=\"center\"><img src=\"tamper.png\" alt>篡改示意图<br></div>\n\n<p>如上图所示，Mallory不需要知道密文是什么意思，但是他可以修改密文，导致Alice解密出预期以外的内容。</p>\n<div align=\"center\"><img src=\"camouflage.png\" alt>伪装示意图<br></div>\n\n<p>如上图所示，Mallory夹在Bob和Alice之间并伪装他们。对于Mallory来说，DHkey是赤裸裸的，所以Bob和Alice互发的消息是没有机密性的，这种攻击也称为中间人攻击（MITM）。</p>\n<h2 id=\"消息认证码\"><a href=\"#消息认证码\" class=\"headerlink\" title=\"消息认证码\"></a>消息认证码</h2><p>消息认证码（MAC）技术是检查信息一致性并进行认证的技术，发送者通过MAC算法可以输出一个MIC值，接收者通过校验MIC值不仅可以判断消息一致性，还能判断消息是否来自正确的发送者。</p>\n<div align=\"center\"><img src=\"MAC.png\" alt></div>\n\n<p>MAC技术有以下几种重要性质：</p>\n<ul>\n<li>正向快速：给定明文、MAC算法和密钥key，在有限时间和有限资源内能计算出MIC。</li>\n<li>逆向困难：给定MIC、MAC算法和明文，在有限时间内很难（基本不可能）逆推出密钥。</li>\n<li>输入敏感：原始输入信息修改一点信息，产生的MIC看起来应该都有很大不同。</li>\n<li>冲突避免：很难找到两段内容不同的明文，使得它们的MIC一致（发生冲突）。即对于任意两个不同的数据块，其MIC相同的可能性极小；对于一个给定的数据块，找到和它MIC相同的数据块极为困难。</li>\n</ul>\n<p>MAC技术与对称加密技术有一个显著差异：加密解密是双向的，可以互相推导，而认证只能单向；加密是为了解密，MAC设计是无法解。</p>\n<p><strong>消息认证码解决的问题</strong></p>\n<p>消息经过CMAC算法之后，为何Mallory无法篡改消息和伪装呢？</p>\n<div align=\"center\"><img src=\"authentication.png\" alt>消息一致性检查和认证示意图<br></div>\n\n<ul>\n<li><p>Mallory如果想篡改明文，那就同时也要篡改MIC，否则无法通过Alice的校验，但是应该将MIC改成多少呢？因为Malloyr没有共享密钥，所以他也不知道MIC应该是什么。如果想篡改MIC，那就同时也要篡改明文才能通过Alice的校验，由于MAC算法的逆向困难性质，Mallory不知道明文应该是什么。</p>\n</li>\n<li><p>Bob用CMAC算法认证一条消息并发给Alice，并要求Alice也用CMAC算法认证并返回一条消息给Bob。若Mallory伪装成Alice，由于没有认证密钥，无法返回通过Bob校验的消息。</p>\n</li>\n</ul>\n<p><strong>消息认证码无法解决的问题</strong></p>\n<p>没错，要使用MAC技术，首先要有相同的认证密钥，又回到了之前的密钥配送问题，具体这里采用哪种方式解决配送密钥问题，视实际情况而定。</p>\n<p><strong>消息认证码攻击方式</strong></p>\n<p>对于MAC算法来说，应保证不能根据MIC和明文推测出通信双方所使用的密钥。但实际上用穷举法是可以推测出来的，如果使用密码学安全的、高强度的伪随机数生成器生成密钥，就会使得破解时间需要很长以至在现实中几乎不可能破解。而如果密钥是人为选定的，就会大大增加被推测出来的风险。</p>\n<h2 id=\"认证加密CCM\"><a href=\"#认证加密CCM\" class=\"headerlink\" title=\"认证加密CCM\"></a>认证加密CCM</h2><p>其实上文一直在有意无意的强调一个事情，那就是加密和认证是独立的两个概念。加密能防止<code>窃听</code>，认证能防止<code>篡改</code>和<code>伪装</code>。前辈们用一种密码技术将两者融合起来——CCM（Counter with CBC-MAC）。</p>\n<p>通过查阅资料，以我的战五渣水平只能理解到这一程度：</p>\n<ul>\n<li>发送方先对明文使用MAC技术，然后对称加密成密文；</li>\n<li>接收方先用对称加密技术解密密文，然后用MAC技术校验明文；</li>\n<li>发送方和接收方需要至少一个共享随机数和一个共享密钥，随机数可以公开，密钥不可以公开。</li>\n</ul>\n<div align=\"center\"><img src=\"CCM.png\" alt>个人猜测CCM应用示意图<br></div>\n\n<p>上图只是个人猜测的示意图，有可能是不对的，因为不是术业专攻方向，没有深入研究，秉着求真精神，觉得应该提醒大家，避免误导。</p>\n<p>放上图的目的是：加密和认证可以做在一个算法中，而且BLE就是这么用的。</p>\n<h2 id=\"信息安全小结\"><a href=\"#信息安全小结\" class=\"headerlink\" title=\"信息安全小结\"></a>信息安全小结</h2><div align=\"center\"><img src=\"SecurityTechnology.png\" alt>威胁、安全特性、密码技术关系图<br></div>\n\n<p>总结：</p>\n<ul>\n<li>为了解决<code>窃听</code>问题，采用对称密码技术；</li>\n<li>为了解决对称密码技术的加密密钥配送问题，采用配送密钥技术；</li>\n<li>为了解决<code>篡改</code>问题，采用消息认证码技术；</li>\n<li>为了解决<code>伪装</code>问题，采用消息认证码技术；</li>\n<li>为了解决消息认证码技术的认证密钥配送问题，采用配送密钥技术。</li>\n</ul>\n<blockquote>\n<p>Tips：无论消息认证码技术还是对称密码技术，都需要用到配送密钥技术，而不同的配送密钥技术本身，也会涉及到认证强度的问题。比如希望用ECDH来解决消息认证码的认证密钥配送问题，但是ECDH本身认证强度为零，所以它也需要消息认证码技术来证明ECDH过程中没有出现篡改或者伪装攻击，即又要使用消息认证码技术，导致进入了死循环。所以需要选择合适的密钥配送技术，常见的有：邮箱验证码、手机短信验证码、NFC、目测法等。</p>\n</blockquote>\n<h1 id=\"ble安全机制初探\"><a href=\"#ble安全机制初探\" class=\"headerlink\" title=\"ble安全机制初探\"></a>ble安全机制初探</h1><p>在介绍ble安全机制之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。</p>\n<div align=\"center\">ble重要角色一览表<img src=\"BleImportantPerson.png\" alt><br></div>\n\n<p>背景知识：简单来说ble设备可分为两种角色，一种是主机角色（master），另一种是从机角色（slave），有以下几种差异：</p>\n<ol>\n<li><p>建立连接前</p>\n<ul>\n<li>主机能进入扫描状态、发起连接状态，不能进入广播状态；</li>\n<li>从机能进入广播状态，不能进入扫描状态和发起连接状态；</li>\n<li>一定是由主机发起连接，从机只能被连接。</li>\n</ul>\n</li>\n<li><p>建立连接后</p>\n<ul>\n<li>一定是由主机发起配对，但是从机能够请求主机发起配对；</li>\n</ul>\n</li>\n</ol>\n<div align=\"center\"><img src=\"KindOfPhase.png\" alt>ble各个状态示意图<br></div>\n\n<ul>\n<li>广播状态：设备正在往空中发送广播包，谁都可以收得到；</li>\n<li>扫描状态：设备正在接收空中的广播包，看看谁在发，发什么；</li>\n<li>发起连接状态：设备指定与另外一个设备发起连接；</li>\n<li>明文数传阶段：两个已连接设备之间，用明文传送数据包；</li>\n<li>配对阶段：两个已连接设备之间，运用密码技术生成各种安全强度的密钥；</li>\n<li>加密过程：两个已连接设备之间，使用配对阶段输出的密钥，或者绑定阶段提供的密钥，衍生出最终用于加密底层数据包的密钥；</li>\n<li>密文数传阶段：两个已连接设备之间，用密文传送数据包；</li>\n<li>绑定阶段：用“绑定”这个词特定描述配对阶段中的第三阶段，该阶段交换绑定信息，有了绑定信息下次需要密文数传可以跳过配对阶段。</li>\n</ul>\n<p>除了展示两种角色的异同，我觉得有必要通过上图澄清几个概念，加深大家的理解：</p>\n<ol>\n<li>复杂密码技术是运用在已连接之后的配对阶段，所以不存在配对失败，导致ble无法正常建立连接，至多是配对失败，导致连接断开。</li>\n<li>连接后，不一定要启动配对，如果明文数传已经满足应用要求，就没必要启动配对了。</li>\n</ol>\n<h2 id=\"ble40安全机制\"><a href=\"#ble40安全机制\" class=\"headerlink\" title=\"ble40安全机制\"></a>ble40安全机制</h2><p>从用户角度提出问题：我现在对密码技术有初步了解了，也知道ble安全机制的一些背景知识，评估下来连接之后的明文数传风险太大，我要用到密文数传，ble提供什么样的解决方案呢？</p>\n<div align=\"center\"><img src=\"SmpAndEncryption.png\" alt>ble4.0安全机制简单示意图<br></div>\n\n<p>上图是ble4.0安全机制简单示意图，是上一节“建立连接后”的细节展开，观察方式从上到下为角色的时间轴，从左到右分别是不同的角色，空白地方的文本为传递的数据，虚线为可选项，双斜杠为不展开讨论的内容。</p>\n<p>对于密文数传，ble提供解决方案分四种情况：</p>\n<ol>\n<li><p>首次连接无绑定</p>\n<ul>\n<li>首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。</li>\n</ul>\n</li>\n<li><p>首次连接有绑定</p>\n<ul>\n<li>首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传，进入绑定阶段，从机将长期密钥（LTK）发送给主机保存。</li>\n</ul>\n</li>\n<li><p>第二次连接且首次连接无绑定</p>\n<ul>\n<li>第二次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。</li>\n</ul>\n</li>\n<li><p>第二次连接且首次连接有绑定</p>\n<ul>\n<li>第二次连接，跳过配对阶段，加密过程使用之前绑定的LTK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。</li>\n</ul>\n</li>\n</ol>\n<p>由下往上读图，回答用户提出的问题：</p>\n<p>ble4.0选择CCM给明文数据认证加密，想要使用CCM，就需要一个密钥和一个随机数用于CCM认证加密，所以ble有一个“加密过程”负责输出一个密钥（sessionKey）和一个随机数（IV），而加密过程又需要一个密钥来产生sessionKey，所以ble有一个“配对阶段”来输出一个临时密钥（STK）给加密过程，或者在绑定阶段输出一个长期密钥（LTK）给加密过程下一次连接时候使用。</p>\n<p><strong>TK配对码的生成和配送</strong></p>\n<p>ble4.0的TK配对码生成和配送方式有多种，常用的两种TK配对码的生成和配送方式是：JustWorks和Passkey，他们有以下差异：</p>\n<ol>\n<li><p>JustWorks模式时，生成的TK是000000，因为这是公开的，没有配送的意义，配送目的是为了防止通信双方以外的第三方获得密钥，由于现在认证码是公开的，就没配送的意义了，而且由于认证码泄露，这种模式不能提供篡改和伪装保护。</p>\n</li>\n<li><p>Passkey模式时，TK的生成方式和配送方式如下：通信其中一方如Alice随机生成TK为142536，通过显示屏/短信/NFC等蓝牙以外的输出数据的方式，将配对码告知给Bob’s User，Bob’s User通过键盘往Bob设备输入142536，使得Bob和Alice拥有一个共享认证密钥，而针对蓝牙基带攻击的第三方Mallory不知道，从而提供篡改和伪装保护。</p>\n</li>\n</ol>\n<p>下面来看一下图，Passkey模式是怎么做到认证保护的。</p>\n<div align=\"center\"><img src=\"MITM.png\" alt>认证保护示意图<br></div>\n\n<p>通过正常认证过程，可以发现Bob和Alice只在空中交互了两次，所以Mallory的攻击时机有两个，第一个是Bob和Alice交换MIC的时刻，另一个是在Bob和Alice交换明文的时刻。</p>\n<p>分两种攻击行为</p>\n<ol>\n<li><p>篡改MIC或者明文其中一项，属于篡改攻击。</p>\n<ul>\n<li>如果篡改MIC，那就是在未知明文和TK的情况下，凭空捏造一个EMIC，而且这个EMIC还要能够通过后续校验，这个几乎不可能。MIC是果，明文和TK是因，因果倒置不可能吧。</li>\n<li>如果篡改明文，那就是给定MIC，基于MAC算法且未知认证密钥TK的情况下，推导出另一份明文，根据MAC算法性质，这个是很难做到的。</li>\n</ul>\n</li>\n<li><p>同时篡改MIC和明文，属于伪装攻击，也叫MITM攻击。</p>\n<ul>\n<li>因为伪造认证码EMIC和伪造明文Erand是Mallory提供的，计算过程可能是EMIC = MAC(EK, Erand)，而真实配对码TK和伪造配对码EKEY只有百万分之一的几率是相同的，所以看作是不相同的，也即EK != TK，根据MAC的输入敏感性质，EMIC != MAC(TK, Erand)，最终认证失败。</li>\n</ul>\n</li>\n</ol>\n<p><strong>ble4.0真的足够安全吗？</strong></p>\n<p>我们先列出ble4.0安全机制各个密钥的安全依赖关系：</p>\n<p>CCM -&gt; sessionKey -&gt; STK(LTK) -&gt; TK</p>\n<p>可以看到，最终的源头是TK认证码，只有保证TK足够安全，密文才能保证安全，也就是说不能让非法分子获得TK，否则他们就能够将密文解密了。</p>\n<p>一般我们依靠MAC算法本身的性质，可以保证认证密钥不被推算出来，但是但是这些性质的前提是：认证密钥是使用密码学安全的、高强度的伪随机数生成器生成的，而且这些密钥位数很多，以至于无法穷举。</p>\n<p>而实际TK的取值是000000~999999，最多只有100万种可能性，先抓取配对阶段（phase2.2）中用到的明文、MIC，再通过穷举的方式，就可以推算出TK了。</p>\n<p>我们分析一下，如果在整个安全机制过程中，一直存在窃听者Eve，那么我们会面临什么威胁。</p>\n<blockquote>\n<p>Tips：在这里也顺带分析静态配对码和动态配对码的区别，静态配对码是指每次输入都是固定的TK值，动态配对码是指每次输入都是动态产生的TK值，其实核心规范里面没有提过静态配对码，但是很多人会希望有如下功能：在一个设备预设一个配对码为123456，然后配对阶段时另一个设备输入配对码123456则通过认证，否则不通过，其实对于ble来说，由于TK可以被破解，所以静态配对码没有起到安全保护作用。</p>\n</blockquote>\n<ul>\n<li><p>如果是静态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。</p>\n<ol>\n<li>Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改；</li>\n<li>Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改；</li>\n<li>伪装Bob或者Alice与对方首次连接，因为TK是静态配对码，通过认证，伪装成功。</li>\n</ol>\n</li>\n<li><p>如果是动态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。</p>\n<ol>\n<li>Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改；</li>\n<li>Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改；</li>\n<li>伪装Bob或者Alice与对方首次连接，因为TK是动态配对码，之前破解的TK用不上，无法通过认证，伪装失败。</li>\n</ol>\n</li>\n</ul>\n<p>总结出几个观点：</p>\n<ol>\n<li><p>因为“加密”都依赖于认证码TK，而TK容易被穷举破解，加密则形同虚设。</p>\n</li>\n<li><p>上面描述的威胁，首先是窃听成功，才能篡改成功，问题是出在了窃听上。正常情况下对于密文的处理，CCM需要先解密，后认证。如果Eve没有窃听成功，乱篡改Bob发出的CCM认证加密过的密文，那么Alice解密出来的数据几乎不可能通过后续认证的。正是因为Eve窃听成功，知道篡改哪部分内容，所以才会造成威胁。解决窃听问题，就能同时解决篡改问题了。</p>\n</li>\n<li><p>TK是不安全的，以至于如果使用静态配对码而不是动态配对码，就无法解决伪装问题，如果认证码不像TK那样范围窄，静态配对码技术本身也没什么问题，但是最好还是定期更新。</p>\n</li>\n</ol>\n<p>上面总结的也是ble4.2安全机制里面做的一部分改善，比如增加破解TK的难度，引入ECDH解决窃听问题。</p>\n<h2 id=\"ble42安全机制\"><a href=\"#ble42安全机制\" class=\"headerlink\" title=\"ble42安全机制\"></a>ble42安全机制</h2><p>上一节，我们分析了ble4.0的安全“漏洞”， 接下来简单说一下ble4.2作出的应对措施。</p>\n<ul>\n<li><p>无法改变的前提：</p>\n<ol>\n<li>配对码是6个字节。</li>\n</ol>\n</li>\n<li><p>可能的攻击方式：</p>\n<ol>\n<li>Eve窃听整个过程，从而破解TK，下一次可以伪装Bob和Alice主动发起连接认证。</li>\n<li>Eve窃听整个过程，从而破解TK，从而得到STK，然后窃取LTK。</li>\n<li>Mallory发起MITM攻击，即使攻击失败，包含整个TK信息的MAC和MIC会被Mallory获得。（虽然我不知道有什么用）</li>\n</ol>\n</li>\n<li><p>提出对应解决的方案：</p>\n<ol>\n<li>动态认证码；</li>\n<li>ECDH保证机密性；</li>\n<li>将TK拆成20bit，每次认证一个bit，攻击失败只会暴露1个bit，不会暴露整个TK。</li>\n</ol>\n</li>\n</ul>\n<p>BLE4.2与BLE4.0的安全机制区别主要体现在“配对阶段”的phase2，在这个阶段引入了ECDH，下面展开passkey模式的phase2（包括phase2.1~2.3）。</p>\n<div align=\"center\"><img src=\"ECDHMITM.png\" alt>BLE4.2 phase2示意图<br></div>\n\n<p>在“Authentication Stage1”过程，可以发现Bob和Alice只在空中交互了三次，所以Mallory的攻击时机有三个：</p>\n<ol>\n<li>交换公钥的时刻</li>\n<li>交换MIC的时刻</li>\n<li>交换明文的时刻。</li>\n</ol>\n<p>后两个攻击方式，在BLE4.0已经分析过了，至于第一个攻击时机，因为公钥是也是MAC算法里面的一个参数，所以它也不能被随意篡改，如果改了后面的Ea和Eb校验就不通过了，即给ECDH也提供了MITM保护。</p>\n<blockquote>\n<p>Tips：这里之所以可以提供MITM保护的实质是人的参与，通过观察的方法获得配对码，绕开了蓝牙空中传输来获得配对码，从而不会受到第三者攻击。</p>\n</blockquote>\n<p>对比BLE4.2和BLE4.0的主要区别：</p>\n<ul>\n<li><p>BLE4.2没有STK，在配对过程直接生成LTK，因为LTK在配对阶段就已经强制生成了，加密过程直接使用LTK，BLE4.2的绑定阶段(phase3)不会发送LTK。</p>\n</li>\n<li><p>LTK是DHkey衍生出来的，DHkey是第三方无法窃听也无法破解出来的，所以可以保证后面用CCM加密后数据的机密性。</p>\n</li>\n</ul>\n<p>BLE4.2完美解决了BLE4.0的安全漏洞。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>文章提到的只是BLE常见的一些概念，其他如：签名（Signed）、授权（Authorization）之类都没有提及，有兴趣的读者可以去核心规范探索一番。</p>\n<p>参考资料里面有许多优秀的书籍和文章，比如密码技术相关知识我是从《图解密码技术》获知的，关于具体的实战抓包分析，吹爆“BLE配对过程详解”这篇文章。</p>\n<p>最后最后，感谢您阅读到最后，这是对我最大的鼓励，也希望这篇博文能让您有一点点的收获。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>一开始是想将MESH加进来的，但是考虑到还没上过正式的项目去体验过，怕写出来理解的不够透彻，所以还是算了，以后有机会再单独开一篇吧，但是有兴趣的朋友可以私底下一起交流。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>《图解密码技术》</li>\n<li><a href=\"http://bbs.21ic.com/blog-1827100-160300.html\" target=\"_blank\" rel=\"noopener\">BLE配对过程详解</a></li>\n<li><a href=\"https://www.bluetooth.com/specifications/bluetooth-core-specification/\" target=\"_blank\" rel=\"noopener\">BLE核心规范</a></li>\n<li><a href=\"https://blog.csdn.net/asdzheng/article/details/70226007\" target=\"_blank\" rel=\"noopener\">Hash算法总结</a></li>\n<li><a href=\"https://www.cnblogs.com/xumaojun/p/8541638.html\" target=\"_blank\" rel=\"noopener\">穷举法破解BLE的TK值</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>网上介绍BLE安全机制的文章大多只关注业务概念，如：配对加密是什么，绑定过程是什么；而忽略了其中涉及到的信息安全知识，如：使用了加密和认证有什么用，不用又会怎么样。让新人读了有种云里雾里，知其然而不知其所以然的感觉。这里结合涉及到的信息安全知识，换一个角度来认识BLE安全机制。<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>标题中的“放弃”有点调侃的意思，是指读者在读完之后，可以不依赖别人，靠自己读蓝牙核心规范加深认识，这样收获也会更多，也是这篇博文的目标。</p>\n<p>为了易于理解，会对蓝牙核心规范的算法进行裁剪，但是原理是不变的，标准算法应参考蓝牙核心规范。</p>\n<p>最后，这是博主的一得之见，欢迎各位指正。</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#密码技术初探\">密码技术初探</a><ul>\n<li><a href=\"#对称密码\">对称密码</a></li>\n<li><a href=\"#diffie-hellman密钥交换算法\">diffie-hellman密钥交换算法</a></li>\n<li><a href=\"#椭圆曲线diffie-hellman密钥交换算法\">椭圆曲线diffie-hellman密钥交换算法</a></li>\n<li><a href=\"#消息认证码\">消息认证码</a></li>\n<li><a href=\"#认证加密ccm\">认证加密CCM</a></li>\n<li><a href=\"#信息安全小结\">信息安全小结</a></li>\n</ul>\n</li>\n<li><a href=\"#ble安全机制初探\">ble安全机制初探</a><ul>\n<li><a href=\"#ble40安全机制\">ble40安全机制</a></li>\n<li><a href=\"#ble42安全机制\">ble42安全机制</a></li>\n</ul>\n</li>\n<li><a href=\"#总结\">总结</a></li>\n<li><a href=\"#参考资料\">参考资料</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"密码技术初探\"><a href=\"#密码技术初探\" class=\"headerlink\" title=\"密码技术初探\"></a>密码技术初探</h1><p>在介绍密码技术之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。</p>\n<div align=\"center\">重要角色一览表<img src=\"ImportantPerson.png\" alt><br></div>\n\n<p>Alice和Bob分别是两家银行，Bob银行通过网络向Alice银行发送了一条500元的汇款请求：<strong>从账户B-6789向账户A-1234汇款500元</strong>。</p>\n<p>当然，会有人在网络中尝试攻击银行间通信，妄想用非法手段牟利，其中就有这样一个分工明确的组织，由以下成员组成：</p>\n<ul>\n<li>Eve<ul>\n<li>窃听不同银行之间的消息，从中获取重要信息，如获知“从账户B-6789向账户A-1234汇款500元”。</li>\n</ul>\n</li>\n<li>Mallory：<ul>\n<li>篡改不同银行之间的消息，如修改汇款请求为“从账户B-6789向账户A-1234汇款5000000元”。</li>\n<li>伪装成Bob银行，以Bob银行名义发送一条新的汇款请求给Alice银行。</li>\n</ul>\n</li>\n</ul>\n<p>从上述例子可知消息面临的威胁有：<code>窃听</code>、<code>篡改</code>和<code>伪装</code>，对应的安全特性为：<code>机密性</code>、<code>一致性</code>、<code>是否已认证</code>。</p>\n<p>“威胁”和“安全特性”的关系可以这样描述：</p>\n<ul>\n<li>如果消息没有加密，消息则不具有机密性，无法防止他人窃听；</li>\n<li>如果发送者发送的消息和接收者的消息是不同的，说明消息被篡改过，不具有一致性；</li>\n<li>如果没有对消息进行认证，无法保证消息来自正确发送者而不是伪装者。</li>\n</ul>\n<p>存在威胁，就会有对应的解决方法，下面会针对每个威胁介绍对应的密码技术。</p>\n<h2 id=\"对称密码\"><a href=\"#对称密码\" class=\"headerlink\" title=\"对称密码\"></a>对称密码</h2><p>算法一般指复杂步骤，加密算法指的是用明文生成密文的步骤，解密的步骤称为解密算法，两者统称为密码算法，密码算法需要用到密钥。</p>\n<p>所谓对称密码（symmetric cryptography）技术，即加密和解密时用的是同一个密钥，加密和解密的算法一般是公开的，如AES128。</p>\n<div align=\"center\"><img src=\"SymmetricCryptography.png\" alt>对称密码应用图<br></div>\n\n<p><strong>对称密码解决的问题</strong></p>\n<p>如上图所示</p>\n<ol>\n<li>Bob创建一条汇款请求消息；</li>\n<li>用密钥key对它加密；</li>\n<li>将加密后的消息发给Alice；</li>\n<li>Alice收到密文；</li>\n<li>Eve窃听到了加密后的消息，由于没有密钥key，无法解读内容；</li>\n<li>Alice用密钥key对消息解密；</li>\n<li>Alice获得一条汇款请求消息。</li>\n</ol>\n<p>对称密码技术可以解决<code>窃听</code>的威胁。</p>\n<p><strong>对称密码无法解决的问题</strong></p>\n<p>对称密码技术可以解决<code>窃听</code>的威胁，但是有一个前提，就是在这之前发送者和接收者要有相同的密钥key，所以一定要先给接收者配送密钥，有以下几种方式：</p>\n<ol>\n<li>Bob通过网络先将key发送给Alice，但容易被Eve截取到；</li>\n<li>Bob乘坐交通工具将密钥key亲手交给Alice，或者其他网络以外的方式配送密钥，这种方式成本高维护麻烦，称为带外（Out-Of-Band）配送；</li>\n<li>用diffie-hellman密钥交换算法解决；</li>\n<li>用椭圆曲线diffie-hellman密钥交换算法解决。</li>\n</ol>\n<h2 id=\"diffie-hellman密钥交换算法\"><a href=\"#diffie-hellman密钥交换算法\" class=\"headerlink\" title=\"diffie-hellman密钥交换算法\"></a>diffie-hellman密钥交换算法</h2><p>先不管DH密钥交换算法是什么，我们现在关注问题是：在Eve窃听网络的情况下，如何解决Bob配送key给Alice的问题？</p>\n<p>密码界的前辈们从数学角度上找到了答案：利用这个数学难题，Bob和Alice可以在Eve窃听的情况下，协商出一个密钥，而Eve不知道密钥是什么。</p>\n<p>最好解决配送问题的办法就是不配送，通过协商获得相同的密钥，是不是很神奇，话不多说，我们看看是怎么实现的。</p>\n<p><strong>离散对数问题</strong></p>\n<p>背景知识：mod符号表达的意思是求余数，如表达式5 mod 7的计算思路为：5除以7等于0，余数为5，所以5 mod 7 = 5。</p>\n<p>现有离散对数问题如下，请问满足公式的x是多少：</p>\n<div align=\"center\"><img src=\"7^xmod13=8.png\" alt></div>\n\n\n<p>为了求x，我们可以运用上面提到的背景知识来做计算，像下面这样依次尝试一遍，就可以得到x = 9。</p>\n<div align=\"center\"><img src=\"7^xmod13=y.png\" alt></div>\n\n<p>例子的数字较小，所以很快就找到答案了，当数字很大时，计算x就会变得非常耗时，快速求出离散对数的算法到现在还没被发现，所以可以得到这样的一个简单结论：</p>\n<div align=\"center\"><img src=\"g^xmodp=y.png\" alt></div>\n\n<p>对于上图公式，已知G、p、Y的时候，很难求出x。</p>\n<p>接下来我们看看如何具体利用这个数学问题来协商出密钥的。</p>\n<p><strong>diffie-hellman密钥交换算法应用</strong></p>\n<p>在DH中，我们将Y称为公钥（public key），将x称为私钥（private key），则有以下结论：已知G、p、公钥的时候，很难求出私钥。</p>\n<div align=\"center\"><img src=\"DH.png\" alt>DH应用图<br></div>\n\n<p>如上图所示</p>\n<ol>\n<li>Bob和Alice选择一个公开的G和p，Eve当然也知道这个公开的G和p；</li>\n<li>Bob和Alice分别随机生成各自的私钥sb和sa；</li>\n<li>Bob和Alice根据G、p以及各自的私钥，生成公钥pb和pa；</li>\n<li>Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa；</li>\n<li>Bob和Alice计算出共享密钥DHkey。</li>\n</ol>\n<p>Eve能计算出DHkey吗？</p>\n<p>对比三个角色最后的“已知信息”可知，只要Eve知道任一私钥（sb或sa），它就能容易算出DHkey，而这时候问题就变成了：Eve在已知G、p、公钥情况下，是否能求出私钥，这也就是我们上面提到的离散对数问题，这是很难做到的。</p>\n<p><strong>diffie-hellman密钥交换算法解决的问题</strong></p>\n<p>因为DH密钥交换算法利用了“离散对数问题”的复杂度，所以就算Eve一直窃听，Bob和Alice也能协商出一个共享密钥，而Eve却因为复杂的数学问题而没办法算出共享密钥，也就解决了对称密码中的配送问题。</p>\n<h2 id=\"椭圆曲线diffie-hellman密钥交换算法\"><a href=\"#椭圆曲线diffie-hellman密钥交换算法\" class=\"headerlink\" title=\"椭圆曲线diffie-hellman密钥交换算法\"></a>椭圆曲线diffie-hellman密钥交换算法</h2><p>DH是利用了“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就叫椭圆曲线diffie-hellman密钥交换（ECDH）。</p>\n<p>两者密钥交换总体流程相同，只是利用的数学问题不同而已，ECDH能够用较短的密钥长度实现较高的安全性。</p>\n<p><strong>椭圆曲线diffie-hellman密钥交换算法应用</strong></p>\n<p>ECDH中的数学问题可以这样简单定义：</p>\n<div align=\"center\"><img src=\"y=xg.png\" alt></div>\n\n<p>已知椭圆曲线上的点Y、基点G的时候，很难求出x。其中算术符号<code>*</code>表示的不是普通的乘法，而是一种在椭圆曲线上的特殊算法。</p>\n<p>在ECDH中，我们称Y为公钥（public key），x为私钥（private key）。</p>\n<div align=\"center\"><img src=\"ECDH.png\" alt>ECDH应用图<br></div>\n\n<p>如上图所示</p>\n<ol>\n<li>Bob和Alice选择一条密码学家推荐的椭圆曲线，选择曲线上的一个基点G；</li>\n<li>Bob和Alice分别随机生成各自的私钥sb和sa；</li>\n<li>Bob和Alice根据G以及各自的私钥，生成公钥pb和pa；</li>\n<li>Bob和Alice互发公钥pb和pa，Eve窃听到了pb和pa；</li>\n<li>Bob和Alice计算出共享密钥DHkey。</li>\n</ol>\n<p><strong>椭圆曲线diffie-hellman密钥交换算法无法解决的问题</strong></p>\n<p>DH和ECDH都能解决密钥配送问题，结合对称密码技术，就能保证消息的机密性，防止被<code>窃听</code>了，但是对于<code>篡改</code>和<code>伪装</code>的攻击，却无能为力。为了解决剩下这两个威胁，就要靠其他技术手段了。</p>\n<div align=\"center\"><img src=\"tamper.png\" alt>篡改示意图<br></div>\n\n<p>如上图所示，Mallory不需要知道密文是什么意思，但是他可以修改密文，导致Alice解密出预期以外的内容。</p>\n<div align=\"center\"><img src=\"camouflage.png\" alt>伪装示意图<br></div>\n\n<p>如上图所示，Mallory夹在Bob和Alice之间并伪装他们。对于Mallory来说，DHkey是赤裸裸的，所以Bob和Alice互发的消息是没有机密性的，这种攻击也称为中间人攻击（MITM）。</p>\n<h2 id=\"消息认证码\"><a href=\"#消息认证码\" class=\"headerlink\" title=\"消息认证码\"></a>消息认证码</h2><p>消息认证码（MAC）技术是检查信息一致性并进行认证的技术，发送者通过MAC算法可以输出一个MIC值，接收者通过校验MIC值不仅可以判断消息一致性，还能判断消息是否来自正确的发送者。</p>\n<div align=\"center\"><img src=\"MAC.png\" alt></div>\n\n<p>MAC技术有以下几种重要性质：</p>\n<ul>\n<li>正向快速：给定明文、MAC算法和密钥key，在有限时间和有限资源内能计算出MIC。</li>\n<li>逆向困难：给定MIC、MAC算法和明文，在有限时间内很难（基本不可能）逆推出密钥。</li>\n<li>输入敏感：原始输入信息修改一点信息，产生的MIC看起来应该都有很大不同。</li>\n<li>冲突避免：很难找到两段内容不同的明文，使得它们的MIC一致（发生冲突）。即对于任意两个不同的数据块，其MIC相同的可能性极小；对于一个给定的数据块，找到和它MIC相同的数据块极为困难。</li>\n</ul>\n<p>MAC技术与对称加密技术有一个显著差异：加密解密是双向的，可以互相推导，而认证只能单向；加密是为了解密，MAC设计是无法解。</p>\n<p><strong>消息认证码解决的问题</strong></p>\n<p>消息经过CMAC算法之后，为何Mallory无法篡改消息和伪装呢？</p>\n<div align=\"center\"><img src=\"authentication.png\" alt>消息一致性检查和认证示意图<br></div>\n\n<ul>\n<li><p>Mallory如果想篡改明文，那就同时也要篡改MIC，否则无法通过Alice的校验，但是应该将MIC改成多少呢？因为Malloyr没有共享密钥，所以他也不知道MIC应该是什么。如果想篡改MIC，那就同时也要篡改明文才能通过Alice的校验，由于MAC算法的逆向困难性质，Mallory不知道明文应该是什么。</p>\n</li>\n<li><p>Bob用CMAC算法认证一条消息并发给Alice，并要求Alice也用CMAC算法认证并返回一条消息给Bob。若Mallory伪装成Alice，由于没有认证密钥，无法返回通过Bob校验的消息。</p>\n</li>\n</ul>\n<p><strong>消息认证码无法解决的问题</strong></p>\n<p>没错，要使用MAC技术，首先要有相同的认证密钥，又回到了之前的密钥配送问题，具体这里采用哪种方式解决配送密钥问题，视实际情况而定。</p>\n<p><strong>消息认证码攻击方式</strong></p>\n<p>对于MAC算法来说，应保证不能根据MIC和明文推测出通信双方所使用的密钥。但实际上用穷举法是可以推测出来的，如果使用密码学安全的、高强度的伪随机数生成器生成密钥，就会使得破解时间需要很长以至在现实中几乎不可能破解。而如果密钥是人为选定的，就会大大增加被推测出来的风险。</p>\n<h2 id=\"认证加密CCM\"><a href=\"#认证加密CCM\" class=\"headerlink\" title=\"认证加密CCM\"></a>认证加密CCM</h2><p>其实上文一直在有意无意的强调一个事情，那就是加密和认证是独立的两个概念。加密能防止<code>窃听</code>，认证能防止<code>篡改</code>和<code>伪装</code>。前辈们用一种密码技术将两者融合起来——CCM（Counter with CBC-MAC）。</p>\n<p>通过查阅资料，以我的战五渣水平只能理解到这一程度：</p>\n<ul>\n<li>发送方先对明文使用MAC技术，然后对称加密成密文；</li>\n<li>接收方先用对称加密技术解密密文，然后用MAC技术校验明文；</li>\n<li>发送方和接收方需要至少一个共享随机数和一个共享密钥，随机数可以公开，密钥不可以公开。</li>\n</ul>\n<div align=\"center\"><img src=\"CCM.png\" alt>个人猜测CCM应用示意图<br></div>\n\n<p>上图只是个人猜测的示意图，有可能是不对的，因为不是术业专攻方向，没有深入研究，秉着求真精神，觉得应该提醒大家，避免误导。</p>\n<p>放上图的目的是：加密和认证可以做在一个算法中，而且BLE就是这么用的。</p>\n<h2 id=\"信息安全小结\"><a href=\"#信息安全小结\" class=\"headerlink\" title=\"信息安全小结\"></a>信息安全小结</h2><div align=\"center\"><img src=\"SecurityTechnology.png\" alt>威胁、安全特性、密码技术关系图<br></div>\n\n<p>总结：</p>\n<ul>\n<li>为了解决<code>窃听</code>问题，采用对称密码技术；</li>\n<li>为了解决对称密码技术的加密密钥配送问题，采用配送密钥技术；</li>\n<li>为了解决<code>篡改</code>问题，采用消息认证码技术；</li>\n<li>为了解决<code>伪装</code>问题，采用消息认证码技术；</li>\n<li>为了解决消息认证码技术的认证密钥配送问题，采用配送密钥技术。</li>\n</ul>\n<blockquote>\n<p>Tips：无论消息认证码技术还是对称密码技术，都需要用到配送密钥技术，而不同的配送密钥技术本身，也会涉及到认证强度的问题。比如希望用ECDH来解决消息认证码的认证密钥配送问题，但是ECDH本身认证强度为零，所以它也需要消息认证码技术来证明ECDH过程中没有出现篡改或者伪装攻击，即又要使用消息认证码技术，导致进入了死循环。所以需要选择合适的密钥配送技术，常见的有：邮箱验证码、手机短信验证码、NFC、目测法等。</p>\n</blockquote>\n<h1 id=\"ble安全机制初探\"><a href=\"#ble安全机制初探\" class=\"headerlink\" title=\"ble安全机制初探\"></a>ble安全机制初探</h1><p>在介绍ble安全机制之前，我们先给参与信息交互的对象赋予名称，方便举例和记忆。</p>\n<div align=\"center\">ble重要角色一览表<img src=\"BleImportantPerson.png\" alt><br></div>\n\n<p>背景知识：简单来说ble设备可分为两种角色，一种是主机角色（master），另一种是从机角色（slave），有以下几种差异：</p>\n<ol>\n<li><p>建立连接前</p>\n<ul>\n<li>主机能进入扫描状态、发起连接状态，不能进入广播状态；</li>\n<li>从机能进入广播状态，不能进入扫描状态和发起连接状态；</li>\n<li>一定是由主机发起连接，从机只能被连接。</li>\n</ul>\n</li>\n<li><p>建立连接后</p>\n<ul>\n<li>一定是由主机发起配对，但是从机能够请求主机发起配对；</li>\n</ul>\n</li>\n</ol>\n<div align=\"center\"><img src=\"KindOfPhase.png\" alt>ble各个状态示意图<br></div>\n\n<ul>\n<li>广播状态：设备正在往空中发送广播包，谁都可以收得到；</li>\n<li>扫描状态：设备正在接收空中的广播包，看看谁在发，发什么；</li>\n<li>发起连接状态：设备指定与另外一个设备发起连接；</li>\n<li>明文数传阶段：两个已连接设备之间，用明文传送数据包；</li>\n<li>配对阶段：两个已连接设备之间，运用密码技术生成各种安全强度的密钥；</li>\n<li>加密过程：两个已连接设备之间，使用配对阶段输出的密钥，或者绑定阶段提供的密钥，衍生出最终用于加密底层数据包的密钥；</li>\n<li>密文数传阶段：两个已连接设备之间，用密文传送数据包；</li>\n<li>绑定阶段：用“绑定”这个词特定描述配对阶段中的第三阶段，该阶段交换绑定信息，有了绑定信息下次需要密文数传可以跳过配对阶段。</li>\n</ul>\n<p>除了展示两种角色的异同，我觉得有必要通过上图澄清几个概念，加深大家的理解：</p>\n<ol>\n<li>复杂密码技术是运用在已连接之后的配对阶段，所以不存在配对失败，导致ble无法正常建立连接，至多是配对失败，导致连接断开。</li>\n<li>连接后，不一定要启动配对，如果明文数传已经满足应用要求，就没必要启动配对了。</li>\n</ol>\n<h2 id=\"ble40安全机制\"><a href=\"#ble40安全机制\" class=\"headerlink\" title=\"ble40安全机制\"></a>ble40安全机制</h2><p>从用户角度提出问题：我现在对密码技术有初步了解了，也知道ble安全机制的一些背景知识，评估下来连接之后的明文数传风险太大，我要用到密文数传，ble提供什么样的解决方案呢？</p>\n<div align=\"center\"><img src=\"SmpAndEncryption.png\" alt>ble4.0安全机制简单示意图<br></div>\n\n<p>上图是ble4.0安全机制简单示意图，是上一节“建立连接后”的细节展开，观察方式从上到下为角色的时间轴，从左到右分别是不同的角色，空白地方的文本为传递的数据，虚线为可选项，双斜杠为不展开讨论的内容。</p>\n<p>对于密文数传，ble提供解决方案分四种情况：</p>\n<ol>\n<li><p>首次连接无绑定</p>\n<ul>\n<li>首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。</li>\n</ul>\n</li>\n<li><p>首次连接有绑定</p>\n<ul>\n<li>首次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传，进入绑定阶段，从机将长期密钥（LTK）发送给主机保存。</li>\n</ul>\n</li>\n<li><p>第二次连接且首次连接无绑定</p>\n<ul>\n<li>第二次连接，配对输出临时密钥（STK），加密过程用STK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。</li>\n</ul>\n</li>\n<li><p>第二次连接且首次连接有绑定</p>\n<ul>\n<li>第二次连接，跳过配对阶段，加密过程使用之前绑定的LTK衍生出会话密钥（sessionKey）和随机数（IV）用于CCM认证加密，后面都是密文数传。</li>\n</ul>\n</li>\n</ol>\n<p>由下往上读图，回答用户提出的问题：</p>\n<p>ble4.0选择CCM给明文数据认证加密，想要使用CCM，就需要一个密钥和一个随机数用于CCM认证加密，所以ble有一个“加密过程”负责输出一个密钥（sessionKey）和一个随机数（IV），而加密过程又需要一个密钥来产生sessionKey，所以ble有一个“配对阶段”来输出一个临时密钥（STK）给加密过程，或者在绑定阶段输出一个长期密钥（LTK）给加密过程下一次连接时候使用。</p>\n<p><strong>TK配对码的生成和配送</strong></p>\n<p>ble4.0的TK配对码生成和配送方式有多种，常用的两种TK配对码的生成和配送方式是：JustWorks和Passkey，他们有以下差异：</p>\n<ol>\n<li><p>JustWorks模式时，生成的TK是000000，因为这是公开的，没有配送的意义，配送目的是为了防止通信双方以外的第三方获得密钥，由于现在认证码是公开的，就没配送的意义了，而且由于认证码泄露，这种模式不能提供篡改和伪装保护。</p>\n</li>\n<li><p>Passkey模式时，TK的生成方式和配送方式如下：通信其中一方如Alice随机生成TK为142536，通过显示屏/短信/NFC等蓝牙以外的输出数据的方式，将配对码告知给Bob’s User，Bob’s User通过键盘往Bob设备输入142536，使得Bob和Alice拥有一个共享认证密钥，而针对蓝牙基带攻击的第三方Mallory不知道，从而提供篡改和伪装保护。</p>\n</li>\n</ol>\n<p>下面来看一下图，Passkey模式是怎么做到认证保护的。</p>\n<div align=\"center\"><img src=\"MITM.png\" alt>认证保护示意图<br></div>\n\n<p>通过正常认证过程，可以发现Bob和Alice只在空中交互了两次，所以Mallory的攻击时机有两个，第一个是Bob和Alice交换MIC的时刻，另一个是在Bob和Alice交换明文的时刻。</p>\n<p>分两种攻击行为</p>\n<ol>\n<li><p>篡改MIC或者明文其中一项，属于篡改攻击。</p>\n<ul>\n<li>如果篡改MIC，那就是在未知明文和TK的情况下，凭空捏造一个EMIC，而且这个EMIC还要能够通过后续校验，这个几乎不可能。MIC是果，明文和TK是因，因果倒置不可能吧。</li>\n<li>如果篡改明文，那就是给定MIC，基于MAC算法且未知认证密钥TK的情况下，推导出另一份明文，根据MAC算法性质，这个是很难做到的。</li>\n</ul>\n</li>\n<li><p>同时篡改MIC和明文，属于伪装攻击，也叫MITM攻击。</p>\n<ul>\n<li>因为伪造认证码EMIC和伪造明文Erand是Mallory提供的，计算过程可能是EMIC = MAC(EK, Erand)，而真实配对码TK和伪造配对码EKEY只有百万分之一的几率是相同的，所以看作是不相同的，也即EK != TK，根据MAC的输入敏感性质，EMIC != MAC(TK, Erand)，最终认证失败。</li>\n</ul>\n</li>\n</ol>\n<p><strong>ble4.0真的足够安全吗？</strong></p>\n<p>我们先列出ble4.0安全机制各个密钥的安全依赖关系：</p>\n<p>CCM -&gt; sessionKey -&gt; STK(LTK) -&gt; TK</p>\n<p>可以看到，最终的源头是TK认证码，只有保证TK足够安全，密文才能保证安全，也就是说不能让非法分子获得TK，否则他们就能够将密文解密了。</p>\n<p>一般我们依靠MAC算法本身的性质，可以保证认证密钥不被推算出来，但是但是这些性质的前提是：认证密钥是使用密码学安全的、高强度的伪随机数生成器生成的，而且这些密钥位数很多，以至于无法穷举。</p>\n<p>而实际TK的取值是000000~999999，最多只有100万种可能性，先抓取配对阶段（phase2.2）中用到的明文、MIC，再通过穷举的方式，就可以推算出TK了。</p>\n<p>我们分析一下，如果在整个安全机制过程中，一直存在窃听者Eve，那么我们会面临什么威胁。</p>\n<blockquote>\n<p>Tips：在这里也顺带分析静态配对码和动态配对码的区别，静态配对码是指每次输入都是固定的TK值，动态配对码是指每次输入都是动态产生的TK值，其实核心规范里面没有提过静态配对码，但是很多人会希望有如下功能：在一个设备预设一个配对码为123456，然后配对阶段时另一个设备输入配对码123456则通过认证，否则不通过，其实对于ble来说，由于TK可以被破解，所以静态配对码没有起到安全保护作用。</p>\n</blockquote>\n<ul>\n<li><p>如果是静态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。</p>\n<ol>\n<li>Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改；</li>\n<li>Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改；</li>\n<li>伪装Bob或者Alice与对方首次连接，因为TK是静态配对码，通过认证，伪装成功。</li>\n</ol>\n</li>\n<li><p>如果是动态配对码，Eve推算出首次连接TK，从而推算出STK，从而推算出sessionKey，从而破解CCM，从而窃取绑定过程中的LTK。</p>\n<ol>\n<li>Bob和Alice首次连接，因TK和STK被破解，所有阶段被破解，可任意窃听和篡改；</li>\n<li>Bob和Alice第二次连接，因LTK被窃取，所有阶段被破解，可任意窃听和篡改；</li>\n<li>伪装Bob或者Alice与对方首次连接，因为TK是动态配对码，之前破解的TK用不上，无法通过认证，伪装失败。</li>\n</ol>\n</li>\n</ul>\n<p>总结出几个观点：</p>\n<ol>\n<li><p>因为“加密”都依赖于认证码TK，而TK容易被穷举破解，加密则形同虚设。</p>\n</li>\n<li><p>上面描述的威胁，首先是窃听成功，才能篡改成功，问题是出在了窃听上。正常情况下对于密文的处理，CCM需要先解密，后认证。如果Eve没有窃听成功，乱篡改Bob发出的CCM认证加密过的密文，那么Alice解密出来的数据几乎不可能通过后续认证的。正是因为Eve窃听成功，知道篡改哪部分内容，所以才会造成威胁。解决窃听问题，就能同时解决篡改问题了。</p>\n</li>\n<li><p>TK是不安全的，以至于如果使用静态配对码而不是动态配对码，就无法解决伪装问题，如果认证码不像TK那样范围窄，静态配对码技术本身也没什么问题，但是最好还是定期更新。</p>\n</li>\n</ol>\n<p>上面总结的也是ble4.2安全机制里面做的一部分改善，比如增加破解TK的难度，引入ECDH解决窃听问题。</p>\n<h2 id=\"ble42安全机制\"><a href=\"#ble42安全机制\" class=\"headerlink\" title=\"ble42安全机制\"></a>ble42安全机制</h2><p>上一节，我们分析了ble4.0的安全“漏洞”， 接下来简单说一下ble4.2作出的应对措施。</p>\n<ul>\n<li><p>无法改变的前提：</p>\n<ol>\n<li>配对码是6个字节。</li>\n</ol>\n</li>\n<li><p>可能的攻击方式：</p>\n<ol>\n<li>Eve窃听整个过程，从而破解TK，下一次可以伪装Bob和Alice主动发起连接认证。</li>\n<li>Eve窃听整个过程，从而破解TK，从而得到STK，然后窃取LTK。</li>\n<li>Mallory发起MITM攻击，即使攻击失败，包含整个TK信息的MAC和MIC会被Mallory获得。（虽然我不知道有什么用）</li>\n</ol>\n</li>\n<li><p>提出对应解决的方案：</p>\n<ol>\n<li>动态认证码；</li>\n<li>ECDH保证机密性；</li>\n<li>将TK拆成20bit，每次认证一个bit，攻击失败只会暴露1个bit，不会暴露整个TK。</li>\n</ol>\n</li>\n</ul>\n<p>BLE4.2与BLE4.0的安全机制区别主要体现在“配对阶段”的phase2，在这个阶段引入了ECDH，下面展开passkey模式的phase2（包括phase2.1~2.3）。</p>\n<div align=\"center\"><img src=\"ECDHMITM.png\" alt>BLE4.2 phase2示意图<br></div>\n\n<p>在“Authentication Stage1”过程，可以发现Bob和Alice只在空中交互了三次，所以Mallory的攻击时机有三个：</p>\n<ol>\n<li>交换公钥的时刻</li>\n<li>交换MIC的时刻</li>\n<li>交换明文的时刻。</li>\n</ol>\n<p>后两个攻击方式，在BLE4.0已经分析过了，至于第一个攻击时机，因为公钥是也是MAC算法里面的一个参数，所以它也不能被随意篡改，如果改了后面的Ea和Eb校验就不通过了，即给ECDH也提供了MITM保护。</p>\n<blockquote>\n<p>Tips：这里之所以可以提供MITM保护的实质是人的参与，通过观察的方法获得配对码，绕开了蓝牙空中传输来获得配对码，从而不会受到第三者攻击。</p>\n</blockquote>\n<p>对比BLE4.2和BLE4.0的主要区别：</p>\n<ul>\n<li><p>BLE4.2没有STK，在配对过程直接生成LTK，因为LTK在配对阶段就已经强制生成了，加密过程直接使用LTK，BLE4.2的绑定阶段(phase3)不会发送LTK。</p>\n</li>\n<li><p>LTK是DHkey衍生出来的，DHkey是第三方无法窃听也无法破解出来的，所以可以保证后面用CCM加密后数据的机密性。</p>\n</li>\n</ul>\n<p>BLE4.2完美解决了BLE4.0的安全漏洞。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>文章提到的只是BLE常见的一些概念，其他如：签名（Signed）、授权（Authorization）之类都没有提及，有兴趣的读者可以去核心规范探索一番。</p>\n<p>参考资料里面有许多优秀的书籍和文章，比如密码技术相关知识我是从《图解密码技术》获知的，关于具体的实战抓包分析，吹爆“BLE配对过程详解”这篇文章。</p>\n<p>最后最后，感谢您阅读到最后，这是对我最大的鼓励，也希望这篇博文能让您有一点点的收获。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>一开始是想将MESH加进来的，但是考虑到还没上过正式的项目去体验过，怕写出来理解的不够透彻，所以还是算了，以后有机会再单独开一篇吧，但是有兴趣的朋友可以私底下一起交流。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>《图解密码技术》</li>\n<li><a href=\"http://bbs.21ic.com/blog-1827100-160300.html\" target=\"_blank\" rel=\"noopener\">BLE配对过程详解</a></li>\n<li><a href=\"https://www.bluetooth.com/specifications/bluetooth-core-specification/\" target=\"_blank\" rel=\"noopener\">BLE核心规范</a></li>\n<li><a href=\"https://blog.csdn.net/asdzheng/article/details/70226007\" target=\"_blank\" rel=\"noopener\">Hash算法总结</a></li>\n<li><a href=\"https://www.cnblogs.com/xumaojun/p/8541638.html\" target=\"_blank\" rel=\"noopener\">穷举法破解BLE的TK值</a></li>\n</ul>"},{"title":"Coder Handbook","date":"2019-08-17T09:45:04.000Z","_content":"\n大佬有云：\n> Talk is cheap. Show me the code.       --Linus Torvalds\n\n官方来说，代码好坏体现一个程序员的职业素养，在笔者看来代码是一个程序员的门面担当，在这个颜值即正义的时代，作为程序员如何码的一手好代码，是门必修课中的必修课。\n<!-- more --> \n\n\n前言\n===\n- 写该文档为目的是：形成一套平时监督自己代码是否合理的规范。\n- 本文大部分的理论经验参考《Clean Code》——Robert C.Martin，如有理解不对，还请斧正。\n- 最后，会附上笔者对于一些``名词``、``动词对``和``形容词``的理解。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 命名](#1-命名)\n    - [1.1. 代码简洁不代表模糊](#11-代码简洁不代表模糊)\n    - [1.2. 有意义的变量名](#12-有意义的变量名)\n    - [1.3. 避免使用编码或者前缀](#13-避免使用编码或者前缀)\n    - [1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词](#14-类名应该是清晰的名词或者名词短语尽量不要用单一抽象名词)\n- [2. 函数](#2-函数)\n    - [2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。](#21-只在函数名的同一抽象层做一件事情且函数应该自顶向下不窜层)\n    - [2.2. 使用描述性名称](#22-使用描述性名称)\n    - [2.3. 命名方式要保持一致](#23-命名方式要保持一致)\n    - [2.4. 函数参数](#24-函数参数)\n    - [2.5. 动词与关键词](#25-动词与关键词)\n    - [2.6. 输出参数](#26-输出参数)\n    - [2.7. 分隔指令与询问](#27-分隔指令与询问)\n    - [2.8. 结构化编程](#28-结构化编程)\n    - [2.9. 如何写出心目中的函数](#29-如何写出心目中的函数)\n- [3. 注释](#3-注释)\n    - [3.1. 好注释](#31-好注释)\n- [4. 对象和数据结构](#4-对象和数据结构)\n    - [4.1. 数据抽象](#41-数据抽象)\n    - [4.2. 数据结构、对象的反对称性](#42-数据结构对象的反对称性)\n    - [4.3. LoD](#43-lod)\n- [5. 异常处理](#5-异常处理)\n    - [5.1. 别传递null值](#51-别传递null值)\n- [6. 附录](#6-附录)\n    - [6.1. 名词](#61-名词)\n    - [6.2. 动词](#62-动词)\n    - [6.3. 形容词](#63-形容词)\n\n<!-- /TOC -->\n\n# 1. 命名\n## 1.1. 代码简洁不代表模糊\n\n```C\n/*\n * 不推荐\n */\nuint8_t array[10];\n\n/*\n * 推荐\n */\nuint8_t students_id[10];\n```\n\n## 1.2. 有意义的变量名\n不要写a1，a2，a3，a，b，这样的变量名，除非在特定应用场景。\n## 1.3. 避免使用编码或者前缀\n以前变量名带编码是因为编译器不会帮忙检查类型，要人工检查，现在编译器会帮忙检查类型，没必要增加冗余的东西。\n\n```C\n/*\n * 不推荐\n */\nuint32_t  u32_student_id;\nuint8_t   u8_student_weight;\nuint8_t  *g_student_weight;\nuint8_t  *g_student_height;\n\n/*\n * 推荐\n */\nuint32_t student_id;\nuint8_t  student_weight;\n```\n\n## 1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词\n我觉得在嵌入式行业会经常使用manager，controller等词，而每个人都会对它们有不同的定义，在不同场景它们也确实有不同的意义，所以就是会产生歧义和模糊性，除非对于这些名词有比较好的区分说明和规范，否则不太推荐使用，推荐使用大家能不产生歧义的名词。\n\n```C\n/*\n * 不推荐\n */\nstruct manager {\n    ...\n};\n\nstruct processor {\n    ...\n};\n\nstruct data {\n    ...\n};\n\nstruct info {\n    ...\n};\n\n/*\n * 推荐\n */\nstruct student_info {\n    uint32_t    weight;\n    uint32_t    height;\n    ...\n};\n\nenum customer_hobbies {\n    FOOTBALL,\n    BASKETBALL,\n    ...\n};\n\nuint8_t dev_addr[6];\n```\n\n# 2. 函数\n## 2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。\n\n```C\n/*\n * 一个抽象层（发送数据），做一件事情（发数据），推荐\n */\nvoid send_fifo_data(void *fifo)\n{\n    if (!is_fifo_empty(fifo)) {\n        send(fifo);\n    }\n}\n\n/*\n * 两个抽象层（发送数据、fifo为空），做一件事情（发数据），不推荐\n */\nvoid send_fifo_data(void *fifo)\n{\n    if (!is_fifo_empty(fifo)) {\n        if (first_elem_in_fifo(fifo) == 0xa5) {\n            send(fifo);\n        }\n    }\n}\n\n/*\n * 两个函数，两个抽象层，做了两件事情，函数自顶向下，不窜层，推荐\n */\nvoid send_fifo_data(void *fifo)\n{\n    if (is_fifo_valid(fifo)) {\n        send(fifo);\n    }\n}\n\nuint8_t is_fifo_valid(void *fifo)\n{\n    if (is_fifo_empty(fifo)) {\n        return 0;\n    }    \n\n    if (first_elem_in_fifo(fifo) == 0xa5) {\n        return 1;\n    }\n}\n```\n\n## 2.2. 使用描述性名称\n\n函数内容应该尽可能短，但是函数名称没限制，只要能把事情描述清楚，长一点没问题。\n\n## 2.3. 命名方式要保持一致\n\n```C\n/*\n * 推荐\n */\nuint32_t get_year();\nuint32_t get_month();\nuint32_t get_day();\nuint32_t get_hour();\n\n/*\n * 不推荐\n */\nuint32_t get_year();\nuint32_t month_get();\nuint32_t fetch_day();\nuint32_t read_hour();\n```\n\n## 2.4. 函数参数\n\n个数越少越好，最好没有。\n- 参数多会导致单元测试出现很多分支，覆盖率复杂。\n- 如果参数多于3个，说明需要定义一个结构体了。\n\n## 2.5. 动词与关键词\n\n```C\n/*\n * 一元函数，应该遵循：动词/名词结构比较好。\n */\nvoid write(void *name)\nvoid write_field(void *name)\n\n/*\n * 二元函数，参数包含在函数名内，可以防止我们对于参数输入顺序出错，也是不错的选择\n */\nvoid is_a_larger_b(void *a, void *b);\n```\n\n## 2.6. 输出参数\n尽量避免输出过多参数，可以用``对象参数``或者``返回值``来替代。\n\n```C\n/*\n * len是希望读到buf的个数，p_len是实际读到buf的个数\n */\nvoid read_bytes(void *fifo, void *buf, uint8_t len, void *p_len);\n\n/*\n * len是希望读到buf的个数，返回值是实际读到buf的个数\n */\nuint32_t read_bytes(void *fifo, void *buf, uint8_t len);\n```\n\n## 2.7. 分隔指令与询问\n函数要么做什么事，要么回答什么事，不要两者兼得。\n\n```C\n/*\n * 设置名字属性，如果name已经存在，则返回1，否则返回0。（不推荐）\n */\nuint8_t set_attribute(void *name, void *val)\n{\n    if (name) {\n        return 1;\n    }\n\n    name = val;\n\n    return 0;\n}\n\n/*\n * 分开两个函数比较合理，然后用以下形式实现。（推荐）\n */\nif (!is_attribute_exist(name)) {\n    set_attribute(name, val);\n}\n```\n\n## 2.8. 结构化编程\nEdsger Dijkstra提出结构化编程，即每个函数，只能有一个入口和一个出口。\n- 永远不能出现goto\n- 循环中不能出现break和continue\n- 每个函数只有一个return\n\n这个原则用在复杂的大函数效果显著，在小函数可以适当出现return和break，但是goto还是不要出现。\n\n## 2.9. 如何写出心目中的函数\n\n尝试 + 单元测试 + 提炼，循环上述步骤。\n\n# 3. 注释\n\n## 3.1. 好注释\n\n- 对意图的注释\n\n```C\nvoid uart_receiver_fsm()\n{\n    uint8_t chr;\n\n    if (is_fifo_not_empty(&fifo)) {\n        chr = get_elem(&fifo);\n        /*\n         * 当收到第一个字节时候便打开接收超时定时器，\n         * 用于计算接收超时\n         */\n        timer_start(0);\n    }\n}\n```\n\n- 阐释\n\n```C\n/*\n * 当a==b的时候，compare返回0\n */\nif (comapre(a, b) == 0) {\n    ...\n}\n\n/*\n * 当a > b(asc2)的时候，compare返回1\n */\nif (comapre(a, b) == 1) {\n    ...\n}\n```\n\n# 4. 对象和数据结构\n\n## 4.1. 数据抽象\n\n- 抽象接口不是简单的取值器和赋值器\n\n```C\n/*\n * 不推荐，battery对象的接口只是将能量数值以函数形式暴露，\n * 这里的几个接口函数就是简单取值器，没有太多抽象作用。   \n */\ntypedef struct {\n    uint32_t remained_energy_in_mw;\n    ...\n} battery_t;\nuint32_t get_remained_energy_in_mw(battery_t *self);\n\n/*\n * 推荐，battery对象的接口将能量抽象成百分比形式，\n * 没有暴露具体数值和单位。\n */\ntypedef struct {\n    uint32_t remained_energy_in_mw;\n    ...\n} battery_t;\nuint32_t get_remained_percent_energy(battery_t *self);\n```\n\n要以最好的形式呈现对象的数据，不能随意加取值期和赋值器。\n\n\n## 4.2. 数据结构、对象的反对称性\n- 过程式代码：暴露数据结构细节，便于在不改动数据结构基础上增添函数。\n- 面向对象式代码：隐藏数据结构细节，便于在不改动函数的基础上增添新类。\n\n过程式代码难修改数据结构，因为这样需要修改全部函数。面向对向式代码难修改函数，因为这样需要修改全部类。所以需要根据实际情况权衡什么时候使用哪种代码。\n\n- 混杂对象和数据结构\n\n混杂增加了添加新函数的难度，也增加了添加数据结构的难度，两面都不讨好。\n\n```C\n/*\n * 推荐，过程式代码，数据结构暴露数据，不提供有意义的函数\n * 优势：添加/修改新的函数不会影响数据结构（比如增加计算形状周长函数）\n * 缺陷：修改数据结构影响所有函数（比如增加一个新的形状）\n */\nenum {\n    SQUARE,\n    RECTANGLE,\n    CIRCLE,\n};\n\ntypedef struct {\n    uint8_t type;\n\n    union {\n        ...\n    }\n    ...\n} shape_info_t;\n\nuint32_t get_area(shape_info_t *shape_info)\n{\n    switch (shape_info->type) {\n        case SQUARE:\n            ...\n            break;\n        case RECTANGLE:\n            ...\n            break;\n        case CIRCLE:\n            ...\n            break; \n    }\n}\n\n/*\n * 推荐，面向对象式代码，隐藏数据，暴露操作数据的函数（shape_get_area）\n * 优势：添加/修改新的数据结构很简单（比如增加一个长方形），对原来的函数没有任何影响。\n * 缺陷：如果需要增加一个获取形状周长的函数，那么全部形状都需要修改。\n * NOTE：这里的关系是is a，如果是has a关系，那么结构体变量类型shape_t应该是shape_t *\n */\n\n#define PI 3.1415926\n\ntypedef uint32_t (*pfn_get_area_t)(void);\n\ntypedef struct {\n    pfn_get_area_t get_area;\n} shape_t;\n\ntypedef struct {\n    shape_t shape_ops;\n    uint32_t r;    \n} circle_t;\n\ntypedef struct {\n    shape_t shape_ops;\n    uint32_t side;    \n} square_t;\n\nstatic uint32_t __cicrle_get_area(void)\n{\n    return PI * r * r;\n}\n\nstatic uint32_t __square_get_area(void)\n{\n    return side * side;\n}\n\ncircle_t c1 = {\n    .shape_ops = __cicrle_get_area,\n};\n\nsquare_t s1 = {\n    .shape_ops = __square_get_area,\n};\n\nuint32_t shape_get_area(shape_t *shape)\n{\n    return shape->get_area();\n}\n\nvoid main()\n{\n    shape_get_area((shape_t *)&c1);\n    shape_get_area((shape_t *)&s1);   \n}\n\n/*\n * 不推荐，一半对象，一半数据结构，既拥有函数，又拥有公共变量。\n * 缺陷：添加新函数难，添加新数据结构难。\n * 如果需要添加形状（即公共变量改变），则访问公共变量的函数都要修改\n * 如果需要新增一个获取周长的抽象方法（即增加执行函数），则所有形状对象都要修改\n */\nenum {\n    SQUARE,\n    RECTANGLE,\n    CIRCLE,\n};\n\ntypedef struct {\n    uint8_t type;\n    uint8_t color_var1;\n    uint8_t color_var2;\n} shape_info_t;\n\ntypedef uint32_t (*pfn_get_color_t)(void);\n\ntypedef struct {\n    shape_info_t shape_info;    //公共变量\n    pfn_get_color_t get_color;  //执行函数\n} shape_t;\n\ntypedef struct {\n    shape_t shape;\n    uint32_t r;    \n} circle_t;\n\ntypedef struct {\n    shape_t shape;\n    uint32_t side;    \n} square_t;\n\nstatic uint32_t __circle_get_color(void)\n{\n    return color_val1 * color_val2;\n}\n\nstatic uint32_t __square_get_color(void)\n{\n    return color_val1 + color_val2;\n}\n\nuint8_t shape_get_color(shape_t *shape)\n{\n    return shape->get_color();\n}\n\nuint32_t shape_get_area(shape_t *shape)\n{\n    /*\n     * 访问公共变量 \n     */\n    switch (shape->shape_info.type) {\n        case SQUARE:\n            ...\n            break;\n        case RECTANGLE:\n            ...\n            break;\n        case CIRCLE:\n            ...\n            break; \n    }\n}\n\ncircle_t c1 = {\n    .shape_info.type = CIRCLE,\n    ...\n};\n\nsquare_t s1 = {\n    .shape_info.type = SQUARE,\n    ...\n};\n\nvoid main()\n{\n    shape_get_color((shape_t *)&c1))\n    shape_get_area((shape_t *)&c1))\n}\n```\n\n## 4.3. LoD\n\nLaw of demeter认为，模块不应该了解它所操作对象的内部情形。\n\n- 火车失事（只关乎于编码风格，像火车一样的代码）\n\n```C\n/*\n * 不推荐，像火车一样的代码\n */\noutput_dir = ctxt.get_options().get_scratch_dir().get_abs_path();\n\n/*\n * 推荐（对象）\n */\nops = ctxt.get_options();\nscratch_dir = ops.get_scratch_dir();\nabs_path = scratch_dir.get_abs_path();\n\n/*\n * 如果ctxt、ops等只是单纯数据结构，而不是对象则没有违反LoD\n */\noutput_dir = ctxt.ops.scratch_dir.abs_path\n```\n\n# 5. 异常处理\n## 5.1. 别传递null值\n调用者可能会意外传入null，自己写代码时候应该不写可以传入null的函数，这样只要发现函数列表中有null就是出问题了。\n\n\n\n\n# 6. 附录\n\n概念解释的来源主要有\n- 百度翻译中的牛津词典\n- google翻译\n- stackoverflow高赞答案\n- wikidiff.com\n- 笔者理解\n- 其他地方\n\n## 6.1. 名词\n\n- acknowledge\n    - 解释：确认帧/应答\n    - 缩写：ack\n    - 关联词：nack\n\n- address\n    - 解释：地址\n    - 缩写：addr\n\n- amount\n    - 解释：合计总量，表示量\n    - 关联词：number\n\n- argument\n    - 解释：Argument is the actual value of this variable that gets passed to function.\n    - 缩写：arg\n    - 关联词：parameter\n```C\nvoid foo(void *param);\n\n...\nuint8_t arg1[] = \"this is my argument\";\nfoo(arg1);\n```\n\n- attribute\n    - 解释：强调事物固有的属性，或区别其他事物的特征。比如车是红色，某某品牌\n    - 缩写：attr\n    - 关联词：property\n\n- backup\n    - 解释：备份\n    - 缩写：bk\n    \n- buffer\n    - 解释：短暂数据存储的地方\n    - 缩写：buf\n    - 关联词：fifo\n\n- callback\n    - 解释：邀请返回做某事，带点因果关系的意思。\n    - 缩写：cb\n    - 关联词：handler\n\n- case\n    - 解释：具体情况/事例/特殊情况\n    \n- command\n    - 解释：命令/指令\n    - 缩写：cmd\n    - 关联词：event\n\n- content\n    - 解释：所含之物/内容\n\n- context\n    - 解释：事情发生的背景/上下文环境\n\n- data\n    - 解释：存储在计算机中的资料/原始数据/调查资料/材料\n    - 同义词：information/results/statistics\n\n- device\n    - 解释：用于做某项工作的对象或者仪器\n    - 缩写：dev\n    \n- driver\n    - 解释：software that controls the sending of data between a computer and a piece of equipment that is attached to it, such as a printer\n\n- event\n    - 解释：发生的事情\n    - 缩写：evt\n\n- fail\n    - 解释：失败\n\n- field\n    - 解释：字段/信息组\n\n- fifo\n    - 解释：先进先出算法/先进先出缓冲区\n    - 关联词：lifo\n\n- frame\n    - 解释：帧有格式，包括帧头+数据部分+帧尾\n    - 关联词：pakcet\n\n- header\n    - 解释：帧头\n    - 缩写：hdr\n\n- handle\n    - 解释：事物控制的部分\n    - 缩写：hdl\n\n- handler\n    - 解释：处理某些事物的人\n    - 缩写：hdlr\n\n- identity\n    - 解释：身份/本体\n    - 缩写：id\n\n- information\n    - 解释：事实/某些事物的细节\n    - 缩写：info\n\n- kind\n    - 解释：a group of people or things that are the same in some way; a particular variety or type，如某个种类的音乐。\n    - 关联词：type\n    \n- length\n    - 解释：长度/距离/持续时间的长短\n    - 缩写：len     \n\n- message\n    - 解释：（书面或口头的）信息，消息，音信\n    - 缩写：msg\n\n- nack\n    - 解释：表示报文有错误，要求重发。\n    - 关联词：ack/syn\n\n- master\n    - 解释：具有控制力的角色\n    - 关联词：slave\n\n- number\n    - 解释：一个符号，代表数字/序号/数，表示数\n    - 缩写：num\n    - 关联词：amount\n\n- packet\n    - 解释：a piece of information that forms part of a message sent through a computer network\n    - 缩写：pkt\n    - 关联词：frame/payload\n\n- parameter\n    - 解释：Parameter is variable in the declaration of function\n    - 缩写：param\n\n- payload\n    - 解释：有效载荷，是frame中的一部分\n\n- property\n    - 解释：强调“拥有”的参数，比如车有颜色属性，有尺寸大小属性。\n    - 关联词：attribute\n\n- receiver\n    - 解释：接收者\n    - 缩写：rx\n    \n- report\n    - 解释：新闻/报告\n\n- request\n    - 解释：(正式礼貌的)请求和要求的事\n    - 缩写：req\n\n- response\n    - 解释：(口头或书面的)回复/响应\n    - 缩写：rsp\n\n- result\n    - 解释：后果/结果\n    - 缩写：res\n\n- self\n    - 解释：指向当前类的指针\n    - 关联词：this\n\n- slave\n    - 解释：受控制的角色\n    - 关联词：master\n\n- sender\n    - 解释：邮寄人 \n\n- size\n    - 解释：抽象大小概念/标定大小尺寸\n\n- status\n    - 解释：(进展中的)状况/情形\n\n- string\n    - 解释：字符串，带'\\0'结尾。\n    - 缩写：str\n    - 关联词：bytes\n\n- succeess\n    - 解释：成功\n\n- syn\n    - 解释：在发消息之前，需要先同步。（tcp）\n    - 关联词：ack/nack\n\n- this\n    - 解释：指向当前对象的指针\n    - 关联词：self\n\n- transmitter\n    - 解释：发射机/发射者\n    - 缩写：tx\n    - 关联词：sender/receiver\n\n- type\n    - 解释：a class or group of people or things that share particular qualities or features and are part of a larger group，如不同的人种\n    - 关联词：kind\n\n- value\n    - 解释：由代数项表示的数值、数量\n    - 缩写：val\n    - 关联词：data\n\n- variable\n    - 解释：可变因素\n    - 缩写：var\n\n- version\n    - 解释：版本\n    - 缩写：vers\n \n- manager\n    - 解释：待定\n- processor\n    - 解释：待定\n- controller\n    - 解释：待定\n\n- block\n    - 解释：由sector组成\n- sector\n    - 解释：由page组成\n- page\n    - 解释：SPI FLASH最小写操作单元\n\n- 关于setting/option/preference/property/configuration的理解：\n\n    Someone style:\n\n    - Settings: \"View or modify the list of things that can     be set\"\n    - Options: \"We have set some things already, and give   you the option to enable or disable them\"\n    - Preferences: \"Tell us how you prefer this to work\"\n    - Properties: \"Change one or more properties of this    item\"\n    - Configuration: \"We have defaults, but they're so  barebones you probably want to configure it yourself\"\n\n    Following an approximate lead from Visual Studio and    other Microsoft products:\n\n    - Properties represent the characteristics of a single  component or object in the application.\n    - Options alter global ways that the application works.     Microsoft products use this to customise the UI toolbar,     for example. There's an implication here that you can  disable UI elements altogether (e.g. a \"Simple\" user     interface or an \"Advanced\" user interface).\n    - Settings and Preferences change qualities of how the  application works. The implication here is to change,    not disable: for example, \"Metric measurements\" or     \"British Imperial measurements\".\n    - Configuration is often where an application is    customised for each user or group.\n\n    知乎：\n\n        Configure some options in the settings.\n\n    - 程序所有的可变项叫做Settings。中文译作设置。所有的设置都是    “可选项”，Option（选项，不是期权），因为在程序世界里没有真的    开放式问题只有选择题（Option）。改变可选项的过程叫做    Configure配置（动词）。\n    - 附赠：已确定的Configure结果叫做Configuration配置（名词）  。Configure和Configuration都经常缩写为Config。一套既成的可    迁移的实现特定目的的Configuration叫做Profile，例如手机里的  静音Profile、仅震动Profile、蓝牙各种profile。\n\n\n## 6.2. 动词\n\n- 持久层/数据库操作\n    - create\n        - 创建新的记录\n    - read\n        - 读已存在的记录\n    - update\n        - 更新已存在的记录\n    - delete\n        - 删除已存在的记录\n\n- 整体和个体的访问操作\n    - put\n        - 将对象或者任意数据存进去（对象大小由sizeof决定）\n    - get\n        - 将对象或者任意数据读出来（对象大小由sizeof决定）\n    - write\n        - 将n个字节写进去\n    - read\n        - 将n个字节读出来\n\n- 恢复/复原/重置\n    - recover\n        - 解释：从备份中获取部分文件\n\n    - restore\n        - 解释：从备份中获取整个系统\n\n    - refresh\n        - 解释：重装系统，但是保留应用程序和个人设置文件\n\n    - reset\n        - 解释：重装系统，删除所有东西\n        - 缩写：rst\n\n- 查询/寻找/搜索\n    - inquire\n        - 解释：在某个范围内查询某指定事物（ask sth）\n    - find\n        - 解释：偶然遇到或者发现特定事物\n    - search\n        - 解释：I searched on the internet. I found what I was looking for.（指定性没那么强）\n\n- 过滤/拦截/排列\n    - filter\n        - 解释：pass (a liquid, gas, light, or sound) through a device to remove unwanted material.\n        - 关联词：filter（名词）\n    - intercept\n        - 解释：to stop sb/sth that is going from one place to another from arriving\n        - 关联词：interceptor（名词） \n    - sort\n        - 解释：按顺序排列\n\n\n- 学习/研究/分析\n    - study\n    - learn\n    - research\n        - 解释：不断寻找和检查来研究某事物\n    - analyze\n        - 解释：对当前主题进行分析\n\n- 覆盖\n    - cover\n        - 解释：把某事物放在某事物上面，如隐藏和保护\n    - overlap\n        - 解释：延伸并部分覆盖或者替代掉某物\n\n- 固定搭配\n    - fetch\n        - 解释：获取东西\n        - 关联词：store   \n    - store\n        - 解释：将东西保存起来以备以后使用\n        - 关联词：fetch\n    \n    - start\n        - 解释：较随意的开始/创立\n    - stop\n        - 解释：较随意的结束\n\n    - begin\n        - 解释：从头开始\n    - end\n        - 解释：终点结束\n\n    - enter\n        - 解释：加入/进入/开始从事/开始活动\n    - exit\n        - 解释：退出（计算机程序）\n\n    - open\n        - 解释：参考文件系统使用方法\n    - close\n        - 解释：参考文件系统使用方法\n\n    - input\n        - 解释：第三人称描述某个事物的输入\n        - 关联词：receive（第一人称）\n    - output\n        - 解释：第三人称描述某个事物的输出\n        - 关联词：transmit（第一人称）\n   \n    - upload\n        - 解释：上传到服务器或者别的电脑\n    - download\n        - 解释：从服务器或者别的电脑下载\n        \n    - set\n        - 解释：设置\n    - clear\n        - 解释：清除\n        - 缩写：clr\n\n    - init\n        - 解释：是一个实例的初始化方法\n    - deinit\n        - 解释：释放内存\n\n    - plus\n        - 解释：加法\n    - minus\n        - 解释：减法\n\n    - subscribe\n        - 解释：订阅\n        - 缩写：subs\n    - publish\n        - 解释：发布\n        - 缩写：pub\n\n    - add\n        - 解释：增加某东西\n    - sub\n        - 解释：减去某东西\n\n    - pend\n        - 参考操作系统\n    - post\n        - 参考操作系统\n\n    - error\n        - 解释：err\n        - 缩写：\n    - ok\n        - 解释：\n        - 缩写：\n\n\n\n- append\n    - 解释：在结尾插入内容\n\n\n- calculate\n    - 解释：计算\n    - 缩写：calc\n\n- contain\n    - 解释：包含/含有/容纳\n\n- erase\n    - 解释：flash专用\n\n- indicate\n    - 解释：指示\n    - 关联词：confirm\n\n- initialize\n    - 解释：类的方法，在所有实例方法和类方法执行前运行\n\n- notify\n    - 解释：正式通报，通知\n\n- implement\n    - 解释：实现\n    - 缩写：impl\n\n- remove\n    - 解释：拿走，但内存还在\n    - 关联词：delete（删除释放内存）、recover\n\n- transfer\n    - 解释：移交/转移\n\n- translate\n    - 解释：转变/变为\n\n- overflow\n    - 解释：溢出某个容器\n    \n- peek\n    - 解释：偷看一眼\n\n- process\n    - 解释：对data作一些的操作或处理\n\n\n## 6.3. 形容词\n\n- 固定搭配\n    - valid\n        - 解释：有效的\n    - invalid\n        - 解释：无效的\n\n    - busy\n        - 解释：忙\n    - idle\n        - 解释：空闲\n\n    - used\n        - 解释：已使用\n    - unused\n        - 解释：没用着的/空闲的\n\n\n\n- 描述真实/真的\n    - actual\n        - 解释：形容客观存在的事实或者行为\n    - real\n        - 解释：真实的/实际存在的，对真理的描述\n\n- 描述大小\n    - larger\n        - 解释：强调体积/能力/数量\n    - bigger\n        - 解释：表示由“重”的意思，重要/重量。\n    - smaller\n        - 解释：无关紧要的/小的数量\n    - little\n        - 解释：小的尺寸/只有一点点\n    - tiny\n        - 解释：极小的/微小的/微量的\n\n- different\n    - 解释：不同\n    - 缩写：diff\n\n- equal\n    - 解释：大小、价值、数量相等或相同\n\n- expected\n    - 解释：预料的/预期的\n\n- initial\n    - 解释：初始化的\n\n- remain\n    - 解释：仍然存在/可以使用/还没被处理\n\n- temp\n    - 解释：临时\n    - 缩写：tmp\n","source":"_posts/coder-handbook.md","raw":"---\ntitle: Coder Handbook\ndate: 2019-08-17 17:45:04\ntags:\n- 代码\n- 整洁\n\n\ncategories:\n- 软件工程\n\n---\n\n大佬有云：\n> Talk is cheap. Show me the code.       --Linus Torvalds\n\n官方来说，代码好坏体现一个程序员的职业素养，在笔者看来代码是一个程序员的门面担当，在这个颜值即正义的时代，作为程序员如何码的一手好代码，是门必修课中的必修课。\n<!-- more --> \n\n\n前言\n===\n- 写该文档为目的是：形成一套平时监督自己代码是否合理的规范。\n- 本文大部分的理论经验参考《Clean Code》——Robert C.Martin，如有理解不对，还请斧正。\n- 最后，会附上笔者对于一些``名词``、``动词对``和``形容词``的理解。\n\n目录\n===\n\n<!-- TOC -->\n\n- [1. 命名](#1-命名)\n    - [1.1. 代码简洁不代表模糊](#11-代码简洁不代表模糊)\n    - [1.2. 有意义的变量名](#12-有意义的变量名)\n    - [1.3. 避免使用编码或者前缀](#13-避免使用编码或者前缀)\n    - [1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词](#14-类名应该是清晰的名词或者名词短语尽量不要用单一抽象名词)\n- [2. 函数](#2-函数)\n    - [2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。](#21-只在函数名的同一抽象层做一件事情且函数应该自顶向下不窜层)\n    - [2.2. 使用描述性名称](#22-使用描述性名称)\n    - [2.3. 命名方式要保持一致](#23-命名方式要保持一致)\n    - [2.4. 函数参数](#24-函数参数)\n    - [2.5. 动词与关键词](#25-动词与关键词)\n    - [2.6. 输出参数](#26-输出参数)\n    - [2.7. 分隔指令与询问](#27-分隔指令与询问)\n    - [2.8. 结构化编程](#28-结构化编程)\n    - [2.9. 如何写出心目中的函数](#29-如何写出心目中的函数)\n- [3. 注释](#3-注释)\n    - [3.1. 好注释](#31-好注释)\n- [4. 对象和数据结构](#4-对象和数据结构)\n    - [4.1. 数据抽象](#41-数据抽象)\n    - [4.2. 数据结构、对象的反对称性](#42-数据结构对象的反对称性)\n    - [4.3. LoD](#43-lod)\n- [5. 异常处理](#5-异常处理)\n    - [5.1. 别传递null值](#51-别传递null值)\n- [6. 附录](#6-附录)\n    - [6.1. 名词](#61-名词)\n    - [6.2. 动词](#62-动词)\n    - [6.3. 形容词](#63-形容词)\n\n<!-- /TOC -->\n\n# 1. 命名\n## 1.1. 代码简洁不代表模糊\n\n```C\n/*\n * 不推荐\n */\nuint8_t array[10];\n\n/*\n * 推荐\n */\nuint8_t students_id[10];\n```\n\n## 1.2. 有意义的变量名\n不要写a1，a2，a3，a，b，这样的变量名，除非在特定应用场景。\n## 1.3. 避免使用编码或者前缀\n以前变量名带编码是因为编译器不会帮忙检查类型，要人工检查，现在编译器会帮忙检查类型，没必要增加冗余的东西。\n\n```C\n/*\n * 不推荐\n */\nuint32_t  u32_student_id;\nuint8_t   u8_student_weight;\nuint8_t  *g_student_weight;\nuint8_t  *g_student_height;\n\n/*\n * 推荐\n */\nuint32_t student_id;\nuint8_t  student_weight;\n```\n\n## 1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词\n我觉得在嵌入式行业会经常使用manager，controller等词，而每个人都会对它们有不同的定义，在不同场景它们也确实有不同的意义，所以就是会产生歧义和模糊性，除非对于这些名词有比较好的区分说明和规范，否则不太推荐使用，推荐使用大家能不产生歧义的名词。\n\n```C\n/*\n * 不推荐\n */\nstruct manager {\n    ...\n};\n\nstruct processor {\n    ...\n};\n\nstruct data {\n    ...\n};\n\nstruct info {\n    ...\n};\n\n/*\n * 推荐\n */\nstruct student_info {\n    uint32_t    weight;\n    uint32_t    height;\n    ...\n};\n\nenum customer_hobbies {\n    FOOTBALL,\n    BASKETBALL,\n    ...\n};\n\nuint8_t dev_addr[6];\n```\n\n# 2. 函数\n## 2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。\n\n```C\n/*\n * 一个抽象层（发送数据），做一件事情（发数据），推荐\n */\nvoid send_fifo_data(void *fifo)\n{\n    if (!is_fifo_empty(fifo)) {\n        send(fifo);\n    }\n}\n\n/*\n * 两个抽象层（发送数据、fifo为空），做一件事情（发数据），不推荐\n */\nvoid send_fifo_data(void *fifo)\n{\n    if (!is_fifo_empty(fifo)) {\n        if (first_elem_in_fifo(fifo) == 0xa5) {\n            send(fifo);\n        }\n    }\n}\n\n/*\n * 两个函数，两个抽象层，做了两件事情，函数自顶向下，不窜层，推荐\n */\nvoid send_fifo_data(void *fifo)\n{\n    if (is_fifo_valid(fifo)) {\n        send(fifo);\n    }\n}\n\nuint8_t is_fifo_valid(void *fifo)\n{\n    if (is_fifo_empty(fifo)) {\n        return 0;\n    }    \n\n    if (first_elem_in_fifo(fifo) == 0xa5) {\n        return 1;\n    }\n}\n```\n\n## 2.2. 使用描述性名称\n\n函数内容应该尽可能短，但是函数名称没限制，只要能把事情描述清楚，长一点没问题。\n\n## 2.3. 命名方式要保持一致\n\n```C\n/*\n * 推荐\n */\nuint32_t get_year();\nuint32_t get_month();\nuint32_t get_day();\nuint32_t get_hour();\n\n/*\n * 不推荐\n */\nuint32_t get_year();\nuint32_t month_get();\nuint32_t fetch_day();\nuint32_t read_hour();\n```\n\n## 2.4. 函数参数\n\n个数越少越好，最好没有。\n- 参数多会导致单元测试出现很多分支，覆盖率复杂。\n- 如果参数多于3个，说明需要定义一个结构体了。\n\n## 2.5. 动词与关键词\n\n```C\n/*\n * 一元函数，应该遵循：动词/名词结构比较好。\n */\nvoid write(void *name)\nvoid write_field(void *name)\n\n/*\n * 二元函数，参数包含在函数名内，可以防止我们对于参数输入顺序出错，也是不错的选择\n */\nvoid is_a_larger_b(void *a, void *b);\n```\n\n## 2.6. 输出参数\n尽量避免输出过多参数，可以用``对象参数``或者``返回值``来替代。\n\n```C\n/*\n * len是希望读到buf的个数，p_len是实际读到buf的个数\n */\nvoid read_bytes(void *fifo, void *buf, uint8_t len, void *p_len);\n\n/*\n * len是希望读到buf的个数，返回值是实际读到buf的个数\n */\nuint32_t read_bytes(void *fifo, void *buf, uint8_t len);\n```\n\n## 2.7. 分隔指令与询问\n函数要么做什么事，要么回答什么事，不要两者兼得。\n\n```C\n/*\n * 设置名字属性，如果name已经存在，则返回1，否则返回0。（不推荐）\n */\nuint8_t set_attribute(void *name, void *val)\n{\n    if (name) {\n        return 1;\n    }\n\n    name = val;\n\n    return 0;\n}\n\n/*\n * 分开两个函数比较合理，然后用以下形式实现。（推荐）\n */\nif (!is_attribute_exist(name)) {\n    set_attribute(name, val);\n}\n```\n\n## 2.8. 结构化编程\nEdsger Dijkstra提出结构化编程，即每个函数，只能有一个入口和一个出口。\n- 永远不能出现goto\n- 循环中不能出现break和continue\n- 每个函数只有一个return\n\n这个原则用在复杂的大函数效果显著，在小函数可以适当出现return和break，但是goto还是不要出现。\n\n## 2.9. 如何写出心目中的函数\n\n尝试 + 单元测试 + 提炼，循环上述步骤。\n\n# 3. 注释\n\n## 3.1. 好注释\n\n- 对意图的注释\n\n```C\nvoid uart_receiver_fsm()\n{\n    uint8_t chr;\n\n    if (is_fifo_not_empty(&fifo)) {\n        chr = get_elem(&fifo);\n        /*\n         * 当收到第一个字节时候便打开接收超时定时器，\n         * 用于计算接收超时\n         */\n        timer_start(0);\n    }\n}\n```\n\n- 阐释\n\n```C\n/*\n * 当a==b的时候，compare返回0\n */\nif (comapre(a, b) == 0) {\n    ...\n}\n\n/*\n * 当a > b(asc2)的时候，compare返回1\n */\nif (comapre(a, b) == 1) {\n    ...\n}\n```\n\n# 4. 对象和数据结构\n\n## 4.1. 数据抽象\n\n- 抽象接口不是简单的取值器和赋值器\n\n```C\n/*\n * 不推荐，battery对象的接口只是将能量数值以函数形式暴露，\n * 这里的几个接口函数就是简单取值器，没有太多抽象作用。   \n */\ntypedef struct {\n    uint32_t remained_energy_in_mw;\n    ...\n} battery_t;\nuint32_t get_remained_energy_in_mw(battery_t *self);\n\n/*\n * 推荐，battery对象的接口将能量抽象成百分比形式，\n * 没有暴露具体数值和单位。\n */\ntypedef struct {\n    uint32_t remained_energy_in_mw;\n    ...\n} battery_t;\nuint32_t get_remained_percent_energy(battery_t *self);\n```\n\n要以最好的形式呈现对象的数据，不能随意加取值期和赋值器。\n\n\n## 4.2. 数据结构、对象的反对称性\n- 过程式代码：暴露数据结构细节，便于在不改动数据结构基础上增添函数。\n- 面向对象式代码：隐藏数据结构细节，便于在不改动函数的基础上增添新类。\n\n过程式代码难修改数据结构，因为这样需要修改全部函数。面向对向式代码难修改函数，因为这样需要修改全部类。所以需要根据实际情况权衡什么时候使用哪种代码。\n\n- 混杂对象和数据结构\n\n混杂增加了添加新函数的难度，也增加了添加数据结构的难度，两面都不讨好。\n\n```C\n/*\n * 推荐，过程式代码，数据结构暴露数据，不提供有意义的函数\n * 优势：添加/修改新的函数不会影响数据结构（比如增加计算形状周长函数）\n * 缺陷：修改数据结构影响所有函数（比如增加一个新的形状）\n */\nenum {\n    SQUARE,\n    RECTANGLE,\n    CIRCLE,\n};\n\ntypedef struct {\n    uint8_t type;\n\n    union {\n        ...\n    }\n    ...\n} shape_info_t;\n\nuint32_t get_area(shape_info_t *shape_info)\n{\n    switch (shape_info->type) {\n        case SQUARE:\n            ...\n            break;\n        case RECTANGLE:\n            ...\n            break;\n        case CIRCLE:\n            ...\n            break; \n    }\n}\n\n/*\n * 推荐，面向对象式代码，隐藏数据，暴露操作数据的函数（shape_get_area）\n * 优势：添加/修改新的数据结构很简单（比如增加一个长方形），对原来的函数没有任何影响。\n * 缺陷：如果需要增加一个获取形状周长的函数，那么全部形状都需要修改。\n * NOTE：这里的关系是is a，如果是has a关系，那么结构体变量类型shape_t应该是shape_t *\n */\n\n#define PI 3.1415926\n\ntypedef uint32_t (*pfn_get_area_t)(void);\n\ntypedef struct {\n    pfn_get_area_t get_area;\n} shape_t;\n\ntypedef struct {\n    shape_t shape_ops;\n    uint32_t r;    \n} circle_t;\n\ntypedef struct {\n    shape_t shape_ops;\n    uint32_t side;    \n} square_t;\n\nstatic uint32_t __cicrle_get_area(void)\n{\n    return PI * r * r;\n}\n\nstatic uint32_t __square_get_area(void)\n{\n    return side * side;\n}\n\ncircle_t c1 = {\n    .shape_ops = __cicrle_get_area,\n};\n\nsquare_t s1 = {\n    .shape_ops = __square_get_area,\n};\n\nuint32_t shape_get_area(shape_t *shape)\n{\n    return shape->get_area();\n}\n\nvoid main()\n{\n    shape_get_area((shape_t *)&c1);\n    shape_get_area((shape_t *)&s1);   \n}\n\n/*\n * 不推荐，一半对象，一半数据结构，既拥有函数，又拥有公共变量。\n * 缺陷：添加新函数难，添加新数据结构难。\n * 如果需要添加形状（即公共变量改变），则访问公共变量的函数都要修改\n * 如果需要新增一个获取周长的抽象方法（即增加执行函数），则所有形状对象都要修改\n */\nenum {\n    SQUARE,\n    RECTANGLE,\n    CIRCLE,\n};\n\ntypedef struct {\n    uint8_t type;\n    uint8_t color_var1;\n    uint8_t color_var2;\n} shape_info_t;\n\ntypedef uint32_t (*pfn_get_color_t)(void);\n\ntypedef struct {\n    shape_info_t shape_info;    //公共变量\n    pfn_get_color_t get_color;  //执行函数\n} shape_t;\n\ntypedef struct {\n    shape_t shape;\n    uint32_t r;    \n} circle_t;\n\ntypedef struct {\n    shape_t shape;\n    uint32_t side;    \n} square_t;\n\nstatic uint32_t __circle_get_color(void)\n{\n    return color_val1 * color_val2;\n}\n\nstatic uint32_t __square_get_color(void)\n{\n    return color_val1 + color_val2;\n}\n\nuint8_t shape_get_color(shape_t *shape)\n{\n    return shape->get_color();\n}\n\nuint32_t shape_get_area(shape_t *shape)\n{\n    /*\n     * 访问公共变量 \n     */\n    switch (shape->shape_info.type) {\n        case SQUARE:\n            ...\n            break;\n        case RECTANGLE:\n            ...\n            break;\n        case CIRCLE:\n            ...\n            break; \n    }\n}\n\ncircle_t c1 = {\n    .shape_info.type = CIRCLE,\n    ...\n};\n\nsquare_t s1 = {\n    .shape_info.type = SQUARE,\n    ...\n};\n\nvoid main()\n{\n    shape_get_color((shape_t *)&c1))\n    shape_get_area((shape_t *)&c1))\n}\n```\n\n## 4.3. LoD\n\nLaw of demeter认为，模块不应该了解它所操作对象的内部情形。\n\n- 火车失事（只关乎于编码风格，像火车一样的代码）\n\n```C\n/*\n * 不推荐，像火车一样的代码\n */\noutput_dir = ctxt.get_options().get_scratch_dir().get_abs_path();\n\n/*\n * 推荐（对象）\n */\nops = ctxt.get_options();\nscratch_dir = ops.get_scratch_dir();\nabs_path = scratch_dir.get_abs_path();\n\n/*\n * 如果ctxt、ops等只是单纯数据结构，而不是对象则没有违反LoD\n */\noutput_dir = ctxt.ops.scratch_dir.abs_path\n```\n\n# 5. 异常处理\n## 5.1. 别传递null值\n调用者可能会意外传入null，自己写代码时候应该不写可以传入null的函数，这样只要发现函数列表中有null就是出问题了。\n\n\n\n\n# 6. 附录\n\n概念解释的来源主要有\n- 百度翻译中的牛津词典\n- google翻译\n- stackoverflow高赞答案\n- wikidiff.com\n- 笔者理解\n- 其他地方\n\n## 6.1. 名词\n\n- acknowledge\n    - 解释：确认帧/应答\n    - 缩写：ack\n    - 关联词：nack\n\n- address\n    - 解释：地址\n    - 缩写：addr\n\n- amount\n    - 解释：合计总量，表示量\n    - 关联词：number\n\n- argument\n    - 解释：Argument is the actual value of this variable that gets passed to function.\n    - 缩写：arg\n    - 关联词：parameter\n```C\nvoid foo(void *param);\n\n...\nuint8_t arg1[] = \"this is my argument\";\nfoo(arg1);\n```\n\n- attribute\n    - 解释：强调事物固有的属性，或区别其他事物的特征。比如车是红色，某某品牌\n    - 缩写：attr\n    - 关联词：property\n\n- backup\n    - 解释：备份\n    - 缩写：bk\n    \n- buffer\n    - 解释：短暂数据存储的地方\n    - 缩写：buf\n    - 关联词：fifo\n\n- callback\n    - 解释：邀请返回做某事，带点因果关系的意思。\n    - 缩写：cb\n    - 关联词：handler\n\n- case\n    - 解释：具体情况/事例/特殊情况\n    \n- command\n    - 解释：命令/指令\n    - 缩写：cmd\n    - 关联词：event\n\n- content\n    - 解释：所含之物/内容\n\n- context\n    - 解释：事情发生的背景/上下文环境\n\n- data\n    - 解释：存储在计算机中的资料/原始数据/调查资料/材料\n    - 同义词：information/results/statistics\n\n- device\n    - 解释：用于做某项工作的对象或者仪器\n    - 缩写：dev\n    \n- driver\n    - 解释：software that controls the sending of data between a computer and a piece of equipment that is attached to it, such as a printer\n\n- event\n    - 解释：发生的事情\n    - 缩写：evt\n\n- fail\n    - 解释：失败\n\n- field\n    - 解释：字段/信息组\n\n- fifo\n    - 解释：先进先出算法/先进先出缓冲区\n    - 关联词：lifo\n\n- frame\n    - 解释：帧有格式，包括帧头+数据部分+帧尾\n    - 关联词：pakcet\n\n- header\n    - 解释：帧头\n    - 缩写：hdr\n\n- handle\n    - 解释：事物控制的部分\n    - 缩写：hdl\n\n- handler\n    - 解释：处理某些事物的人\n    - 缩写：hdlr\n\n- identity\n    - 解释：身份/本体\n    - 缩写：id\n\n- information\n    - 解释：事实/某些事物的细节\n    - 缩写：info\n\n- kind\n    - 解释：a group of people or things that are the same in some way; a particular variety or type，如某个种类的音乐。\n    - 关联词：type\n    \n- length\n    - 解释：长度/距离/持续时间的长短\n    - 缩写：len     \n\n- message\n    - 解释：（书面或口头的）信息，消息，音信\n    - 缩写：msg\n\n- nack\n    - 解释：表示报文有错误，要求重发。\n    - 关联词：ack/syn\n\n- master\n    - 解释：具有控制力的角色\n    - 关联词：slave\n\n- number\n    - 解释：一个符号，代表数字/序号/数，表示数\n    - 缩写：num\n    - 关联词：amount\n\n- packet\n    - 解释：a piece of information that forms part of a message sent through a computer network\n    - 缩写：pkt\n    - 关联词：frame/payload\n\n- parameter\n    - 解释：Parameter is variable in the declaration of function\n    - 缩写：param\n\n- payload\n    - 解释：有效载荷，是frame中的一部分\n\n- property\n    - 解释：强调“拥有”的参数，比如车有颜色属性，有尺寸大小属性。\n    - 关联词：attribute\n\n- receiver\n    - 解释：接收者\n    - 缩写：rx\n    \n- report\n    - 解释：新闻/报告\n\n- request\n    - 解释：(正式礼貌的)请求和要求的事\n    - 缩写：req\n\n- response\n    - 解释：(口头或书面的)回复/响应\n    - 缩写：rsp\n\n- result\n    - 解释：后果/结果\n    - 缩写：res\n\n- self\n    - 解释：指向当前类的指针\n    - 关联词：this\n\n- slave\n    - 解释：受控制的角色\n    - 关联词：master\n\n- sender\n    - 解释：邮寄人 \n\n- size\n    - 解释：抽象大小概念/标定大小尺寸\n\n- status\n    - 解释：(进展中的)状况/情形\n\n- string\n    - 解释：字符串，带'\\0'结尾。\n    - 缩写：str\n    - 关联词：bytes\n\n- succeess\n    - 解释：成功\n\n- syn\n    - 解释：在发消息之前，需要先同步。（tcp）\n    - 关联词：ack/nack\n\n- this\n    - 解释：指向当前对象的指针\n    - 关联词：self\n\n- transmitter\n    - 解释：发射机/发射者\n    - 缩写：tx\n    - 关联词：sender/receiver\n\n- type\n    - 解释：a class or group of people or things that share particular qualities or features and are part of a larger group，如不同的人种\n    - 关联词：kind\n\n- value\n    - 解释：由代数项表示的数值、数量\n    - 缩写：val\n    - 关联词：data\n\n- variable\n    - 解释：可变因素\n    - 缩写：var\n\n- version\n    - 解释：版本\n    - 缩写：vers\n \n- manager\n    - 解释：待定\n- processor\n    - 解释：待定\n- controller\n    - 解释：待定\n\n- block\n    - 解释：由sector组成\n- sector\n    - 解释：由page组成\n- page\n    - 解释：SPI FLASH最小写操作单元\n\n- 关于setting/option/preference/property/configuration的理解：\n\n    Someone style:\n\n    - Settings: \"View or modify the list of things that can     be set\"\n    - Options: \"We have set some things already, and give   you the option to enable or disable them\"\n    - Preferences: \"Tell us how you prefer this to work\"\n    - Properties: \"Change one or more properties of this    item\"\n    - Configuration: \"We have defaults, but they're so  barebones you probably want to configure it yourself\"\n\n    Following an approximate lead from Visual Studio and    other Microsoft products:\n\n    - Properties represent the characteristics of a single  component or object in the application.\n    - Options alter global ways that the application works.     Microsoft products use this to customise the UI toolbar,     for example. There's an implication here that you can  disable UI elements altogether (e.g. a \"Simple\" user     interface or an \"Advanced\" user interface).\n    - Settings and Preferences change qualities of how the  application works. The implication here is to change,    not disable: for example, \"Metric measurements\" or     \"British Imperial measurements\".\n    - Configuration is often where an application is    customised for each user or group.\n\n    知乎：\n\n        Configure some options in the settings.\n\n    - 程序所有的可变项叫做Settings。中文译作设置。所有的设置都是    “可选项”，Option（选项，不是期权），因为在程序世界里没有真的    开放式问题只有选择题（Option）。改变可选项的过程叫做    Configure配置（动词）。\n    - 附赠：已确定的Configure结果叫做Configuration配置（名词）  。Configure和Configuration都经常缩写为Config。一套既成的可    迁移的实现特定目的的Configuration叫做Profile，例如手机里的  静音Profile、仅震动Profile、蓝牙各种profile。\n\n\n## 6.2. 动词\n\n- 持久层/数据库操作\n    - create\n        - 创建新的记录\n    - read\n        - 读已存在的记录\n    - update\n        - 更新已存在的记录\n    - delete\n        - 删除已存在的记录\n\n- 整体和个体的访问操作\n    - put\n        - 将对象或者任意数据存进去（对象大小由sizeof决定）\n    - get\n        - 将对象或者任意数据读出来（对象大小由sizeof决定）\n    - write\n        - 将n个字节写进去\n    - read\n        - 将n个字节读出来\n\n- 恢复/复原/重置\n    - recover\n        - 解释：从备份中获取部分文件\n\n    - restore\n        - 解释：从备份中获取整个系统\n\n    - refresh\n        - 解释：重装系统，但是保留应用程序和个人设置文件\n\n    - reset\n        - 解释：重装系统，删除所有东西\n        - 缩写：rst\n\n- 查询/寻找/搜索\n    - inquire\n        - 解释：在某个范围内查询某指定事物（ask sth）\n    - find\n        - 解释：偶然遇到或者发现特定事物\n    - search\n        - 解释：I searched on the internet. I found what I was looking for.（指定性没那么强）\n\n- 过滤/拦截/排列\n    - filter\n        - 解释：pass (a liquid, gas, light, or sound) through a device to remove unwanted material.\n        - 关联词：filter（名词）\n    - intercept\n        - 解释：to stop sb/sth that is going from one place to another from arriving\n        - 关联词：interceptor（名词） \n    - sort\n        - 解释：按顺序排列\n\n\n- 学习/研究/分析\n    - study\n    - learn\n    - research\n        - 解释：不断寻找和检查来研究某事物\n    - analyze\n        - 解释：对当前主题进行分析\n\n- 覆盖\n    - cover\n        - 解释：把某事物放在某事物上面，如隐藏和保护\n    - overlap\n        - 解释：延伸并部分覆盖或者替代掉某物\n\n- 固定搭配\n    - fetch\n        - 解释：获取东西\n        - 关联词：store   \n    - store\n        - 解释：将东西保存起来以备以后使用\n        - 关联词：fetch\n    \n    - start\n        - 解释：较随意的开始/创立\n    - stop\n        - 解释：较随意的结束\n\n    - begin\n        - 解释：从头开始\n    - end\n        - 解释：终点结束\n\n    - enter\n        - 解释：加入/进入/开始从事/开始活动\n    - exit\n        - 解释：退出（计算机程序）\n\n    - open\n        - 解释：参考文件系统使用方法\n    - close\n        - 解释：参考文件系统使用方法\n\n    - input\n        - 解释：第三人称描述某个事物的输入\n        - 关联词：receive（第一人称）\n    - output\n        - 解释：第三人称描述某个事物的输出\n        - 关联词：transmit（第一人称）\n   \n    - upload\n        - 解释：上传到服务器或者别的电脑\n    - download\n        - 解释：从服务器或者别的电脑下载\n        \n    - set\n        - 解释：设置\n    - clear\n        - 解释：清除\n        - 缩写：clr\n\n    - init\n        - 解释：是一个实例的初始化方法\n    - deinit\n        - 解释：释放内存\n\n    - plus\n        - 解释：加法\n    - minus\n        - 解释：减法\n\n    - subscribe\n        - 解释：订阅\n        - 缩写：subs\n    - publish\n        - 解释：发布\n        - 缩写：pub\n\n    - add\n        - 解释：增加某东西\n    - sub\n        - 解释：减去某东西\n\n    - pend\n        - 参考操作系统\n    - post\n        - 参考操作系统\n\n    - error\n        - 解释：err\n        - 缩写：\n    - ok\n        - 解释：\n        - 缩写：\n\n\n\n- append\n    - 解释：在结尾插入内容\n\n\n- calculate\n    - 解释：计算\n    - 缩写：calc\n\n- contain\n    - 解释：包含/含有/容纳\n\n- erase\n    - 解释：flash专用\n\n- indicate\n    - 解释：指示\n    - 关联词：confirm\n\n- initialize\n    - 解释：类的方法，在所有实例方法和类方法执行前运行\n\n- notify\n    - 解释：正式通报，通知\n\n- implement\n    - 解释：实现\n    - 缩写：impl\n\n- remove\n    - 解释：拿走，但内存还在\n    - 关联词：delete（删除释放内存）、recover\n\n- transfer\n    - 解释：移交/转移\n\n- translate\n    - 解释：转变/变为\n\n- overflow\n    - 解释：溢出某个容器\n    \n- peek\n    - 解释：偷看一眼\n\n- process\n    - 解释：对data作一些的操作或处理\n\n\n## 6.3. 形容词\n\n- 固定搭配\n    - valid\n        - 解释：有效的\n    - invalid\n        - 解释：无效的\n\n    - busy\n        - 解释：忙\n    - idle\n        - 解释：空闲\n\n    - used\n        - 解释：已使用\n    - unused\n        - 解释：没用着的/空闲的\n\n\n\n- 描述真实/真的\n    - actual\n        - 解释：形容客观存在的事实或者行为\n    - real\n        - 解释：真实的/实际存在的，对真理的描述\n\n- 描述大小\n    - larger\n        - 解释：强调体积/能力/数量\n    - bigger\n        - 解释：表示由“重”的意思，重要/重量。\n    - smaller\n        - 解释：无关紧要的/小的数量\n    - little\n        - 解释：小的尺寸/只有一点点\n    - tiny\n        - 解释：极小的/微小的/微量的\n\n- different\n    - 解释：不同\n    - 缩写：diff\n\n- equal\n    - 解释：大小、价值、数量相等或相同\n\n- expected\n    - 解释：预料的/预期的\n\n- initial\n    - 解释：初始化的\n\n- remain\n    - 解释：仍然存在/可以使用/还没被处理\n\n- temp\n    - 解释：临时\n    - 缩写：tmp\n","slug":"coder-handbook","published":1,"updated":"2019-09-19T02:37:57.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22u8qar001mgcg8ps0fovs4","content":"<p>大佬有云：</p>\n<blockquote>\n<p>Talk is cheap. Show me the code.       –Linus Torvalds</p>\n</blockquote>\n<p>官方来说，代码好坏体现一个程序员的职业素养，在笔者看来代码是一个程序员的门面担当，在这个颜值即正义的时代，作为程序员如何码的一手好代码，是门必修课中的必修课。<br><a id=\"more\"></a> </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li>写该文档为目的是：形成一套平时监督自己代码是否合理的规范。</li>\n<li>本文大部分的理论经验参考《Clean Code》——Robert C.Martin，如有理解不对，还请斧正。</li>\n<li>最后，会附上笔者对于一些<code>名词</code>、<code>动词对</code>和<code>形容词</code>的理解。</li>\n</ul>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-命名\">1. 命名</a><ul>\n<li><a href=\"#11-代码简洁不代表模糊\">1.1. 代码简洁不代表模糊</a></li>\n<li><a href=\"#12-有意义的变量名\">1.2. 有意义的变量名</a></li>\n<li><a href=\"#13-避免使用编码或者前缀\">1.3. 避免使用编码或者前缀</a></li>\n<li><a href=\"#14-类名应该是清晰的名词或者名词短语尽量不要用单一抽象名词\">1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词</a></li>\n</ul>\n</li>\n<li><a href=\"#2-函数\">2. 函数</a><ul>\n<li><a href=\"#21-只在函数名的同一抽象层做一件事情且函数应该自顶向下不窜层\">2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。</a></li>\n<li><a href=\"#22-使用描述性名称\">2.2. 使用描述性名称</a></li>\n<li><a href=\"#23-命名方式要保持一致\">2.3. 命名方式要保持一致</a></li>\n<li><a href=\"#24-函数参数\">2.4. 函数参数</a></li>\n<li><a href=\"#25-动词与关键词\">2.5. 动词与关键词</a></li>\n<li><a href=\"#26-输出参数\">2.6. 输出参数</a></li>\n<li><a href=\"#27-分隔指令与询问\">2.7. 分隔指令与询问</a></li>\n<li><a href=\"#28-结构化编程\">2.8. 结构化编程</a></li>\n<li><a href=\"#29-如何写出心目中的函数\">2.9. 如何写出心目中的函数</a></li>\n</ul>\n</li>\n<li><a href=\"#3-注释\">3. 注释</a><ul>\n<li><a href=\"#31-好注释\">3.1. 好注释</a></li>\n</ul>\n</li>\n<li><a href=\"#4-对象和数据结构\">4. 对象和数据结构</a><ul>\n<li><a href=\"#41-数据抽象\">4.1. 数据抽象</a></li>\n<li><a href=\"#42-数据结构对象的反对称性\">4.2. 数据结构、对象的反对称性</a></li>\n<li><a href=\"#43-lod\">4.3. LoD</a></li>\n</ul>\n</li>\n<li><a href=\"#5-异常处理\">5. 异常处理</a><ul>\n<li><a href=\"#51-别传递null值\">5.1. 别传递null值</a></li>\n</ul>\n</li>\n<li><a href=\"#6-附录\">6. 附录</a><ul>\n<li><a href=\"#61-名词\">6.1. 名词</a></li>\n<li><a href=\"#62-动词\">6.2. 动词</a></li>\n<li><a href=\"#63-形容词\">6.3. 形容词</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-命名\"><a href=\"#1-命名\" class=\"headerlink\" title=\"1. 命名\"></a>1. 命名</h1><h2 id=\"1-1-代码简洁不代表模糊\"><a href=\"#1-1-代码简洁不代表模糊\" class=\"headerlink\" title=\"1.1. 代码简洁不代表模糊\"></a>1.1. 代码简洁不代表模糊</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> <span class=\"built_in\">array</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> students_id[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-有意义的变量名\"><a href=\"#1-2-有意义的变量名\" class=\"headerlink\" title=\"1.2. 有意义的变量名\"></a>1.2. 有意义的变量名</h2><p>不要写a1，a2，a3，a，b，这样的变量名，除非在特定应用场景。</p>\n<h2 id=\"1-3-避免使用编码或者前缀\"><a href=\"#1-3-避免使用编码或者前缀\" class=\"headerlink\" title=\"1.3. 避免使用编码或者前缀\"></a>1.3. 避免使用编码或者前缀</h2><p>以前变量名带编码是因为编译器不会帮忙检查类型，要人工检查，现在编译器会帮忙检查类型，没必要增加冗余的东西。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span>  u32_student_id;</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span>   u8_student_weight;</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span>  *g_student_weight;</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span>  *g_student_height;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> student_id;</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span>  student_weight;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-4-类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词\"><a href=\"#1-4-类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词\" class=\"headerlink\" title=\"1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词\"></a>1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词</h2><p>我觉得在嵌入式行业会经常使用manager，controller等词，而每个人都会对它们有不同的定义，在不同场景它们也确实有不同的意义，所以就是会产生歧义和模糊性，除非对于这些名词有比较好的区分说明和规范，否则不太推荐使用，推荐使用大家能不产生歧义的名词。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">manager</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">processor</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">data</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">info</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student_info</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>    weight;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>    height;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> customer_hobbies &#123;</span><br><span class=\"line\">    FOOTBALL,</span><br><span class=\"line\">    BASKETBALL,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> dev_addr[<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-函数\"><a href=\"#2-函数\" class=\"headerlink\" title=\"2. 函数\"></a>2. 函数</h1><h2 id=\"2-1-只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。\"><a href=\"#2-1-只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。\" class=\"headerlink\" title=\"2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。\"></a>2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 一个抽象层（发送数据），做一件事情（发数据），推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_fifo_data</span><span class=\"params\">(<span class=\"keyword\">void</span> *fifo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_fifo_empty(fifo)) &#123;</span><br><span class=\"line\">        send(fifo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 两个抽象层（发送数据、fifo为空），做一件事情（发数据），不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_fifo_data</span><span class=\"params\">(<span class=\"keyword\">void</span> *fifo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_fifo_empty(fifo)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first_elem_in_fifo(fifo) == <span class=\"number\">0xa5</span>) &#123;</span><br><span class=\"line\">            send(fifo);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 两个函数，两个抽象层，做了两件事情，函数自顶向下，不窜层，推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_fifo_data</span><span class=\"params\">(<span class=\"keyword\">void</span> *fifo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_fifo_valid(fifo)) &#123;</span><br><span class=\"line\">        send(fifo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> is_fifo_valid(<span class=\"keyword\">void</span> *fifo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_fifo_empty(fifo)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first_elem_in_fifo(fifo) == <span class=\"number\">0xa5</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2-使用描述性名称\"><a href=\"#2-2-使用描述性名称\" class=\"headerlink\" title=\"2.2. 使用描述性名称\"></a>2.2. 使用描述性名称</h2><p>函数内容应该尽可能短，但是函数名称没限制，只要能把事情描述清楚，长一点没问题。</p>\n<h2 id=\"2-3-命名方式要保持一致\"><a href=\"#2-3-命名方式要保持一致\" class=\"headerlink\" title=\"2.3. 命名方式要保持一致\"></a>2.3. 命名方式要保持一致</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_year();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_month();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_day();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_hour();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_year();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> month_get();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> fetch_day();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> read_hour();</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4-函数参数\"><a href=\"#2-4-函数参数\" class=\"headerlink\" title=\"2.4. 函数参数\"></a>2.4. 函数参数</h2><p>个数越少越好，最好没有。</p>\n<ul>\n<li>参数多会导致单元测试出现很多分支，覆盖率复杂。</li>\n<li>如果参数多于3个，说明需要定义一个结构体了。</li>\n</ul>\n<h2 id=\"2-5-动词与关键词\"><a href=\"#2-5-动词与关键词\" class=\"headerlink\" title=\"2.5. 动词与关键词\"></a>2.5. 动词与关键词</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 一元函数，应该遵循：动词/名词结构比较好。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">void</span> *name)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write_field</span><span class=\"params\">(<span class=\"keyword\">void</span> *name)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">/*</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"> * 二元函数，参数包含在函数名内，可以防止我们对于参数输入顺序出错，也是不错的选择</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"> */</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">is_a_larger_b</span><span class=\"params\">(<span class=\"keyword\">void</span> *a, <span class=\"keyword\">void</span> *b)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-6-输出参数\"><a href=\"#2-6-输出参数\" class=\"headerlink\" title=\"2.6. 输出参数\"></a>2.6. 输出参数</h2><p>尽量避免输出过多参数，可以用<code>对象参数</code>或者<code>返回值</code>来替代。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * len是希望读到buf的个数，p_len是实际读到buf的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_bytes</span><span class=\"params\">(<span class=\"keyword\">void</span> *fifo, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">uint8_t</span> len, <span class=\"keyword\">void</span> *p_len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * len是希望读到buf的个数，返回值是实际读到buf的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> read_bytes(<span class=\"keyword\">void</span> *fifo, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">uint8_t</span> len);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-7-分隔指令与询问\"><a href=\"#2-7-分隔指令与询问\" class=\"headerlink\" title=\"2.7. 分隔指令与询问\"></a>2.7. 分隔指令与询问</h2><p>函数要么做什么事，要么回答什么事，不要两者兼得。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置名字属性，如果name已经存在，则返回1，否则返回0。（不推荐）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> set_attribute(<span class=\"keyword\">void</span> *name, <span class=\"keyword\">void</span> *val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    name = val;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 分开两个函数比较合理，然后用以下形式实现。（推荐）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!is_attribute_exist(name)) &#123;</span><br><span class=\"line\">    set_attribute(name, val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-8-结构化编程\"><a href=\"#2-8-结构化编程\" class=\"headerlink\" title=\"2.8. 结构化编程\"></a>2.8. 结构化编程</h2><p>Edsger Dijkstra提出结构化编程，即每个函数，只能有一个入口和一个出口。</p>\n<ul>\n<li>永远不能出现goto</li>\n<li>循环中不能出现break和continue</li>\n<li>每个函数只有一个return</li>\n</ul>\n<p>这个原则用在复杂的大函数效果显著，在小函数可以适当出现return和break，但是goto还是不要出现。</p>\n<h2 id=\"2-9-如何写出心目中的函数\"><a href=\"#2-9-如何写出心目中的函数\" class=\"headerlink\" title=\"2.9. 如何写出心目中的函数\"></a>2.9. 如何写出心目中的函数</h2><p>尝试 + 单元测试 + 提炼，循环上述步骤。</p>\n<h1 id=\"3-注释\"><a href=\"#3-注释\" class=\"headerlink\" title=\"3. 注释\"></a>3. 注释</h1><h2 id=\"3-1-好注释\"><a href=\"#3-1-好注释\" class=\"headerlink\" title=\"3.1. 好注释\"></a>3.1. 好注释</h2><ul>\n<li>对意图的注释</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">uart_receiver_fsm</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> chr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_fifo_not_empty(&amp;fifo)) &#123;</span><br><span class=\"line\">        chr = get_elem(&amp;fifo);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 当收到第一个字节时候便打开接收超时定时器，</span></span><br><span class=\"line\"><span class=\"comment\">         * 用于计算接收超时</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        timer_start(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>阐释</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 当a==b的时候，compare返回0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (comapre(a, b) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 当a &gt; b(asc2)的时候，compare返回1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (comapre(a, b) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-对象和数据结构\"><a href=\"#4-对象和数据结构\" class=\"headerlink\" title=\"4. 对象和数据结构\"></a>4. 对象和数据结构</h1><h2 id=\"4-1-数据抽象\"><a href=\"#4-1-数据抽象\" class=\"headerlink\" title=\"4.1. 数据抽象\"></a>4.1. 数据抽象</h2><ul>\n<li>抽象接口不是简单的取值器和赋值器</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐，battery对象的接口只是将能量数值以函数形式暴露，</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里的几个接口函数就是简单取值器，没有太多抽象作用。   </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> remained_energy_in_mw;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">battery_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_remained_energy_in_mw(<span class=\"keyword\">battery_t</span> *self);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐，battery对象的接口将能量抽象成百分比形式，</span></span><br><span class=\"line\"><span class=\"comment\"> * 没有暴露具体数值和单位。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> remained_energy_in_mw;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">battery_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_remained_percent_energy(<span class=\"keyword\">battery_t</span> *self);</span><br></pre></td></tr></table></figure>\n<p>要以最好的形式呈现对象的数据，不能随意加取值期和赋值器。</p>\n<h2 id=\"4-2-数据结构、对象的反对称性\"><a href=\"#4-2-数据结构、对象的反对称性\" class=\"headerlink\" title=\"4.2. 数据结构、对象的反对称性\"></a>4.2. 数据结构、对象的反对称性</h2><ul>\n<li>过程式代码：暴露数据结构细节，便于在不改动数据结构基础上增添函数。</li>\n<li>面向对象式代码：隐藏数据结构细节，便于在不改动函数的基础上增添新类。</li>\n</ul>\n<p>过程式代码难修改数据结构，因为这样需要修改全部函数。面向对向式代码难修改函数，因为这样需要修改全部类。所以需要根据实际情况权衡什么时候使用哪种代码。</p>\n<ul>\n<li>混杂对象和数据结构</li>\n</ul>\n<p>混杂增加了添加新函数的难度，也增加了添加数据结构的难度，两面都不讨好。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐，过程式代码，数据结构暴露数据，不提供有意义的函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 优势：添加/修改新的函数不会影响数据结构（比如增加计算形状周长函数）</span></span><br><span class=\"line\"><span class=\"comment\"> * 缺陷：修改数据结构影响所有函数（比如增加一个新的形状）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    SQUARE,</span><br><span class=\"line\">    RECTANGLE,</span><br><span class=\"line\">    CIRCLE,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">shape_info_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_area(<span class=\"keyword\">shape_info_t</span> *shape_info)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (shape_info-&gt;type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SQUARE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RECTANGLE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CIRCLE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐，面向对象式代码，隐藏数据，暴露操作数据的函数（shape_get_area）</span></span><br><span class=\"line\"><span class=\"comment\"> * 优势：添加/修改新的数据结构很简单（比如增加一个长方形），对原来的函数没有任何影响。</span></span><br><span class=\"line\"><span class=\"comment\"> * 缺陷：如果需要增加一个获取形状周长的函数，那么全部形状都需要修改。</span></span><br><span class=\"line\"><span class=\"comment\"> * NOTE：这里的关系是is a，如果是has a关系，那么结构体变量类型shape_t应该是shape_t *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PI 3.1415926</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">uint32_t</span> <span class=\"params\">(*<span class=\"keyword\">pfn_get_area_t</span>)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">pfn_get_area_t</span> get_area;</span><br><span class=\"line\">&#125; <span class=\"keyword\">shape_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_t</span> shape_ops;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> r;    </span><br><span class=\"line\">&#125; <span class=\"keyword\">circle_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_t</span> shape_ops;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> side;    </span><br><span class=\"line\">&#125; <span class=\"keyword\">square_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> __cicrle_get_area(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PI * r * r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> __square_get_area(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> side * side;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">circle_t</span> c1 = &#123;</span><br><span class=\"line\">    .shape_ops = __cicrle_get_area,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">square_t</span> s1 = &#123;</span><br><span class=\"line\">    .shape_ops = __square_get_area,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> shape_get_area(<span class=\"keyword\">shape_t</span> *shape)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shape-&gt;get_area();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    shape_get_area((<span class=\"keyword\">shape_t</span> *)&amp;c1);</span><br><span class=\"line\">    shape_get_area((<span class=\"keyword\">shape_t</span> *)&amp;s1);   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐，一半对象，一半数据结构，既拥有函数，又拥有公共变量。</span></span><br><span class=\"line\"><span class=\"comment\"> * 缺陷：添加新函数难，添加新数据结构难。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果需要添加形状（即公共变量改变），则访问公共变量的函数都要修改</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果需要新增一个获取周长的抽象方法（即增加执行函数），则所有形状对象都要修改</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    SQUARE,</span><br><span class=\"line\">    RECTANGLE,</span><br><span class=\"line\">    CIRCLE,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> type;</span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> color_var1;</span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> color_var2;</span><br><span class=\"line\">&#125; <span class=\"keyword\">shape_info_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">uint32_t</span> <span class=\"params\">(*<span class=\"keyword\">pfn_get_color_t</span>)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_info_t</span> shape_info;    <span class=\"comment\">//公共变量</span></span><br><span class=\"line\">    <span class=\"keyword\">pfn_get_color_t</span> get_color;  <span class=\"comment\">//执行函数</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">shape_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_t</span> shape;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> r;    </span><br><span class=\"line\">&#125; <span class=\"keyword\">circle_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_t</span> shape;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> side;    </span><br><span class=\"line\">&#125; <span class=\"keyword\">square_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> __circle_get_color(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color_val1 * color_val2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> __square_get_color(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color_val1 + color_val2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> shape_get_color(<span class=\"keyword\">shape_t</span> *shape)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shape-&gt;get_color();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> shape_get_area(<span class=\"keyword\">shape_t</span> *shape)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 访问公共变量 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (shape-&gt;shape_info.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SQUARE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RECTANGLE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CIRCLE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">circle_t</span> c1 = &#123;</span><br><span class=\"line\">    .shape_info.type = CIRCLE,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">square_t</span> s1 = &#123;</span><br><span class=\"line\">    .shape_info.type = SQUARE,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    shape_get_color((<span class=\"keyword\">shape_t</span> *)&amp;c1))</span><br><span class=\"line\">    shape_get_area((<span class=\"keyword\">shape_t</span> *)&amp;c1))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3-LoD\"><a href=\"#4-3-LoD\" class=\"headerlink\" title=\"4.3. LoD\"></a>4.3. LoD</h2><p>Law of demeter认为，模块不应该了解它所操作对象的内部情形。</p>\n<ul>\n<li>火车失事（只关乎于编码风格，像火车一样的代码）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐，像火车一样的代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">output_dir = ctxt.get_options().get_scratch_dir().get_abs_path();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐（对象）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">ops = ctxt.get_options();</span><br><span class=\"line\">scratch_dir = ops.get_scratch_dir();</span><br><span class=\"line\">abs_path = scratch_dir.get_abs_path();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果ctxt、ops等只是单纯数据结构，而不是对象则没有违反LoD</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">output_dir = ctxt.ops.scratch_dir.abs_path</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-异常处理\"><a href=\"#5-异常处理\" class=\"headerlink\" title=\"5. 异常处理\"></a>5. 异常处理</h1><h2 id=\"5-1-别传递null值\"><a href=\"#5-1-别传递null值\" class=\"headerlink\" title=\"5.1. 别传递null值\"></a>5.1. 别传递null值</h2><p>调用者可能会意外传入null，自己写代码时候应该不写可以传入null的函数，这样只要发现函数列表中有null就是出问题了。</p>\n<h1 id=\"6-附录\"><a href=\"#6-附录\" class=\"headerlink\" title=\"6. 附录\"></a>6. 附录</h1><p>概念解释的来源主要有</p>\n<ul>\n<li>百度翻译中的牛津词典</li>\n<li>google翻译</li>\n<li>stackoverflow高赞答案</li>\n<li>wikidiff.com</li>\n<li>笔者理解</li>\n<li>其他地方</li>\n</ul>\n<h2 id=\"6-1-名词\"><a href=\"#6-1-名词\" class=\"headerlink\" title=\"6.1. 名词\"></a>6.1. 名词</h2><ul>\n<li><p>acknowledge</p>\n<ul>\n<li>解释：确认帧/应答</li>\n<li>缩写：ack</li>\n<li>关联词：nack</li>\n</ul>\n</li>\n<li><p>address</p>\n<ul>\n<li>解释：地址</li>\n<li>缩写：addr</li>\n</ul>\n</li>\n<li><p>amount</p>\n<ul>\n<li>解释：合计总量，表示量</li>\n<li>关联词：number</li>\n</ul>\n</li>\n<li><p>argument</p>\n<ul>\n<li>解释：Argument is the actual value of this variable that gets passed to function.</li>\n<li>缩写：arg</li>\n<li>关联词：parameter<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span> *param)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> arg1[] = <span class=\"string\">\"this is my argument\"</span>;</span><br><span class=\"line\">foo(arg1);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>attribute</p>\n<ul>\n<li>解释：强调事物固有的属性，或区别其他事物的特征。比如车是红色，某某品牌</li>\n<li>缩写：attr</li>\n<li>关联词：property</li>\n</ul>\n</li>\n<li><p>backup</p>\n<ul>\n<li>解释：备份</li>\n<li>缩写：bk</li>\n</ul>\n</li>\n<li><p>buffer</p>\n<ul>\n<li>解释：短暂数据存储的地方</li>\n<li>缩写：buf</li>\n<li>关联词：fifo</li>\n</ul>\n</li>\n<li><p>callback</p>\n<ul>\n<li>解释：邀请返回做某事，带点因果关系的意思。</li>\n<li>缩写：cb</li>\n<li>关联词：handler</li>\n</ul>\n</li>\n<li><p>case</p>\n<ul>\n<li>解释：具体情况/事例/特殊情况</li>\n</ul>\n</li>\n<li><p>command</p>\n<ul>\n<li>解释：命令/指令</li>\n<li>缩写：cmd</li>\n<li>关联词：event</li>\n</ul>\n</li>\n<li><p>content</p>\n<ul>\n<li>解释：所含之物/内容</li>\n</ul>\n</li>\n<li><p>context</p>\n<ul>\n<li>解释：事情发生的背景/上下文环境</li>\n</ul>\n</li>\n<li><p>data</p>\n<ul>\n<li>解释：存储在计算机中的资料/原始数据/调查资料/材料</li>\n<li>同义词：information/results/statistics</li>\n</ul>\n</li>\n<li><p>device</p>\n<ul>\n<li>解释：用于做某项工作的对象或者仪器</li>\n<li>缩写：dev</li>\n</ul>\n</li>\n<li><p>driver</p>\n<ul>\n<li>解释：software that controls the sending of data between a computer and a piece of equipment that is attached to it, such as a printer</li>\n</ul>\n</li>\n<li><p>event</p>\n<ul>\n<li>解释：发生的事情</li>\n<li>缩写：evt</li>\n</ul>\n</li>\n<li><p>fail</p>\n<ul>\n<li>解释：失败</li>\n</ul>\n</li>\n<li><p>field</p>\n<ul>\n<li>解释：字段/信息组</li>\n</ul>\n</li>\n<li><p>fifo</p>\n<ul>\n<li>解释：先进先出算法/先进先出缓冲区</li>\n<li>关联词：lifo</li>\n</ul>\n</li>\n<li><p>frame</p>\n<ul>\n<li>解释：帧有格式，包括帧头+数据部分+帧尾</li>\n<li>关联词：pakcet</li>\n</ul>\n</li>\n<li><p>header</p>\n<ul>\n<li>解释：帧头</li>\n<li>缩写：hdr</li>\n</ul>\n</li>\n<li><p>handle</p>\n<ul>\n<li>解释：事物控制的部分</li>\n<li>缩写：hdl</li>\n</ul>\n</li>\n<li><p>handler</p>\n<ul>\n<li>解释：处理某些事物的人</li>\n<li>缩写：hdlr</li>\n</ul>\n</li>\n<li><p>identity</p>\n<ul>\n<li>解释：身份/本体</li>\n<li>缩写：id</li>\n</ul>\n</li>\n<li><p>information</p>\n<ul>\n<li>解释：事实/某些事物的细节</li>\n<li>缩写：info</li>\n</ul>\n</li>\n<li><p>kind</p>\n<ul>\n<li>解释：a group of people or things that are the same in some way; a particular variety or type，如某个种类的音乐。</li>\n<li>关联词：type</li>\n</ul>\n</li>\n<li><p>length</p>\n<ul>\n<li>解释：长度/距离/持续时间的长短</li>\n<li>缩写：len     </li>\n</ul>\n</li>\n<li><p>message</p>\n<ul>\n<li>解释：（书面或口头的）信息，消息，音信</li>\n<li>缩写：msg</li>\n</ul>\n</li>\n<li><p>nack</p>\n<ul>\n<li>解释：表示报文有错误，要求重发。</li>\n<li>关联词：ack/syn</li>\n</ul>\n</li>\n<li><p>master</p>\n<ul>\n<li>解释：具有控制力的角色</li>\n<li>关联词：slave</li>\n</ul>\n</li>\n<li><p>number</p>\n<ul>\n<li>解释：一个符号，代表数字/序号/数，表示数</li>\n<li>缩写：num</li>\n<li>关联词：amount</li>\n</ul>\n</li>\n<li><p>packet</p>\n<ul>\n<li>解释：a piece of information that forms part of a message sent through a computer network</li>\n<li>缩写：pkt</li>\n<li>关联词：frame/payload</li>\n</ul>\n</li>\n<li><p>parameter</p>\n<ul>\n<li>解释：Parameter is variable in the declaration of function</li>\n<li>缩写：param</li>\n</ul>\n</li>\n<li><p>payload</p>\n<ul>\n<li>解释：有效载荷，是frame中的一部分</li>\n</ul>\n</li>\n<li><p>property</p>\n<ul>\n<li>解释：强调“拥有”的参数，比如车有颜色属性，有尺寸大小属性。</li>\n<li>关联词：attribute</li>\n</ul>\n</li>\n<li><p>receiver</p>\n<ul>\n<li>解释：接收者</li>\n<li>缩写：rx</li>\n</ul>\n</li>\n<li><p>report</p>\n<ul>\n<li>解释：新闻/报告</li>\n</ul>\n</li>\n<li><p>request</p>\n<ul>\n<li>解释：(正式礼貌的)请求和要求的事</li>\n<li>缩写：req</li>\n</ul>\n</li>\n<li><p>response</p>\n<ul>\n<li>解释：(口头或书面的)回复/响应</li>\n<li>缩写：rsp</li>\n</ul>\n</li>\n<li><p>result</p>\n<ul>\n<li>解释：后果/结果</li>\n<li>缩写：res</li>\n</ul>\n</li>\n<li><p>self</p>\n<ul>\n<li>解释：指向当前类的指针</li>\n<li>关联词：this</li>\n</ul>\n</li>\n<li><p>slave</p>\n<ul>\n<li>解释：受控制的角色</li>\n<li>关联词：master</li>\n</ul>\n</li>\n<li><p>sender</p>\n<ul>\n<li>解释：邮寄人 </li>\n</ul>\n</li>\n<li><p>size</p>\n<ul>\n<li>解释：抽象大小概念/标定大小尺寸</li>\n</ul>\n</li>\n<li><p>status</p>\n<ul>\n<li>解释：(进展中的)状况/情形</li>\n</ul>\n</li>\n<li><p>string</p>\n<ul>\n<li>解释：字符串，带’\\0’结尾。</li>\n<li>缩写：str</li>\n<li>关联词：bytes</li>\n</ul>\n</li>\n<li><p>succeess</p>\n<ul>\n<li>解释：成功</li>\n</ul>\n</li>\n<li><p>syn</p>\n<ul>\n<li>解释：在发消息之前，需要先同步。（tcp）</li>\n<li>关联词：ack/nack</li>\n</ul>\n</li>\n<li><p>this</p>\n<ul>\n<li>解释：指向当前对象的指针</li>\n<li>关联词：self</li>\n</ul>\n</li>\n<li><p>transmitter</p>\n<ul>\n<li>解释：发射机/发射者</li>\n<li>缩写：tx</li>\n<li>关联词：sender/receiver</li>\n</ul>\n</li>\n<li><p>type</p>\n<ul>\n<li>解释：a class or group of people or things that share particular qualities or features and are part of a larger group，如不同的人种</li>\n<li>关联词：kind</li>\n</ul>\n</li>\n<li><p>value</p>\n<ul>\n<li>解释：由代数项表示的数值、数量</li>\n<li>缩写：val</li>\n<li>关联词：data</li>\n</ul>\n</li>\n<li><p>variable</p>\n<ul>\n<li>解释：可变因素</li>\n<li>缩写：var</li>\n</ul>\n</li>\n<li><p>version</p>\n<ul>\n<li>解释：版本</li>\n<li>缩写：vers</li>\n</ul>\n</li>\n<li><p>manager</p>\n<ul>\n<li>解释：待定</li>\n</ul>\n</li>\n<li>processor<ul>\n<li>解释：待定</li>\n</ul>\n</li>\n<li><p>controller</p>\n<ul>\n<li>解释：待定</li>\n</ul>\n</li>\n<li><p>block</p>\n<ul>\n<li>解释：由sector组成</li>\n</ul>\n</li>\n<li>sector<ul>\n<li>解释：由page组成</li>\n</ul>\n</li>\n<li><p>page</p>\n<ul>\n<li>解释：SPI FLASH最小写操作单元</li>\n</ul>\n</li>\n<li><p>关于setting/option/preference/property/configuration的理解：</p>\n<p>  Someone style:</p>\n<ul>\n<li>Settings: “View or modify the list of things that can     be set”</li>\n<li>Options: “We have set some things already, and give   you the option to enable or disable them”</li>\n<li>Preferences: “Tell us how you prefer this to work”</li>\n<li>Properties: “Change one or more properties of this    item”</li>\n<li><p>Configuration: “We have defaults, but they’re so  barebones you probably want to configure it yourself”</p>\n<p>Following an approximate lead from Visual Studio and    other Microsoft products:</p>\n</li>\n<li><p>Properties represent the characteristics of a single  component or object in the application.</p>\n</li>\n<li>Options alter global ways that the application works.     Microsoft products use this to customise the UI toolbar,     for example. There’s an implication here that you can  disable UI elements altogether (e.g. a “Simple” user     interface or an “Advanced” user interface).</li>\n<li>Settings and Preferences change qualities of how the  application works. The implication here is to change,    not disable: for example, “Metric measurements” or     “British Imperial measurements”.</li>\n<li><p>Configuration is often where an application is    customised for each user or group.</p>\n<p>知乎：</p>\n<p>  Configure some options in the settings.</p>\n</li>\n<li><p>程序所有的可变项叫做Settings。中文译作设置。所有的设置都是    “可选项”，Option（选项，不是期权），因为在程序世界里没有真的    开放式问题只有选择题（Option）。改变可选项的过程叫做    Configure配置（动词）。</p>\n</li>\n<li>附赠：已确定的Configure结果叫做Configuration配置（名词）  。Configure和Configuration都经常缩写为Config。一套既成的可    迁移的实现特定目的的Configuration叫做Profile，例如手机里的  静音Profile、仅震动Profile、蓝牙各种profile。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-2-动词\"><a href=\"#6-2-动词\" class=\"headerlink\" title=\"6.2. 动词\"></a>6.2. 动词</h2><ul>\n<li><p>持久层/数据库操作</p>\n<ul>\n<li>create<ul>\n<li>创建新的记录</li>\n</ul>\n</li>\n<li>read<ul>\n<li>读已存在的记录</li>\n</ul>\n</li>\n<li>update<ul>\n<li>更新已存在的记录</li>\n</ul>\n</li>\n<li>delete<ul>\n<li>删除已存在的记录</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>整体和个体的访问操作</p>\n<ul>\n<li>put<ul>\n<li>将对象或者任意数据存进去（对象大小由sizeof决定）</li>\n</ul>\n</li>\n<li>get<ul>\n<li>将对象或者任意数据读出来（对象大小由sizeof决定）</li>\n</ul>\n</li>\n<li>write<ul>\n<li>将n个字节写进去</li>\n</ul>\n</li>\n<li>read<ul>\n<li>将n个字节读出来</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>恢复/复原/重置</p>\n<ul>\n<li><p>recover</p>\n<ul>\n<li>解释：从备份中获取部分文件</li>\n</ul>\n</li>\n<li><p>restore</p>\n<ul>\n<li>解释：从备份中获取整个系统</li>\n</ul>\n</li>\n<li><p>refresh</p>\n<ul>\n<li>解释：重装系统，但是保留应用程序和个人设置文件</li>\n</ul>\n</li>\n<li><p>reset</p>\n<ul>\n<li>解释：重装系统，删除所有东西</li>\n<li>缩写：rst</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>查询/寻找/搜索</p>\n<ul>\n<li>inquire<ul>\n<li>解释：在某个范围内查询某指定事物（ask sth）</li>\n</ul>\n</li>\n<li>find<ul>\n<li>解释：偶然遇到或者发现特定事物</li>\n</ul>\n</li>\n<li>search<ul>\n<li>解释：I searched on the internet. I found what I was looking for.（指定性没那么强）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>过滤/拦截/排列</p>\n<ul>\n<li>filter<ul>\n<li>解释：pass (a liquid, gas, light, or sound) through a device to remove unwanted material.</li>\n<li>关联词：filter（名词）</li>\n</ul>\n</li>\n<li>intercept<ul>\n<li>解释：to stop sb/sth that is going from one place to another from arriving</li>\n<li>关联词：interceptor（名词） </li>\n</ul>\n</li>\n<li>sort<ul>\n<li>解释：按顺序排列</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>学习/研究/分析</p>\n<ul>\n<li>study</li>\n<li>learn</li>\n<li>research<ul>\n<li>解释：不断寻找和检查来研究某事物</li>\n</ul>\n</li>\n<li>analyze<ul>\n<li>解释：对当前主题进行分析</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>覆盖</p>\n<ul>\n<li>cover<ul>\n<li>解释：把某事物放在某事物上面，如隐藏和保护</li>\n</ul>\n</li>\n<li>overlap<ul>\n<li>解释：延伸并部分覆盖或者替代掉某物</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>固定搭配</p>\n<ul>\n<li>fetch<ul>\n<li>解释：获取东西</li>\n<li>关联词：store   </li>\n</ul>\n</li>\n<li><p>store</p>\n<ul>\n<li>解释：将东西保存起来以备以后使用</li>\n<li>关联词：fetch</li>\n</ul>\n</li>\n<li><p>start</p>\n<ul>\n<li>解释：较随意的开始/创立</li>\n</ul>\n</li>\n<li><p>stop</p>\n<ul>\n<li>解释：较随意的结束</li>\n</ul>\n</li>\n<li><p>begin</p>\n<ul>\n<li>解释：从头开始</li>\n</ul>\n</li>\n<li><p>end</p>\n<ul>\n<li>解释：终点结束</li>\n</ul>\n</li>\n<li><p>enter</p>\n<ul>\n<li>解释：加入/进入/开始从事/开始活动</li>\n</ul>\n</li>\n<li><p>exit</p>\n<ul>\n<li>解释：退出（计算机程序）</li>\n</ul>\n</li>\n<li><p>open</p>\n<ul>\n<li>解释：参考文件系统使用方法</li>\n</ul>\n</li>\n<li><p>close</p>\n<ul>\n<li>解释：参考文件系统使用方法</li>\n</ul>\n</li>\n<li><p>input</p>\n<ul>\n<li>解释：第三人称描述某个事物的输入</li>\n<li>关联词：receive（第一人称）</li>\n</ul>\n</li>\n<li><p>output</p>\n<ul>\n<li>解释：第三人称描述某个事物的输出</li>\n<li>关联词：transmit（第一人称）</li>\n</ul>\n</li>\n<li><p>upload</p>\n<ul>\n<li>解释：上传到服务器或者别的电脑</li>\n</ul>\n</li>\n<li><p>download</p>\n<ul>\n<li>解释：从服务器或者别的电脑下载</li>\n</ul>\n</li>\n<li><p>set</p>\n<ul>\n<li>解释：设置</li>\n</ul>\n</li>\n<li><p>clear</p>\n<ul>\n<li>解释：清除</li>\n<li>缩写：clr</li>\n</ul>\n</li>\n<li><p>init</p>\n<ul>\n<li>解释：是一个实例的初始化方法</li>\n</ul>\n</li>\n<li><p>deinit</p>\n<ul>\n<li>解释：释放内存</li>\n</ul>\n</li>\n<li><p>plus</p>\n<ul>\n<li>解释：加法</li>\n</ul>\n</li>\n<li><p>minus</p>\n<ul>\n<li>解释：减法</li>\n</ul>\n</li>\n<li><p>subscribe</p>\n<ul>\n<li>解释：订阅</li>\n<li>缩写：subs</li>\n</ul>\n</li>\n<li><p>publish</p>\n<ul>\n<li>解释：发布</li>\n<li>缩写：pub</li>\n</ul>\n</li>\n<li><p>add</p>\n<ul>\n<li>解释：增加某东西</li>\n</ul>\n</li>\n<li><p>sub</p>\n<ul>\n<li>解释：减去某东西</li>\n</ul>\n</li>\n<li><p>pend</p>\n<ul>\n<li>参考操作系统</li>\n</ul>\n</li>\n<li><p>post</p>\n<ul>\n<li>参考操作系统</li>\n</ul>\n</li>\n<li><p>error</p>\n<ul>\n<li>解释：err</li>\n<li>缩写：</li>\n</ul>\n</li>\n<li>ok<ul>\n<li>解释：</li>\n<li>缩写：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>append<ul>\n<li>解释：在结尾插入内容</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>calculate</p>\n<ul>\n<li>解释：计算</li>\n<li>缩写：calc</li>\n</ul>\n</li>\n<li><p>contain</p>\n<ul>\n<li>解释：包含/含有/容纳</li>\n</ul>\n</li>\n<li><p>erase</p>\n<ul>\n<li>解释：flash专用</li>\n</ul>\n</li>\n<li><p>indicate</p>\n<ul>\n<li>解释：指示</li>\n<li>关联词：confirm</li>\n</ul>\n</li>\n<li><p>initialize</p>\n<ul>\n<li>解释：类的方法，在所有实例方法和类方法执行前运行</li>\n</ul>\n</li>\n<li><p>notify</p>\n<ul>\n<li>解释：正式通报，通知</li>\n</ul>\n</li>\n<li><p>implement</p>\n<ul>\n<li>解释：实现</li>\n<li>缩写：impl</li>\n</ul>\n</li>\n<li><p>remove</p>\n<ul>\n<li>解释：拿走，但内存还在</li>\n<li>关联词：delete（删除释放内存）、recover</li>\n</ul>\n</li>\n<li><p>transfer</p>\n<ul>\n<li>解释：移交/转移</li>\n</ul>\n</li>\n<li><p>translate</p>\n<ul>\n<li>解释：转变/变为</li>\n</ul>\n</li>\n<li><p>overflow</p>\n<ul>\n<li>解释：溢出某个容器</li>\n</ul>\n</li>\n<li><p>peek</p>\n<ul>\n<li>解释：偷看一眼</li>\n</ul>\n</li>\n<li><p>process</p>\n<ul>\n<li>解释：对data作一些的操作或处理</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-3-形容词\"><a href=\"#6-3-形容词\" class=\"headerlink\" title=\"6.3. 形容词\"></a>6.3. 形容词</h2><ul>\n<li><p>固定搭配</p>\n<ul>\n<li>valid<ul>\n<li>解释：有效的</li>\n</ul>\n</li>\n<li><p>invalid</p>\n<ul>\n<li>解释：无效的</li>\n</ul>\n</li>\n<li><p>busy</p>\n<ul>\n<li>解释：忙</li>\n</ul>\n</li>\n<li><p>idle</p>\n<ul>\n<li>解释：空闲</li>\n</ul>\n</li>\n<li><p>used</p>\n<ul>\n<li>解释：已使用</li>\n</ul>\n</li>\n<li>unused<ul>\n<li>解释：没用着的/空闲的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>描述真实/真的</p>\n<ul>\n<li>actual<ul>\n<li>解释：形容客观存在的事实或者行为</li>\n</ul>\n</li>\n<li>real<ul>\n<li>解释：真实的/实际存在的，对真理的描述</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>描述大小</p>\n<ul>\n<li>larger<ul>\n<li>解释：强调体积/能力/数量</li>\n</ul>\n</li>\n<li>bigger<ul>\n<li>解释：表示由“重”的意思，重要/重量。</li>\n</ul>\n</li>\n<li>smaller<ul>\n<li>解释：无关紧要的/小的数量</li>\n</ul>\n</li>\n<li>little<ul>\n<li>解释：小的尺寸/只有一点点</li>\n</ul>\n</li>\n<li>tiny<ul>\n<li>解释：极小的/微小的/微量的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>different</p>\n<ul>\n<li>解释：不同</li>\n<li>缩写：diff</li>\n</ul>\n</li>\n<li><p>equal</p>\n<ul>\n<li>解释：大小、价值、数量相等或相同</li>\n</ul>\n</li>\n<li><p>expected</p>\n<ul>\n<li>解释：预料的/预期的</li>\n</ul>\n</li>\n<li><p>initial</p>\n<ul>\n<li>解释：初始化的</li>\n</ul>\n</li>\n<li><p>remain</p>\n<ul>\n<li>解释：仍然存在/可以使用/还没被处理</li>\n</ul>\n</li>\n<li><p>temp</p>\n<ul>\n<li>解释：临时</li>\n<li>缩写：tmp</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>大佬有云：</p>\n<blockquote>\n<p>Talk is cheap. Show me the code.       –Linus Torvalds</p>\n</blockquote>\n<p>官方来说，代码好坏体现一个程序员的职业素养，在笔者看来代码是一个程序员的门面担当，在这个颜值即正义的时代，作为程序员如何码的一手好代码，是门必修课中的必修课。<br>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><ul>\n<li>写该文档为目的是：形成一套平时监督自己代码是否合理的规范。</li>\n<li>本文大部分的理论经验参考《Clean Code》——Robert C.Martin，如有理解不对，还请斧正。</li>\n<li>最后，会附上笔者对于一些<code>名词</code>、<code>动词对</code>和<code>形容词</code>的理解。</li>\n</ul>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><!-- TOC -->\n<ul>\n<li><a href=\"#1-命名\">1. 命名</a><ul>\n<li><a href=\"#11-代码简洁不代表模糊\">1.1. 代码简洁不代表模糊</a></li>\n<li><a href=\"#12-有意义的变量名\">1.2. 有意义的变量名</a></li>\n<li><a href=\"#13-避免使用编码或者前缀\">1.3. 避免使用编码或者前缀</a></li>\n<li><a href=\"#14-类名应该是清晰的名词或者名词短语尽量不要用单一抽象名词\">1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词</a></li>\n</ul>\n</li>\n<li><a href=\"#2-函数\">2. 函数</a><ul>\n<li><a href=\"#21-只在函数名的同一抽象层做一件事情且函数应该自顶向下不窜层\">2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。</a></li>\n<li><a href=\"#22-使用描述性名称\">2.2. 使用描述性名称</a></li>\n<li><a href=\"#23-命名方式要保持一致\">2.3. 命名方式要保持一致</a></li>\n<li><a href=\"#24-函数参数\">2.4. 函数参数</a></li>\n<li><a href=\"#25-动词与关键词\">2.5. 动词与关键词</a></li>\n<li><a href=\"#26-输出参数\">2.6. 输出参数</a></li>\n<li><a href=\"#27-分隔指令与询问\">2.7. 分隔指令与询问</a></li>\n<li><a href=\"#28-结构化编程\">2.8. 结构化编程</a></li>\n<li><a href=\"#29-如何写出心目中的函数\">2.9. 如何写出心目中的函数</a></li>\n</ul>\n</li>\n<li><a href=\"#3-注释\">3. 注释</a><ul>\n<li><a href=\"#31-好注释\">3.1. 好注释</a></li>\n</ul>\n</li>\n<li><a href=\"#4-对象和数据结构\">4. 对象和数据结构</a><ul>\n<li><a href=\"#41-数据抽象\">4.1. 数据抽象</a></li>\n<li><a href=\"#42-数据结构对象的反对称性\">4.2. 数据结构、对象的反对称性</a></li>\n<li><a href=\"#43-lod\">4.3. LoD</a></li>\n</ul>\n</li>\n<li><a href=\"#5-异常处理\">5. 异常处理</a><ul>\n<li><a href=\"#51-别传递null值\">5.1. 别传递null值</a></li>\n</ul>\n</li>\n<li><a href=\"#6-附录\">6. 附录</a><ul>\n<li><a href=\"#61-名词\">6.1. 名词</a></li>\n<li><a href=\"#62-动词\">6.2. 动词</a></li>\n<li><a href=\"#63-形容词\">6.3. 形容词</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"1-命名\"><a href=\"#1-命名\" class=\"headerlink\" title=\"1. 命名\"></a>1. 命名</h1><h2 id=\"1-1-代码简洁不代表模糊\"><a href=\"#1-1-代码简洁不代表模糊\" class=\"headerlink\" title=\"1.1. 代码简洁不代表模糊\"></a>1.1. 代码简洁不代表模糊</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> <span class=\"built_in\">array</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> students_id[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-有意义的变量名\"><a href=\"#1-2-有意义的变量名\" class=\"headerlink\" title=\"1.2. 有意义的变量名\"></a>1.2. 有意义的变量名</h2><p>不要写a1，a2，a3，a，b，这样的变量名，除非在特定应用场景。</p>\n<h2 id=\"1-3-避免使用编码或者前缀\"><a href=\"#1-3-避免使用编码或者前缀\" class=\"headerlink\" title=\"1.3. 避免使用编码或者前缀\"></a>1.3. 避免使用编码或者前缀</h2><p>以前变量名带编码是因为编译器不会帮忙检查类型，要人工检查，现在编译器会帮忙检查类型，没必要增加冗余的东西。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span>  u32_student_id;</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span>   u8_student_weight;</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span>  *g_student_weight;</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span>  *g_student_height;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> student_id;</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span>  student_weight;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-4-类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词\"><a href=\"#1-4-类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词\" class=\"headerlink\" title=\"1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词\"></a>1.4. 类名应该是清晰的名词或者名词短语，尽量不要用单一抽象名词</h2><p>我觉得在嵌入式行业会经常使用manager，controller等词，而每个人都会对它们有不同的定义，在不同场景它们也确实有不同的意义，所以就是会产生歧义和模糊性，除非对于这些名词有比较好的区分说明和规范，否则不太推荐使用，推荐使用大家能不产生歧义的名词。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">manager</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">processor</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">data</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">info</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student_info</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>    weight;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>    height;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> customer_hobbies &#123;</span><br><span class=\"line\">    FOOTBALL,</span><br><span class=\"line\">    BASKETBALL,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> dev_addr[<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-函数\"><a href=\"#2-函数\" class=\"headerlink\" title=\"2. 函数\"></a>2. 函数</h1><h2 id=\"2-1-只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。\"><a href=\"#2-1-只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。\" class=\"headerlink\" title=\"2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。\"></a>2.1. 只在函数名的同一抽象层做一件事情，且函数应该自顶向下，不窜层。</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 一个抽象层（发送数据），做一件事情（发数据），推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_fifo_data</span><span class=\"params\">(<span class=\"keyword\">void</span> *fifo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_fifo_empty(fifo)) &#123;</span><br><span class=\"line\">        send(fifo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 两个抽象层（发送数据、fifo为空），做一件事情（发数据），不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_fifo_data</span><span class=\"params\">(<span class=\"keyword\">void</span> *fifo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_fifo_empty(fifo)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first_elem_in_fifo(fifo) == <span class=\"number\">0xa5</span>) &#123;</span><br><span class=\"line\">            send(fifo);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 两个函数，两个抽象层，做了两件事情，函数自顶向下，不窜层，推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_fifo_data</span><span class=\"params\">(<span class=\"keyword\">void</span> *fifo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_fifo_valid(fifo)) &#123;</span><br><span class=\"line\">        send(fifo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> is_fifo_valid(<span class=\"keyword\">void</span> *fifo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_fifo_empty(fifo)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first_elem_in_fifo(fifo) == <span class=\"number\">0xa5</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2-使用描述性名称\"><a href=\"#2-2-使用描述性名称\" class=\"headerlink\" title=\"2.2. 使用描述性名称\"></a>2.2. 使用描述性名称</h2><p>函数内容应该尽可能短，但是函数名称没限制，只要能把事情描述清楚，长一点没问题。</p>\n<h2 id=\"2-3-命名方式要保持一致\"><a href=\"#2-3-命名方式要保持一致\" class=\"headerlink\" title=\"2.3. 命名方式要保持一致\"></a>2.3. 命名方式要保持一致</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_year();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_month();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_day();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_hour();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_year();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> month_get();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> fetch_day();</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> read_hour();</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4-函数参数\"><a href=\"#2-4-函数参数\" class=\"headerlink\" title=\"2.4. 函数参数\"></a>2.4. 函数参数</h2><p>个数越少越好，最好没有。</p>\n<ul>\n<li>参数多会导致单元测试出现很多分支，覆盖率复杂。</li>\n<li>如果参数多于3个，说明需要定义一个结构体了。</li>\n</ul>\n<h2 id=\"2-5-动词与关键词\"><a href=\"#2-5-动词与关键词\" class=\"headerlink\" title=\"2.5. 动词与关键词\"></a>2.5. 动词与关键词</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 一元函数，应该遵循：动词/名词结构比较好。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">void</span> *name)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write_field</span><span class=\"params\">(<span class=\"keyword\">void</span> *name)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">/*</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"> * 二元函数，参数包含在函数名内，可以防止我们对于参数输入顺序出错，也是不错的选择</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"> */</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">is_a_larger_b</span><span class=\"params\">(<span class=\"keyword\">void</span> *a, <span class=\"keyword\">void</span> *b)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-6-输出参数\"><a href=\"#2-6-输出参数\" class=\"headerlink\" title=\"2.6. 输出参数\"></a>2.6. 输出参数</h2><p>尽量避免输出过多参数，可以用<code>对象参数</code>或者<code>返回值</code>来替代。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * len是希望读到buf的个数，p_len是实际读到buf的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_bytes</span><span class=\"params\">(<span class=\"keyword\">void</span> *fifo, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">uint8_t</span> len, <span class=\"keyword\">void</span> *p_len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * len是希望读到buf的个数，返回值是实际读到buf的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> read_bytes(<span class=\"keyword\">void</span> *fifo, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">uint8_t</span> len);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-7-分隔指令与询问\"><a href=\"#2-7-分隔指令与询问\" class=\"headerlink\" title=\"2.7. 分隔指令与询问\"></a>2.7. 分隔指令与询问</h2><p>函数要么做什么事，要么回答什么事，不要两者兼得。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置名字属性，如果name已经存在，则返回1，否则返回0。（不推荐）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> set_attribute(<span class=\"keyword\">void</span> *name, <span class=\"keyword\">void</span> *val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    name = val;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 分开两个函数比较合理，然后用以下形式实现。（推荐）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!is_attribute_exist(name)) &#123;</span><br><span class=\"line\">    set_attribute(name, val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-8-结构化编程\"><a href=\"#2-8-结构化编程\" class=\"headerlink\" title=\"2.8. 结构化编程\"></a>2.8. 结构化编程</h2><p>Edsger Dijkstra提出结构化编程，即每个函数，只能有一个入口和一个出口。</p>\n<ul>\n<li>永远不能出现goto</li>\n<li>循环中不能出现break和continue</li>\n<li>每个函数只有一个return</li>\n</ul>\n<p>这个原则用在复杂的大函数效果显著，在小函数可以适当出现return和break，但是goto还是不要出现。</p>\n<h2 id=\"2-9-如何写出心目中的函数\"><a href=\"#2-9-如何写出心目中的函数\" class=\"headerlink\" title=\"2.9. 如何写出心目中的函数\"></a>2.9. 如何写出心目中的函数</h2><p>尝试 + 单元测试 + 提炼，循环上述步骤。</p>\n<h1 id=\"3-注释\"><a href=\"#3-注释\" class=\"headerlink\" title=\"3. 注释\"></a>3. 注释</h1><h2 id=\"3-1-好注释\"><a href=\"#3-1-好注释\" class=\"headerlink\" title=\"3.1. 好注释\"></a>3.1. 好注释</h2><ul>\n<li>对意图的注释</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">uart_receiver_fsm</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> chr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_fifo_not_empty(&amp;fifo)) &#123;</span><br><span class=\"line\">        chr = get_elem(&amp;fifo);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 当收到第一个字节时候便打开接收超时定时器，</span></span><br><span class=\"line\"><span class=\"comment\">         * 用于计算接收超时</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        timer_start(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>阐释</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 当a==b的时候，compare返回0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (comapre(a, b) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 当a &gt; b(asc2)的时候，compare返回1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (comapre(a, b) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-对象和数据结构\"><a href=\"#4-对象和数据结构\" class=\"headerlink\" title=\"4. 对象和数据结构\"></a>4. 对象和数据结构</h1><h2 id=\"4-1-数据抽象\"><a href=\"#4-1-数据抽象\" class=\"headerlink\" title=\"4.1. 数据抽象\"></a>4.1. 数据抽象</h2><ul>\n<li>抽象接口不是简单的取值器和赋值器</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐，battery对象的接口只是将能量数值以函数形式暴露，</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里的几个接口函数就是简单取值器，没有太多抽象作用。   </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> remained_energy_in_mw;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">battery_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_remained_energy_in_mw(<span class=\"keyword\">battery_t</span> *self);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐，battery对象的接口将能量抽象成百分比形式，</span></span><br><span class=\"line\"><span class=\"comment\"> * 没有暴露具体数值和单位。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> remained_energy_in_mw;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">battery_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_remained_percent_energy(<span class=\"keyword\">battery_t</span> *self);</span><br></pre></td></tr></table></figure>\n<p>要以最好的形式呈现对象的数据，不能随意加取值期和赋值器。</p>\n<h2 id=\"4-2-数据结构、对象的反对称性\"><a href=\"#4-2-数据结构、对象的反对称性\" class=\"headerlink\" title=\"4.2. 数据结构、对象的反对称性\"></a>4.2. 数据结构、对象的反对称性</h2><ul>\n<li>过程式代码：暴露数据结构细节，便于在不改动数据结构基础上增添函数。</li>\n<li>面向对象式代码：隐藏数据结构细节，便于在不改动函数的基础上增添新类。</li>\n</ul>\n<p>过程式代码难修改数据结构，因为这样需要修改全部函数。面向对向式代码难修改函数，因为这样需要修改全部类。所以需要根据实际情况权衡什么时候使用哪种代码。</p>\n<ul>\n<li>混杂对象和数据结构</li>\n</ul>\n<p>混杂增加了添加新函数的难度，也增加了添加数据结构的难度，两面都不讨好。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐，过程式代码，数据结构暴露数据，不提供有意义的函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 优势：添加/修改新的函数不会影响数据结构（比如增加计算形状周长函数）</span></span><br><span class=\"line\"><span class=\"comment\"> * 缺陷：修改数据结构影响所有函数（比如增加一个新的形状）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    SQUARE,</span><br><span class=\"line\">    RECTANGLE,</span><br><span class=\"line\">    CIRCLE,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">shape_info_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> get_area(<span class=\"keyword\">shape_info_t</span> *shape_info)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (shape_info-&gt;type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SQUARE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RECTANGLE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CIRCLE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐，面向对象式代码，隐藏数据，暴露操作数据的函数（shape_get_area）</span></span><br><span class=\"line\"><span class=\"comment\"> * 优势：添加/修改新的数据结构很简单（比如增加一个长方形），对原来的函数没有任何影响。</span></span><br><span class=\"line\"><span class=\"comment\"> * 缺陷：如果需要增加一个获取形状周长的函数，那么全部形状都需要修改。</span></span><br><span class=\"line\"><span class=\"comment\"> * NOTE：这里的关系是is a，如果是has a关系，那么结构体变量类型shape_t应该是shape_t *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PI 3.1415926</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">uint32_t</span> <span class=\"params\">(*<span class=\"keyword\">pfn_get_area_t</span>)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">pfn_get_area_t</span> get_area;</span><br><span class=\"line\">&#125; <span class=\"keyword\">shape_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_t</span> shape_ops;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> r;    </span><br><span class=\"line\">&#125; <span class=\"keyword\">circle_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_t</span> shape_ops;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> side;    </span><br><span class=\"line\">&#125; <span class=\"keyword\">square_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> __cicrle_get_area(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PI * r * r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> __square_get_area(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> side * side;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">circle_t</span> c1 = &#123;</span><br><span class=\"line\">    .shape_ops = __cicrle_get_area,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">square_t</span> s1 = &#123;</span><br><span class=\"line\">    .shape_ops = __square_get_area,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> shape_get_area(<span class=\"keyword\">shape_t</span> *shape)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shape-&gt;get_area();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    shape_get_area((<span class=\"keyword\">shape_t</span> *)&amp;c1);</span><br><span class=\"line\">    shape_get_area((<span class=\"keyword\">shape_t</span> *)&amp;s1);   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐，一半对象，一半数据结构，既拥有函数，又拥有公共变量。</span></span><br><span class=\"line\"><span class=\"comment\"> * 缺陷：添加新函数难，添加新数据结构难。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果需要添加形状（即公共变量改变），则访问公共变量的函数都要修改</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果需要新增一个获取周长的抽象方法（即增加执行函数），则所有形状对象都要修改</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    SQUARE,</span><br><span class=\"line\">    RECTANGLE,</span><br><span class=\"line\">    CIRCLE,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> type;</span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> color_var1;</span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> color_var2;</span><br><span class=\"line\">&#125; <span class=\"keyword\">shape_info_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">uint32_t</span> <span class=\"params\">(*<span class=\"keyword\">pfn_get_color_t</span>)</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_info_t</span> shape_info;    <span class=\"comment\">//公共变量</span></span><br><span class=\"line\">    <span class=\"keyword\">pfn_get_color_t</span> get_color;  <span class=\"comment\">//执行函数</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">shape_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_t</span> shape;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> r;    </span><br><span class=\"line\">&#125; <span class=\"keyword\">circle_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">shape_t</span> shape;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> side;    </span><br><span class=\"line\">&#125; <span class=\"keyword\">square_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> __circle_get_color(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color_val1 * color_val2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span> __square_get_color(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> color_val1 + color_val2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> shape_get_color(<span class=\"keyword\">shape_t</span> *shape)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shape-&gt;get_color();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span> shape_get_area(<span class=\"keyword\">shape_t</span> *shape)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 访问公共变量 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (shape-&gt;shape_info.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SQUARE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RECTANGLE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CIRCLE:</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">circle_t</span> c1 = &#123;</span><br><span class=\"line\">    .shape_info.type = CIRCLE,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">square_t</span> s1 = &#123;</span><br><span class=\"line\">    .shape_info.type = SQUARE,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    shape_get_color((<span class=\"keyword\">shape_t</span> *)&amp;c1))</span><br><span class=\"line\">    shape_get_area((<span class=\"keyword\">shape_t</span> *)&amp;c1))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3-LoD\"><a href=\"#4-3-LoD\" class=\"headerlink\" title=\"4.3. LoD\"></a>4.3. LoD</h2><p>Law of demeter认为，模块不应该了解它所操作对象的内部情形。</p>\n<ul>\n<li>火车失事（只关乎于编码风格，像火车一样的代码）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 不推荐，像火车一样的代码</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">output_dir = ctxt.get_options().get_scratch_dir().get_abs_path();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 推荐（对象）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">ops = ctxt.get_options();</span><br><span class=\"line\">scratch_dir = ops.get_scratch_dir();</span><br><span class=\"line\">abs_path = scratch_dir.get_abs_path();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果ctxt、ops等只是单纯数据结构，而不是对象则没有违反LoD</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">output_dir = ctxt.ops.scratch_dir.abs_path</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-异常处理\"><a href=\"#5-异常处理\" class=\"headerlink\" title=\"5. 异常处理\"></a>5. 异常处理</h1><h2 id=\"5-1-别传递null值\"><a href=\"#5-1-别传递null值\" class=\"headerlink\" title=\"5.1. 别传递null值\"></a>5.1. 别传递null值</h2><p>调用者可能会意外传入null，自己写代码时候应该不写可以传入null的函数，这样只要发现函数列表中有null就是出问题了。</p>\n<h1 id=\"6-附录\"><a href=\"#6-附录\" class=\"headerlink\" title=\"6. 附录\"></a>6. 附录</h1><p>概念解释的来源主要有</p>\n<ul>\n<li>百度翻译中的牛津词典</li>\n<li>google翻译</li>\n<li>stackoverflow高赞答案</li>\n<li>wikidiff.com</li>\n<li>笔者理解</li>\n<li>其他地方</li>\n</ul>\n<h2 id=\"6-1-名词\"><a href=\"#6-1-名词\" class=\"headerlink\" title=\"6.1. 名词\"></a>6.1. 名词</h2><ul>\n<li><p>acknowledge</p>\n<ul>\n<li>解释：确认帧/应答</li>\n<li>缩写：ack</li>\n<li>关联词：nack</li>\n</ul>\n</li>\n<li><p>address</p>\n<ul>\n<li>解释：地址</li>\n<li>缩写：addr</li>\n</ul>\n</li>\n<li><p>amount</p>\n<ul>\n<li>解释：合计总量，表示量</li>\n<li>关联词：number</li>\n</ul>\n</li>\n<li><p>argument</p>\n<ul>\n<li>解释：Argument is the actual value of this variable that gets passed to function.</li>\n<li>缩写：arg</li>\n<li>关联词：parameter<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span> *param)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">uint8_t</span> arg1[] = <span class=\"string\">\"this is my argument\"</span>;</span><br><span class=\"line\">foo(arg1);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>attribute</p>\n<ul>\n<li>解释：强调事物固有的属性，或区别其他事物的特征。比如车是红色，某某品牌</li>\n<li>缩写：attr</li>\n<li>关联词：property</li>\n</ul>\n</li>\n<li><p>backup</p>\n<ul>\n<li>解释：备份</li>\n<li>缩写：bk</li>\n</ul>\n</li>\n<li><p>buffer</p>\n<ul>\n<li>解释：短暂数据存储的地方</li>\n<li>缩写：buf</li>\n<li>关联词：fifo</li>\n</ul>\n</li>\n<li><p>callback</p>\n<ul>\n<li>解释：邀请返回做某事，带点因果关系的意思。</li>\n<li>缩写：cb</li>\n<li>关联词：handler</li>\n</ul>\n</li>\n<li><p>case</p>\n<ul>\n<li>解释：具体情况/事例/特殊情况</li>\n</ul>\n</li>\n<li><p>command</p>\n<ul>\n<li>解释：命令/指令</li>\n<li>缩写：cmd</li>\n<li>关联词：event</li>\n</ul>\n</li>\n<li><p>content</p>\n<ul>\n<li>解释：所含之物/内容</li>\n</ul>\n</li>\n<li><p>context</p>\n<ul>\n<li>解释：事情发生的背景/上下文环境</li>\n</ul>\n</li>\n<li><p>data</p>\n<ul>\n<li>解释：存储在计算机中的资料/原始数据/调查资料/材料</li>\n<li>同义词：information/results/statistics</li>\n</ul>\n</li>\n<li><p>device</p>\n<ul>\n<li>解释：用于做某项工作的对象或者仪器</li>\n<li>缩写：dev</li>\n</ul>\n</li>\n<li><p>driver</p>\n<ul>\n<li>解释：software that controls the sending of data between a computer and a piece of equipment that is attached to it, such as a printer</li>\n</ul>\n</li>\n<li><p>event</p>\n<ul>\n<li>解释：发生的事情</li>\n<li>缩写：evt</li>\n</ul>\n</li>\n<li><p>fail</p>\n<ul>\n<li>解释：失败</li>\n</ul>\n</li>\n<li><p>field</p>\n<ul>\n<li>解释：字段/信息组</li>\n</ul>\n</li>\n<li><p>fifo</p>\n<ul>\n<li>解释：先进先出算法/先进先出缓冲区</li>\n<li>关联词：lifo</li>\n</ul>\n</li>\n<li><p>frame</p>\n<ul>\n<li>解释：帧有格式，包括帧头+数据部分+帧尾</li>\n<li>关联词：pakcet</li>\n</ul>\n</li>\n<li><p>header</p>\n<ul>\n<li>解释：帧头</li>\n<li>缩写：hdr</li>\n</ul>\n</li>\n<li><p>handle</p>\n<ul>\n<li>解释：事物控制的部分</li>\n<li>缩写：hdl</li>\n</ul>\n</li>\n<li><p>handler</p>\n<ul>\n<li>解释：处理某些事物的人</li>\n<li>缩写：hdlr</li>\n</ul>\n</li>\n<li><p>identity</p>\n<ul>\n<li>解释：身份/本体</li>\n<li>缩写：id</li>\n</ul>\n</li>\n<li><p>information</p>\n<ul>\n<li>解释：事实/某些事物的细节</li>\n<li>缩写：info</li>\n</ul>\n</li>\n<li><p>kind</p>\n<ul>\n<li>解释：a group of people or things that are the same in some way; a particular variety or type，如某个种类的音乐。</li>\n<li>关联词：type</li>\n</ul>\n</li>\n<li><p>length</p>\n<ul>\n<li>解释：长度/距离/持续时间的长短</li>\n<li>缩写：len     </li>\n</ul>\n</li>\n<li><p>message</p>\n<ul>\n<li>解释：（书面或口头的）信息，消息，音信</li>\n<li>缩写：msg</li>\n</ul>\n</li>\n<li><p>nack</p>\n<ul>\n<li>解释：表示报文有错误，要求重发。</li>\n<li>关联词：ack/syn</li>\n</ul>\n</li>\n<li><p>master</p>\n<ul>\n<li>解释：具有控制力的角色</li>\n<li>关联词：slave</li>\n</ul>\n</li>\n<li><p>number</p>\n<ul>\n<li>解释：一个符号，代表数字/序号/数，表示数</li>\n<li>缩写：num</li>\n<li>关联词：amount</li>\n</ul>\n</li>\n<li><p>packet</p>\n<ul>\n<li>解释：a piece of information that forms part of a message sent through a computer network</li>\n<li>缩写：pkt</li>\n<li>关联词：frame/payload</li>\n</ul>\n</li>\n<li><p>parameter</p>\n<ul>\n<li>解释：Parameter is variable in the declaration of function</li>\n<li>缩写：param</li>\n</ul>\n</li>\n<li><p>payload</p>\n<ul>\n<li>解释：有效载荷，是frame中的一部分</li>\n</ul>\n</li>\n<li><p>property</p>\n<ul>\n<li>解释：强调“拥有”的参数，比如车有颜色属性，有尺寸大小属性。</li>\n<li>关联词：attribute</li>\n</ul>\n</li>\n<li><p>receiver</p>\n<ul>\n<li>解释：接收者</li>\n<li>缩写：rx</li>\n</ul>\n</li>\n<li><p>report</p>\n<ul>\n<li>解释：新闻/报告</li>\n</ul>\n</li>\n<li><p>request</p>\n<ul>\n<li>解释：(正式礼貌的)请求和要求的事</li>\n<li>缩写：req</li>\n</ul>\n</li>\n<li><p>response</p>\n<ul>\n<li>解释：(口头或书面的)回复/响应</li>\n<li>缩写：rsp</li>\n</ul>\n</li>\n<li><p>result</p>\n<ul>\n<li>解释：后果/结果</li>\n<li>缩写：res</li>\n</ul>\n</li>\n<li><p>self</p>\n<ul>\n<li>解释：指向当前类的指针</li>\n<li>关联词：this</li>\n</ul>\n</li>\n<li><p>slave</p>\n<ul>\n<li>解释：受控制的角色</li>\n<li>关联词：master</li>\n</ul>\n</li>\n<li><p>sender</p>\n<ul>\n<li>解释：邮寄人 </li>\n</ul>\n</li>\n<li><p>size</p>\n<ul>\n<li>解释：抽象大小概念/标定大小尺寸</li>\n</ul>\n</li>\n<li><p>status</p>\n<ul>\n<li>解释：(进展中的)状况/情形</li>\n</ul>\n</li>\n<li><p>string</p>\n<ul>\n<li>解释：字符串，带’\\0’结尾。</li>\n<li>缩写：str</li>\n<li>关联词：bytes</li>\n</ul>\n</li>\n<li><p>succeess</p>\n<ul>\n<li>解释：成功</li>\n</ul>\n</li>\n<li><p>syn</p>\n<ul>\n<li>解释：在发消息之前，需要先同步。（tcp）</li>\n<li>关联词：ack/nack</li>\n</ul>\n</li>\n<li><p>this</p>\n<ul>\n<li>解释：指向当前对象的指针</li>\n<li>关联词：self</li>\n</ul>\n</li>\n<li><p>transmitter</p>\n<ul>\n<li>解释：发射机/发射者</li>\n<li>缩写：tx</li>\n<li>关联词：sender/receiver</li>\n</ul>\n</li>\n<li><p>type</p>\n<ul>\n<li>解释：a class or group of people or things that share particular qualities or features and are part of a larger group，如不同的人种</li>\n<li>关联词：kind</li>\n</ul>\n</li>\n<li><p>value</p>\n<ul>\n<li>解释：由代数项表示的数值、数量</li>\n<li>缩写：val</li>\n<li>关联词：data</li>\n</ul>\n</li>\n<li><p>variable</p>\n<ul>\n<li>解释：可变因素</li>\n<li>缩写：var</li>\n</ul>\n</li>\n<li><p>version</p>\n<ul>\n<li>解释：版本</li>\n<li>缩写：vers</li>\n</ul>\n</li>\n<li><p>manager</p>\n<ul>\n<li>解释：待定</li>\n</ul>\n</li>\n<li>processor<ul>\n<li>解释：待定</li>\n</ul>\n</li>\n<li><p>controller</p>\n<ul>\n<li>解释：待定</li>\n</ul>\n</li>\n<li><p>block</p>\n<ul>\n<li>解释：由sector组成</li>\n</ul>\n</li>\n<li>sector<ul>\n<li>解释：由page组成</li>\n</ul>\n</li>\n<li><p>page</p>\n<ul>\n<li>解释：SPI FLASH最小写操作单元</li>\n</ul>\n</li>\n<li><p>关于setting/option/preference/property/configuration的理解：</p>\n<p>  Someone style:</p>\n<ul>\n<li>Settings: “View or modify the list of things that can     be set”</li>\n<li>Options: “We have set some things already, and give   you the option to enable or disable them”</li>\n<li>Preferences: “Tell us how you prefer this to work”</li>\n<li>Properties: “Change one or more properties of this    item”</li>\n<li><p>Configuration: “We have defaults, but they’re so  barebones you probably want to configure it yourself”</p>\n<p>Following an approximate lead from Visual Studio and    other Microsoft products:</p>\n</li>\n<li><p>Properties represent the characteristics of a single  component or object in the application.</p>\n</li>\n<li>Options alter global ways that the application works.     Microsoft products use this to customise the UI toolbar,     for example. There’s an implication here that you can  disable UI elements altogether (e.g. a “Simple” user     interface or an “Advanced” user interface).</li>\n<li>Settings and Preferences change qualities of how the  application works. The implication here is to change,    not disable: for example, “Metric measurements” or     “British Imperial measurements”.</li>\n<li><p>Configuration is often where an application is    customised for each user or group.</p>\n<p>知乎：</p>\n<p>  Configure some options in the settings.</p>\n</li>\n<li><p>程序所有的可变项叫做Settings。中文译作设置。所有的设置都是    “可选项”，Option（选项，不是期权），因为在程序世界里没有真的    开放式问题只有选择题（Option）。改变可选项的过程叫做    Configure配置（动词）。</p>\n</li>\n<li>附赠：已确定的Configure结果叫做Configuration配置（名词）  。Configure和Configuration都经常缩写为Config。一套既成的可    迁移的实现特定目的的Configuration叫做Profile，例如手机里的  静音Profile、仅震动Profile、蓝牙各种profile。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-2-动词\"><a href=\"#6-2-动词\" class=\"headerlink\" title=\"6.2. 动词\"></a>6.2. 动词</h2><ul>\n<li><p>持久层/数据库操作</p>\n<ul>\n<li>create<ul>\n<li>创建新的记录</li>\n</ul>\n</li>\n<li>read<ul>\n<li>读已存在的记录</li>\n</ul>\n</li>\n<li>update<ul>\n<li>更新已存在的记录</li>\n</ul>\n</li>\n<li>delete<ul>\n<li>删除已存在的记录</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>整体和个体的访问操作</p>\n<ul>\n<li>put<ul>\n<li>将对象或者任意数据存进去（对象大小由sizeof决定）</li>\n</ul>\n</li>\n<li>get<ul>\n<li>将对象或者任意数据读出来（对象大小由sizeof决定）</li>\n</ul>\n</li>\n<li>write<ul>\n<li>将n个字节写进去</li>\n</ul>\n</li>\n<li>read<ul>\n<li>将n个字节读出来</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>恢复/复原/重置</p>\n<ul>\n<li><p>recover</p>\n<ul>\n<li>解释：从备份中获取部分文件</li>\n</ul>\n</li>\n<li><p>restore</p>\n<ul>\n<li>解释：从备份中获取整个系统</li>\n</ul>\n</li>\n<li><p>refresh</p>\n<ul>\n<li>解释：重装系统，但是保留应用程序和个人设置文件</li>\n</ul>\n</li>\n<li><p>reset</p>\n<ul>\n<li>解释：重装系统，删除所有东西</li>\n<li>缩写：rst</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>查询/寻找/搜索</p>\n<ul>\n<li>inquire<ul>\n<li>解释：在某个范围内查询某指定事物（ask sth）</li>\n</ul>\n</li>\n<li>find<ul>\n<li>解释：偶然遇到或者发现特定事物</li>\n</ul>\n</li>\n<li>search<ul>\n<li>解释：I searched on the internet. I found what I was looking for.（指定性没那么强）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>过滤/拦截/排列</p>\n<ul>\n<li>filter<ul>\n<li>解释：pass (a liquid, gas, light, or sound) through a device to remove unwanted material.</li>\n<li>关联词：filter（名词）</li>\n</ul>\n</li>\n<li>intercept<ul>\n<li>解释：to stop sb/sth that is going from one place to another from arriving</li>\n<li>关联词：interceptor（名词） </li>\n</ul>\n</li>\n<li>sort<ul>\n<li>解释：按顺序排列</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>学习/研究/分析</p>\n<ul>\n<li>study</li>\n<li>learn</li>\n<li>research<ul>\n<li>解释：不断寻找和检查来研究某事物</li>\n</ul>\n</li>\n<li>analyze<ul>\n<li>解释：对当前主题进行分析</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>覆盖</p>\n<ul>\n<li>cover<ul>\n<li>解释：把某事物放在某事物上面，如隐藏和保护</li>\n</ul>\n</li>\n<li>overlap<ul>\n<li>解释：延伸并部分覆盖或者替代掉某物</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>固定搭配</p>\n<ul>\n<li>fetch<ul>\n<li>解释：获取东西</li>\n<li>关联词：store   </li>\n</ul>\n</li>\n<li><p>store</p>\n<ul>\n<li>解释：将东西保存起来以备以后使用</li>\n<li>关联词：fetch</li>\n</ul>\n</li>\n<li><p>start</p>\n<ul>\n<li>解释：较随意的开始/创立</li>\n</ul>\n</li>\n<li><p>stop</p>\n<ul>\n<li>解释：较随意的结束</li>\n</ul>\n</li>\n<li><p>begin</p>\n<ul>\n<li>解释：从头开始</li>\n</ul>\n</li>\n<li><p>end</p>\n<ul>\n<li>解释：终点结束</li>\n</ul>\n</li>\n<li><p>enter</p>\n<ul>\n<li>解释：加入/进入/开始从事/开始活动</li>\n</ul>\n</li>\n<li><p>exit</p>\n<ul>\n<li>解释：退出（计算机程序）</li>\n</ul>\n</li>\n<li><p>open</p>\n<ul>\n<li>解释：参考文件系统使用方法</li>\n</ul>\n</li>\n<li><p>close</p>\n<ul>\n<li>解释：参考文件系统使用方法</li>\n</ul>\n</li>\n<li><p>input</p>\n<ul>\n<li>解释：第三人称描述某个事物的输入</li>\n<li>关联词：receive（第一人称）</li>\n</ul>\n</li>\n<li><p>output</p>\n<ul>\n<li>解释：第三人称描述某个事物的输出</li>\n<li>关联词：transmit（第一人称）</li>\n</ul>\n</li>\n<li><p>upload</p>\n<ul>\n<li>解释：上传到服务器或者别的电脑</li>\n</ul>\n</li>\n<li><p>download</p>\n<ul>\n<li>解释：从服务器或者别的电脑下载</li>\n</ul>\n</li>\n<li><p>set</p>\n<ul>\n<li>解释：设置</li>\n</ul>\n</li>\n<li><p>clear</p>\n<ul>\n<li>解释：清除</li>\n<li>缩写：clr</li>\n</ul>\n</li>\n<li><p>init</p>\n<ul>\n<li>解释：是一个实例的初始化方法</li>\n</ul>\n</li>\n<li><p>deinit</p>\n<ul>\n<li>解释：释放内存</li>\n</ul>\n</li>\n<li><p>plus</p>\n<ul>\n<li>解释：加法</li>\n</ul>\n</li>\n<li><p>minus</p>\n<ul>\n<li>解释：减法</li>\n</ul>\n</li>\n<li><p>subscribe</p>\n<ul>\n<li>解释：订阅</li>\n<li>缩写：subs</li>\n</ul>\n</li>\n<li><p>publish</p>\n<ul>\n<li>解释：发布</li>\n<li>缩写：pub</li>\n</ul>\n</li>\n<li><p>add</p>\n<ul>\n<li>解释：增加某东西</li>\n</ul>\n</li>\n<li><p>sub</p>\n<ul>\n<li>解释：减去某东西</li>\n</ul>\n</li>\n<li><p>pend</p>\n<ul>\n<li>参考操作系统</li>\n</ul>\n</li>\n<li><p>post</p>\n<ul>\n<li>参考操作系统</li>\n</ul>\n</li>\n<li><p>error</p>\n<ul>\n<li>解释：err</li>\n<li>缩写：</li>\n</ul>\n</li>\n<li>ok<ul>\n<li>解释：</li>\n<li>缩写：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>append<ul>\n<li>解释：在结尾插入内容</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>calculate</p>\n<ul>\n<li>解释：计算</li>\n<li>缩写：calc</li>\n</ul>\n</li>\n<li><p>contain</p>\n<ul>\n<li>解释：包含/含有/容纳</li>\n</ul>\n</li>\n<li><p>erase</p>\n<ul>\n<li>解释：flash专用</li>\n</ul>\n</li>\n<li><p>indicate</p>\n<ul>\n<li>解释：指示</li>\n<li>关联词：confirm</li>\n</ul>\n</li>\n<li><p>initialize</p>\n<ul>\n<li>解释：类的方法，在所有实例方法和类方法执行前运行</li>\n</ul>\n</li>\n<li><p>notify</p>\n<ul>\n<li>解释：正式通报，通知</li>\n</ul>\n</li>\n<li><p>implement</p>\n<ul>\n<li>解释：实现</li>\n<li>缩写：impl</li>\n</ul>\n</li>\n<li><p>remove</p>\n<ul>\n<li>解释：拿走，但内存还在</li>\n<li>关联词：delete（删除释放内存）、recover</li>\n</ul>\n</li>\n<li><p>transfer</p>\n<ul>\n<li>解释：移交/转移</li>\n</ul>\n</li>\n<li><p>translate</p>\n<ul>\n<li>解释：转变/变为</li>\n</ul>\n</li>\n<li><p>overflow</p>\n<ul>\n<li>解释：溢出某个容器</li>\n</ul>\n</li>\n<li><p>peek</p>\n<ul>\n<li>解释：偷看一眼</li>\n</ul>\n</li>\n<li><p>process</p>\n<ul>\n<li>解释：对data作一些的操作或处理</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-3-形容词\"><a href=\"#6-3-形容词\" class=\"headerlink\" title=\"6.3. 形容词\"></a>6.3. 形容词</h2><ul>\n<li><p>固定搭配</p>\n<ul>\n<li>valid<ul>\n<li>解释：有效的</li>\n</ul>\n</li>\n<li><p>invalid</p>\n<ul>\n<li>解释：无效的</li>\n</ul>\n</li>\n<li><p>busy</p>\n<ul>\n<li>解释：忙</li>\n</ul>\n</li>\n<li><p>idle</p>\n<ul>\n<li>解释：空闲</li>\n</ul>\n</li>\n<li><p>used</p>\n<ul>\n<li>解释：已使用</li>\n</ul>\n</li>\n<li>unused<ul>\n<li>解释：没用着的/空闲的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>描述真实/真的</p>\n<ul>\n<li>actual<ul>\n<li>解释：形容客观存在的事实或者行为</li>\n</ul>\n</li>\n<li>real<ul>\n<li>解释：真实的/实际存在的，对真理的描述</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>描述大小</p>\n<ul>\n<li>larger<ul>\n<li>解释：强调体积/能力/数量</li>\n</ul>\n</li>\n<li>bigger<ul>\n<li>解释：表示由“重”的意思，重要/重量。</li>\n</ul>\n</li>\n<li>smaller<ul>\n<li>解释：无关紧要的/小的数量</li>\n</ul>\n</li>\n<li>little<ul>\n<li>解释：小的尺寸/只有一点点</li>\n</ul>\n</li>\n<li>tiny<ul>\n<li>解释：极小的/微小的/微量的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>different</p>\n<ul>\n<li>解释：不同</li>\n<li>缩写：diff</li>\n</ul>\n</li>\n<li><p>equal</p>\n<ul>\n<li>解释：大小、价值、数量相等或相同</li>\n</ul>\n</li>\n<li><p>expected</p>\n<ul>\n<li>解释：预料的/预期的</li>\n</ul>\n</li>\n<li><p>initial</p>\n<ul>\n<li>解释：初始化的</li>\n</ul>\n</li>\n<li><p>remain</p>\n<ul>\n<li>解释：仍然存在/可以使用/还没被处理</li>\n</ul>\n</li>\n<li><p>temp</p>\n<ul>\n<li>解释：临时</li>\n<li>缩写：tmp</li>\n</ul>\n</li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/cmsis_include.png","slug":"cmsis_include.png","post":"ck22u8q7n0010gcg80gh53b3j","modified":0,"renderable":0},{"_id":"source/_posts/ADC相关性能参数概念/量化误差.jpg","slug":"量化误差.jpg","post":"ck22u8q5u0000gcg8fuq0yyqk","modified":0,"renderable":0},{"_id":"source/_posts/浅谈BLE核心架构和数据帧/ble_communicate.svg","slug":"ble_communicate.svg","post":"ck22u8q690008gcg84iaxzygv","modified":0,"renderable":0},{"_id":"source/_posts/浅谈BLE核心架构和数据帧/ble_core_architecture.png","slug":"ble_core_architecture.png","post":"ck22u8q690008gcg84iaxzygv","modified":0,"renderable":0},{"_id":"source/_posts/浅谈BLE核心架构和数据帧/ble_core_traffic_bearers.png","slug":"ble_core_traffic_bearers.png","post":"ck22u8q690008gcg84iaxzygv","modified":0,"renderable":0},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/create_template_mdk.gif","slug":"create_template_mdk.gif","post":"ck22u8q7n0010gcg80gh53b3j","modified":0,"renderable":0},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/nrfx_config.png","slug":"nrfx_config.png","post":"ck22u8q7n0010gcg80gh53b3j","modified":0,"renderable":0},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/port_done.gif","slug":"port_done.gif","post":"ck22u8q7n0010gcg80gh53b3j","modified":0,"renderable":0},{"_id":"source/_posts/rtt-nimble揭秘系列——移植bsp（2）/rtconfig_keil.png","slug":"rtconfig_keil.png","post":"ck22u8q7n0010gcg80gh53b3j","modified":0,"renderable":0},{"_id":"source/_posts/rtt-nimble揭秘系列——移植nimble（3）/ble_hr.gif","slug":"ble_hr.gif","post":"ck22u8q8l001hgcg8gwvpjcki","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/7^xmod13=8.png","slug":"7^xmod13=8.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/7^xmod13=y.png","slug":"7^xmod13=y.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/BleImportantPerson.png","slug":"BleImportantPerson.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/CCM.epgz","slug":"CCM.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/CCM.png","slug":"CCM.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/DH.epgz","slug":"DH.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/DH.png","slug":"DH.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/ECDH.epgz","slug":"ECDH.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/ECDH.png","slug":"ECDH.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/ECDHMITM.epgz","slug":"ECDHMITM.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/ECDHMITM.png","slug":"ECDHMITM.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/ImportantPerson.epgz","slug":"ImportantPerson.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/ImportantPerson.png","slug":"ImportantPerson.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/KindOfPhase.epgz","slug":"KindOfPhase.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/KindOfPhase.png","slug":"KindOfPhase.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/MAC.png","slug":"MAC.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/MITM.epgz","slug":"MITM.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/MITM.png","slug":"MITM.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/SecurityTechnology.epgz","slug":"SecurityTechnology.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/SecurityTechnology.png","slug":"SecurityTechnology.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/SmpAndEncryption.epgz","slug":"SmpAndEncryption.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/SmpAndEncryption.png","slug":"SmpAndEncryption.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/SymmetricCryptography.epgz","slug":"SymmetricCryptography.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/SymmetricCryptography.png","slug":"SymmetricCryptography.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/authentication.epgz","slug":"authentication.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/authentication.png","slug":"authentication.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/camouflage.epgz","slug":"camouflage.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/camouflage.png","slug":"camouflage.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/g^xmodp=y.png","slug":"g^xmodp=y.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/tamper.epgz","slug":"tamper.epgz","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/tamper.png","slug":"tamper.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/BLE安全机制从入门到放弃/y=xg.png","slug":"y=xg.png","post":"ck22u8qal001lgcg8edulpzf9","modified":0,"renderable":0},{"_id":"source/_posts/ADC相关性能参数概念/DNL.jpg","slug":"DNL.jpg","post":"ck22u8q5u0000gcg8fuq0yyqk","modified":1,"renderable":0},{"_id":"source/_posts/ADC相关性能参数概念/INL.jpg","slug":"INL.jpg","post":"ck22u8q5u0000gcg8fuq0yyqk","modified":1,"renderable":0}],"PostCategory":[{"post_id":"ck22u8q690008gcg84iaxzygv","category_id":"ck22u8q640004gcg82ifv6mvm","_id":"ck22u8q6d000fgcg8g60hgyqu"},{"post_id":"ck22u8q620002gcg8s2nc8jne","category_id":"ck22u8q640004gcg82ifv6mvm","_id":"ck22u8q6e000ggcg8w3i18cpz"},{"post_id":"ck22u8q660006gcg8ceycd20z","category_id":"ck22u8q6c000cgcg81o0cybtw","_id":"ck22u8q6f000jgcg879g13vs5"},{"post_id":"ck22u8q680007gcg8k0tph1f7","category_id":"ck22u8q6c000cgcg81o0cybtw","_id":"ck22u8q6g000lgcg8hi6yfs26"},{"post_id":"ck22u8q7n0010gcg80gh53b3j","category_id":"ck22u8q6c000cgcg81o0cybtw","_id":"ck22u8q7s0016gcg86sa0te9l"},{"post_id":"ck22u8q7o0011gcg8qgvewd9p","category_id":"ck22u8q7r0013gcg8466mehaj","_id":"ck22u8q7t0018gcg81832s158"},{"post_id":"ck22u8q8l001hgcg8gwvpjcki","category_id":"ck22u8q6c000cgcg81o0cybtw","_id":"ck22u8q8n001kgcg8hjybfwv1"},{"post_id":"ck22u8qal001lgcg8edulpzf9","category_id":"ck22u8q6c000cgcg81o0cybtw","_id":"ck22u8qau001pgcg8jra4rbjx"},{"post_id":"ck22u8qar001mgcg8ps0fovs4","category_id":"ck22u8qau001ogcg8oq9u6xfo","_id":"ck22u8qaw001sgcg8qhjtsjnx"},{"post_id":"ck22u8q5u0000gcg8fuq0yyqk","category_id":"ck22u8q640004gcg82ifv6mvm","_id":"ck260b8fm001bx8g8iowa470x"}],"PostTag":[{"post_id":"ck22u8q620002gcg8s2nc8jne","tag_id":"ck22u8q6a000agcg8wsyw4f9z","_id":"ck22u8q6j000ngcg8iqbr1zzs"},{"post_id":"ck22u8q620002gcg8s2nc8jne","tag_id":"ck22u8q6d000egcg80czlwyls","_id":"ck22u8q6n000ogcg8vi911xj8"},{"post_id":"ck22u8q620002gcg8s2nc8jne","tag_id":"ck22u8q6e000igcg8innvuzqk","_id":"ck22u8q6n000qgcg8c3fzykaf"},{"post_id":"ck22u8q620002gcg8s2nc8jne","tag_id":"ck22u8q6f000kgcg893m7schg","_id":"ck22u8q6o000rgcg8ohxajprr"},{"post_id":"ck22u8q660006gcg8ceycd20z","tag_id":"ck22u8q6g000mgcg8bhuc1sqr","_id":"ck22u8q6o000tgcg8s6pjt8lb"},{"post_id":"ck22u8q660006gcg8ceycd20z","tag_id":"ck22u8q6n000pgcg8zgegnkzv","_id":"ck22u8q6o000ugcg8c8wfxhxk"},{"post_id":"ck22u8q680007gcg8k0tph1f7","tag_id":"ck22u8q6g000mgcg8bhuc1sqr","_id":"ck22u8q6q000xgcg825wjb8cp"},{"post_id":"ck22u8q680007gcg8k0tph1f7","tag_id":"ck22u8q6n000pgcg8zgegnkzv","_id":"ck22u8q6q000ygcg8og3u4tig"},{"post_id":"ck22u8q690008gcg84iaxzygv","tag_id":"ck22u8q6p000wgcg8negyfh9x","_id":"ck22u8q6q000zgcg8p52t4xdy"},{"post_id":"ck22u8q7n0010gcg80gh53b3j","tag_id":"ck22u8q6g000mgcg8bhuc1sqr","_id":"ck22u8q7p0012gcg8boj8752e"},{"post_id":"ck22u8q7n0010gcg80gh53b3j","tag_id":"ck22u8q6n000pgcg8zgegnkzv","_id":"ck22u8q7r0015gcg8apdqceb3"},{"post_id":"ck22u8q7o0011gcg8qgvewd9p","tag_id":"ck22u8q7r0014gcg82fevzmb7","_id":"ck22u8q7u001cgcg8093bkd2y"},{"post_id":"ck22u8q7o0011gcg8qgvewd9p","tag_id":"ck22u8q7s0017gcg8nz6t9d44","_id":"ck22u8q7u001dgcg8chb3o68f"},{"post_id":"ck22u8q7o0011gcg8qgvewd9p","tag_id":"ck22u8q7t0019gcg8wl9y6ppy","_id":"ck22u8q7u001egcg8h5zalc49"},{"post_id":"ck22u8q7o0011gcg8qgvewd9p","tag_id":"ck22u8q7t001agcg8xk6mee5g","_id":"ck22u8q7v001fgcg8zre68op6"},{"post_id":"ck22u8q7o0011gcg8qgvewd9p","tag_id":"ck22u8q7u001bgcg8rm0h9ohh","_id":"ck22u8q7v001ggcg87m3dkvej"},{"post_id":"ck22u8q8l001hgcg8gwvpjcki","tag_id":"ck22u8q6g000mgcg8bhuc1sqr","_id":"ck22u8q8m001igcg8xk300fd7"},{"post_id":"ck22u8q8l001hgcg8gwvpjcki","tag_id":"ck22u8q6n000pgcg8zgegnkzv","_id":"ck22u8q8n001jgcg8altn25ld"},{"post_id":"ck22u8qal001lgcg8edulpzf9","tag_id":"ck22u8qas001ngcg8v6i1nncc","_id":"ck22u8qax001ugcg84x62b0cb"},{"post_id":"ck22u8qal001lgcg8edulpzf9","tag_id":"ck22u8qav001qgcg8vm5ki951","_id":"ck22u8qay001vgcg8ecrxnv00"},{"post_id":"ck22u8qal001lgcg8edulpzf9","tag_id":"ck22u8qaw001rgcg8kgz4hujc","_id":"ck22u8qay001xgcg8mc7ssuqn"},{"post_id":"ck22u8qar001mgcg8ps0fovs4","tag_id":"ck22u8qax001tgcg8nos52gtu","_id":"ck22u8qaz001ygcg829kn90dh"},{"post_id":"ck22u8qar001mgcg8ps0fovs4","tag_id":"ck22u8qay001wgcg87gbovbny","_id":"ck22u8qaz001zgcg8ec1k0sdn"},{"post_id":"ck22u8q5u0000gcg8fuq0yyqk","tag_id":"ck22u8q660005gcg8bsptify8","_id":"ck260b8fl001ax8g8zc48fk6p"}],"Tag":[{"name":"ADC","_id":"ck22u8q660005gcg8bsptify8"},{"name":"hardfault","_id":"ck22u8q6a000agcg8wsyw4f9z"},{"name":"cortex","_id":"ck22u8q6d000egcg80czlwyls"},{"name":"debug","_id":"ck22u8q6e000igcg8innvuzqk"},{"name":"栈帧回溯","_id":"ck22u8q6f000kgcg893m7schg"},{"name":"rtthread","_id":"ck22u8q6g000mgcg8bhuc1sqr"},{"name":"nimble","_id":"ck22u8q6n000pgcg8zgegnkzv"},{"name":"ble","_id":"ck22u8q6p000wgcg8negyfh9x"},{"name":"Hexo","_id":"ck22u8q7r0014gcg82fevzmb7"},{"name":"博客","_id":"ck22u8q7s0017gcg8nz6t9d44"},{"name":"搭建","_id":"ck22u8q7t0019gcg8wl9y6ppy"},{"name":"配置","_id":"ck22u8q7t001agcg8xk6mee5g"},{"name":"工具","_id":"ck22u8q7u001bgcg8rm0h9ohh"},{"name":"BLE","_id":"ck22u8qas001ngcg8v6i1nncc"},{"name":"安全机制","_id":"ck22u8qav001qgcg8vm5ki951"},{"name":"蓝牙","_id":"ck22u8qaw001rgcg8kgz4hujc"},{"name":"代码","_id":"ck22u8qax001tgcg8nos52gtu"},{"name":"整洁","_id":"ck22u8qay001wgcg87gbovbny"}]}}